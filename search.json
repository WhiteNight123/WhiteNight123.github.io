[{"title":"ä¿ç ”ç»éªŒè´´","path":"/2024/09/29/ä¿ç ”ç»éªŒè´´/","content":"2024å¹´ï¼ˆ25å±Šï¼‰å››éè®¡ç®—æœºä¿ç ”ç»éªŒè´´ï¼ˆæµ™è½¯ï¼ŒåŒ—é‚®ï¼Œé‡å¤§ï¼Œæˆç”µï¼Œè¥¿ç”µæ­ï¼Œæ·±å¤§ï¼‰[TOC] å‰è¨€ä»Šå¹´æ˜¯å¯¹å››éåœ°ç‹±çº§å¤–ä¿éš¾åº¦çš„ä¸€å¹´ï¼ˆä»¥åä¼šæ›´éš¾ğŸ¤¡ï¼‰ï¼Œå¤§éƒ¨åˆ†å­¦æ ¡ä¿ç ”ç‡æå‡ï¼Œç››è¡Œæœ¬æ ¡ä¿æŠ¤ï¼Œå·¥ç¨‹ç¡•åšè®¡åˆ’å ç”¨å¤§é‡åé¢ï¼Œå¾ˆå¤šå­¦æ ¡å¼€å§‹ä¼˜åŒ–ç”Ÿæºè´¨é‡ï¼Œä½†æ‰€å¹¸æˆ‘çš„ç»“æœä¹Ÿè¿˜ä¸é”™ã€‚ ä¸ªäººæƒ…å†µå­¦æ ¡ï¼šæŸè¥¿å—åœ°åŒºå››é ä¸“ä¸šï¼šè½¯ä»¶å·¥ç¨‹ rkï¼šå‰äº”å­¦æœŸæ’å3360ï¼ˆå¤ä»¤è¥æ ¹æœ¬è¿‡ä¸äº†ï¼‰ï¼Œå…­å­¦æœŸç»¼åˆæ’å1530ï¼ˆæ’åå‡ºçš„å¤ªæ™šäº†ï¼Œå¾ˆå¤šå¥½å­¦æ ¡å·²ç»æˆªæ­¢äº†ï¼‰ã€‚ å››å…­çº§ï¼š4çº§490ï¼Œ6çº§æ²¡è¿‡ï¼ˆå¤ä»¤è¥è¢«æ‹’å¾—å¿«å¥”æºƒäº†ï¼‰ï¼Œé¢„æ¨å…450ï¼ˆå‹‰å¼ºèƒ½ç”¨ï¼‰ ç«èµ›ï¼šè“æ¡¥æ¯å›½ä¸€ï¼Œè½¯ä»¶æ¯å›½ä¸‰ï¼Œæ•°æ¨¡çœä¸€ï¼ˆå¤§éƒ¨åˆ†è€å¸ˆä¸çœ‹ï¼Œç”šè‡³æœ‰è€å¸ˆé—®è“æ¡¥æ¯æ˜¯ä»€ä¹ˆæ¯”èµ›ğŸ¤¡ï¼‰ ç§‘ç ”ï¼šğŸˆšï¼Œæå¤§çš„çŸ­æ¿ rkâ‰ˆé¡¶çº§ç§‘ç ”6çº§ç«èµ› ç›®æ ‡ï¼šä¸­9æˆ–åŒ—é‚®ã€‚ æœ€ç»ˆå»å‘ï¼šæµ™æ±Ÿå¤§å­¦è½¯ä»¶å­¦é™¢äººå·¥æ™ºèƒ½ä¸“ä¸šã€‚ å¤ä»¤è¥å…¥è¥æƒ…å†µä¸æ˜¯rk1+æ²¡è¿‡6çº§ï¼Œå¤ä»¤è¥æå…¶æƒ¨æ·¡ï¼ŒçœŸçš„å¿«å´©æºƒäº†ã€‚ å­¦æ ¡ å­¦é™¢ çŠ¶æ€ å¤‡æ³¨ å—äº¬å¤§å­¦ æ™ºèƒ½è½¯ä»¶ æœªå…¥ æŠ•ç€ç© å—äº¬å¤§å­¦ è½¯ä»¶ æœªå…¥ åŒæ€ åŒ—äº¬é‚®ç”µå¤§å­¦ è®¡ç®—æœº é¢è¯•å¯„ é¢è¯•15minï¼Œå¯„äº† æµ™æ±Ÿå¤§å­¦ è½¯ä»¶ ä¼˜è¥ é¢„æ¨å…å…¥åœºåˆ¸ è¥¿åŒ—å·¥ä¸šå¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸æ‡‚ ä¸­å±±å¤§å­¦ è½¯ä»¶ æœªå…¥ æŠ•ç€ç© ç”µå­ç§‘æŠ€å¤§å­¦ æ™ºèƒ½è®¡ç®— æœªå…¥ æŠ•ç€ç© å±±ä¸œå¤§å­¦ è½¯ä»¶ å®£è®²è¥ æµ·è¥ ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ å…ˆç ”é™¢ æœªå…¥ å‘äº†20å°é‚®ä»¶ï¼Œæ— æœ åŒ—äº¬å¸ˆèŒƒå¤§å­¦ äººå·¥æ™ºèƒ½ æœªå…¥ æŠ•ç€ç© åŒ—äº¬ç†å·¥å¤§å­¦ ç æµ· æœªå…¥ æŠ•ç€ç© åŒ—äº¬äº¤é€šå¤§å­¦ è®¡ç®—æœº æœªå…¥ ä¸æ‡‚ åå—ç†å·¥å¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸æ‡‚ æ·±åœ³å¤§å­¦ è®¡ç®—æœº ä¼˜è¥ å€™è¡¥ç¬¬äºŒæ‰¹å…¥äº† é‡åº†å¤§å­¦ è®¡ç®—æœº æœªå…¥ å¡åŒä¸€æµ é‡åº†å¤§å­¦ å·¥ç¨‹å¸ˆ æœªå…¥ åŒæ€ é‡åº†å¤§å­¦ è½¯ä»¶ æœªå…¥ ä¸‰æ€ åŒ—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è®¡ç®—æœº æœªå…¥ æŠ•ç€ç© åŒ—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è½¯ä»¶ æœºè¯•å¯„ ä¸æ˜¯acmer ä»ä¸Šé¢çš„è¡¨å¯ä»¥çœ‹åˆ°ï¼Œå¤ä»¤è¥ååˆ†æƒ¨çƒˆï¼Œåªæ‹¿åˆ°äº†æ·±å¤§çš„offerå’Œæµ™è½¯é¢„æ¨å…çš„å…¥åœºåˆ¸ã€‚ åŒ—äº¬é‚®ç”µå¤§å­¦è®¡ç®—æœºï¼Œå¯„äº†å…¥äº†11ç»„ï¼Œè¯´æ˜¯ä»200äººé‡Œé€‰äº†40äººï¼Œæœ€ç»ˆå½•å–8äººã€‚çº¿ä¸Š15åˆ†é’Ÿé¢è¯•ï¼Œ8åˆ†é’Ÿè‡ªæˆ‘ä»‹ç»ï¼Œç„¶åæ˜¯æé—®é¡¹ç›®ï¼Œç¬¬ä¸€æ¬¡é¢è¯•ï¼Œå‡†å¤‡ä¸å……åˆ†ï¼Œç»“æœå°±æ˜¯å¯„äº†ã€‚ æµ™è½¯ï¼Œä¼˜è¥çº¿ä¸Šï¼Œæ€»å…±å…¥äº†2700äººï¼Œæˆ‘é€‰çš„æ˜¯å¤§æ•°æ®åˆ†è¥ï¼Œç„¶åé‡Œé¢è¿˜è¦å†åˆ†å›¢é˜Ÿã€‚æˆ‘ä»¬å›¢é˜Ÿæ˜¯é˜…è¯»ä¸€ç¯‡è®ºæ–‡ï¼Œç„¶ååšä¸€ä¸ªæ±‡æŠ¥+é¢è¯•ï¼Œå‡†å¤‡äº†ä¸€ä¸ªæ˜ŸæœŸï¼Œä¼˜äº†ã€‚ä»Šå¹´å‡ºç°äº†å“è¶Šè¥å‘˜ï¼ˆåªèƒ½æ˜¯985å’ŒåŒ—é‚®è¥¿ç”µï¼‰ç›¸å½“äºé“offerï¼Œç„¶åæ˜¯ä¼˜ç§€è¥å‘˜ï¼ˆé¢„æ¨å…å…¥åœºåˆ¸ï¼‰ï¼Œä»Šå¹´çš„barå¼‚å¸¸çš„é«˜ï¼Œå¯¹äºåŒéå’Œ211åŸºæœ¬é ä¼˜è¥æ‰èƒ½è¿›é¢„æ¨å…ã€‚ä¼˜ç§€è¥å‘˜å æ¯”10%ï¼Œå“è¶Šè¥å‘˜å æ¯”3%ã€‚ æ·±åœ³å¤§å­¦ï¼Œä¼˜è¥å”¯ä¸€ä¸€ä¸ªçº¿ä¸‹çš„å¤ä»¤è¥ï¼Œç”±äºæ˜¯æ— æ¡ä»¶æŠ¥é”€800å…ƒï¼Œå…¥è¥é—¨æ§›è¾ƒé«˜ï¼Œå€™è¡¥äº†ä¸¤è½®è¿›å»äº†ã€‚é¦–å…ˆå°±æ˜¯å¬è®²åº§ï¼Œç¬¬ä¸€å¤©æ™šä¸Šæ¨¡æ‹Ÿæœºè¯•ï¼Œç¬¬äºŒå¤©æ™šä¸Šæ­£å¼æœºè¯•ï¼Œéš¾åº¦ä¸€èˆ¬æ•°æ®ç»“æ„çš„æ°´å¹³ï¼Œåé¢æœ‰ä¸€ç‚¹ç‚¹éš¾ï¼Œæœ€å70åˆ†ï¼Œç¬¬ä¸‰å¤©ä¸‹åˆæ˜¯é¢è¯•ã€‚é¢è¯•æ–¹å¼ä¸ºç¾¤é¢ï¼Œåˆ†åˆ°å„ä¸ªå›¢é˜Ÿé‡Œï¼Œä»¥åœ†æ¡Œä¼šè®®çš„æ–¹å¼èŠå¤©ï¼Œæœ€åæ‹¿åˆ°ä¼˜è¥offerï¼ˆç–‘ä¼¼æœºè¯•ä¸çˆ†é›¶å°±ç»™ï¼‰ã€‚ ä¸å¾—ä¸è¯´ï¼Œæ·±å¤§æ˜¯çœŸçš„æœ‰é’±ï¼Œå¦‚æœä¸æ˜¯å››éå°±å¥½äº†ã€‚ é¢„æ¨å…å…¥è¥æƒ…å†µ å­¦æ ¡ å­¦é™¢ çŠ¶æ€ å¤‡æ³¨ æµ™æ±Ÿå¤§å­¦ è½¯ä»¶å­¦é™¢ å€™è¡¥3 æœ€ç»ˆå»å‘ å—äº¬å¤§å­¦ è½¯ä»¶å­¦é™¢ æœªå…¥ æŠ•ç€ç© å—äº¬å¤§å­¦ æ™ºèƒ½è½¯ä»¶ æœªå…¥ æŠ•ç€ç© ä¸­å—å¤§å­¦ è®¡ç®—æœº æœªå…¥ æœ‰ç‚¹è¿· æ¹–å—å¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æœ‰ç‚¹è¿· æ¹–å—å¤§å­¦ ä¿¡æ¯å­¦é™¢ æœªå…¥ æœ‰ç‚¹è¿· ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ ç§‘å­¦å²› æœªå…¥ æœ‰ç‚¹è¿· ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æŠ•ç€ç© å±±ä¸œå¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ æ—¶é—´å¤ªé•¿å’Œé‡å¤§å†²çªäº† å¤§è¿ç†å·¥å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ å’Œæµ™è½¯å†²çªäº† åŒæµå¤§å­¦ å·¥ç¨‹ç¡•åš æœªå…¥ æŠ•ç€ç© è¥¿å®‰ç”µå­ç§‘æŠ€å¤§å­¦ å“å·¥ å·²å…¥,å¯„ ä½“éªŒäº†ä¸€ä¸‹ å—äº¬èˆªç©ºèˆªå¤©å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ å’Œæµ™è½¯å†²çªäº† ç”µå­ç§‘æŠ€å¤§å­¦ è®¡ç®—æœº å·²å…¥,é¸½ æµ™è½¯å€™è¡¥åˆ°äº†ï¼Œæ²¡å» é‡åº†å¤§å­¦ è®¡ç®—æœº å€™è¡¥,é¸½ ä½“éªŒäº†ä¸€ä¸‹ åŒ—äº¬é‚®ç”µå¤§å­¦ è®¡ç®—æœº è¢«é¸½ è¢«è€å¸ˆé¸½äº†ğŸ¤¡ï¼Œåæœ‰æƒŠå–œ å¯ä»¥çœ‹åˆ°ï¼Œé¢„æ¨å…çš„æ—¶å€™æˆ‘æ¨å…æ’åæé«˜ï¼Œå…¥è¥æƒ…å†µä¹Ÿç¨å¾®å¥½ç‚¹äº†ã€‚ä½†ç”±äºä»Šå¹´å¤§éƒ¨åˆ†å­¦æ ¡æå‡ç”Ÿæºè´¨é‡ï¼Œé¢„æ¨å…ä»ç„¶è‰°éš¾ã€‚ æµ™è½¯æµ™è½¯æ˜¯æˆ‘é¢„æ¨å…çš„ç¬¬ä¸€ç«™ï¼Œä¹Ÿæ˜¯æˆ‘çš„æœ€ç»ˆå»å‘ã€‚ ä»Šå¹´barå¾ˆé«˜ï¼Œç”±äºæœ‰å¤ä»¤è¥çš„ä¼˜è¥ï¼Œè¿‡äº†åˆç­›ï¼Œä»Šå¹´åŒérk1åŸºæœ¬è¿›ä¸å»ã€‚é¢„æ¨å…æ€»å…±ç­›äº†è¿‘800äººï¼Œçº¿ä¸‹æ¥äº†540äººï¼Œç”Ÿæºæ˜æ˜¾æ¯”å»å¹´æé«˜äº†ï¼Œå¤§æ¦‚90%éƒ½æ˜¯9çˆ·ã€‚ æµ™è½¯å¤è¯•åˆ†ä¸ºæœºè¯•å’Œé¢è¯•ï¼Œæœºè¯•å æ¯”15%ï¼Œç¬¬ä¸€å¤©æ™šä¸Šå¼€å§‹æœºè¯•ï¼Œå…±4é“é¢˜ï¼Œéš¾åº¦ä»¥æ­¤é€’å¢ï¼Œé¢˜ç›®èƒŒæ™¯å‡ä¸èµ¤å£ç›¸å…³ï¼ˆè€ƒå¯Ÿäº†ç®€å•æ•°å­¦ï¼Œdfsï¼Œdpï¼ŒäºŒåˆ†ï¼‰ï¼Œéš¾åº¦æ¯”å»å¹´ç•¥å¤§ï¼Œä½†æ˜¯akäººæ•°æ›´å¤šäº†ï¼Œæˆ‘1ä¸ªåŠå°æ—¶akï¼Œæ’å40+ï¼Œç­‰åˆ°ç»“æŸæ—¶ï¼Œçº¦130ä¸ªakï¼Œ90åˆ†ä»¥ä¸Šçš„200+ã€‚å¬è¯´å¾€å¹´æ˜¯æŒ‰æœºè¯•ç»™é¢è¯•æˆç»©ï¼Œä½†ä»Šå¹´æœºè¯•æ²¡æœ‰åŒºåˆ†åº¦äº†ï¼ˆå¤ªå·äº†ï¼‰ï¼Œè€Œä¸”è€å¸ˆé¢è¯•çš„æ—¶å€™å¥½åƒçœ‹ä¸åˆ°ä½ çš„æœºè¯•æˆç»©ã€‚ 20å·æœºè¯•ï¼Œé¢è¯•æ’åˆ°22å·äº†ï¼Œæ—¶é—´20åˆ†é’Ÿï¼Œæœ‰ä¸ªè®¡æ—¶å™¨ã€‚æµ™è½¯ä¸åŒçš„ç»„é¢è¯•é£æ ¼å¾ˆä¸åŒã€‚æˆ‘ä»¬ç»„é¦–å…ˆæ¥ä¸ª1åˆ†é’Ÿè‹±æ–‡è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åå¼€å§‹ç”¨pptè®²5-8åˆ†é’Ÿã€‚æ¥ä¸‹æ¥é—®ä¸“ä¸šè¯¾ï¼Œæˆ‘é€‰æ‹©äº†è®¡ç½‘ï¼Œé—®äº†ä¸¤ä¸ªé—®é¢˜ï¼Œæ²¡å¬æ‡‚ï¼ˆğŸ¤¡ï¼‰ï¼Œç„¶åæ¢äº†æ•°æ®ç»“æ„ã€‚æ€ä¹ˆæ±‚æ ‘çš„ç›´å¾„ï¼Œæ€ä¹ˆæ±‚å›¾çš„ç›´å¾„ï¼Œæ ‘çš„ç›´å¾„å’Œå›¾çš„ç›´å¾„æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚å¦‚ä½•ç»´æŠ¤æ•°ç»„ä¸­çš„æœ€å¤§å€¼ï¼Œå¦‚ä½•å¿«é€Ÿæ±‚å‡ºä¸­ä½æ•°ã€‚ç”¨è¿‡stlå§ï¼Œå¦‚æœéœ€è¦ä¸€ä¸ªè‡ªåŠ¨æ’åºçš„é›†åˆï¼Œå¯ä»¥æœ‰é‡å¤çš„å…ƒç´ ï¼Œåº”è¯¥ç”¨ä»€ä¹ˆã€‚multisetæ’å…¥ä¸¤æ¬¡2ï¼Œeraseä¸€æ¬¡2ï¼Œç»“æœæ˜¯ä»€ä¹ˆã€‚sortå‡½æ•°ä»å°åˆ°å¤§æ’åºï¼Œæ¯”è¾ƒæ€ä¹ˆå†™ï¼Œå¦‚æœæŠŠæ”¹æˆæœ‰ä»€ä¹ˆåŒºåˆ«ã€‚ç­”çš„ç¨€çƒ‚ï¼Œç„¶åå¼€å§‹é—®é¡¹ç›®ï¼Œé¡¹ç›®é‡Œæœ‰ä¸ªæŠŠnä¸ªæ¨¡å‹åˆ†é…åˆ°mä¸ªè®¾å¤‡ï¼Œæˆ‘ä½¿ç”¨çš„çº¿æ€§è§„åˆ’ï¼Œè€å¸ˆè¯´è¿™æ˜¯ä¸€ä¸ªç®—æ³•é—®é¢˜ï¼Œåº”è¯¥ç”¨ä»€ä¹ˆç®—æ³•è§£å†³ï¼Œï¼ˆå®Œå…¨ä¸æ‡‚ğŸ¤¡ï¼‰ï¼Œç„¶ååˆé—®äº†ä¸€äº›é¡¹ç›®çš„ç»†èŠ‚ã€‚æœ€åé—®åˆ°ï¼Œå¤ä»¤è¥åœ¨å“ªä¸ªè¥ï¼Œå“ªä¸ªè¯¾é¢˜ç»„ï¼Œå¹²äº†äº›ä»€ä¹ˆã€‚å°±è¿™æ ·ç»“æŸäº†ã€‚ æ€»ä¹‹é¢å´©äº†ï¼Œå‡ºæ¥åæ•´ä¸ªäººéƒ½ä¸å¥½äº†ï¼Œé‚£ä¸ªä¸»é—®çš„è€å¸ˆåº”è¯¥æ˜¯æ‰“acmçš„ï¼Œçœ‹è§æˆ‘ç®—æ³•ä¸é”™ï¼Œç›´æ¥é—®åˆ°åº•ã€‚ã€‚ã€‚å¯æˆ‘ä¸æ˜¯acmerå•ŠğŸ˜­ã€‚åœ¨å¤–é¢åäº†ä¸€ä¼šå„¿ï¼Œæ„Ÿè§‰å¤©å¡Œäº†ï¼Œç„¶åå°±å»æ­å·è¥¿æ¹–æ•£æ•£å¿ƒï¼Œé¡ºä¾¿å‚åŠ è¥¿ç”µæ­çš„å¤è¯•ï¼ˆæœ¬æ¥æ‰“ç®—å¦‚æœç¨³äº†çš„è¯ï¼Œå°±ä¸å‚åŠ äº†ï¼‰ã€‚ 25å·å‡ºäº†ç»“æœï¼Œæ’å190+540ï¼Œå€™è¡¥ç¬¬ä¸‰ï¼Œç„¶åç¬¬äºŒå¤©å°±è¡¥åˆ°äº†ï¼Œä¸€æ­¥ç™»å¤©ï¼Œè·¨è¶ŠåŒéã€åŒä¸€æµã€211ã€æ™®é€š985è¿™äº›å­¦é™¢æ­§è§†é“¾ç›´æ¥æ¥åˆ°é¡¶æµ985æ°´å¹³ã€‚ psï¼šæµ™è½¯æ˜å¹´å°±æ¢æ–°æ ¡åŒºäº†ï¼Œæ¥äº†å¾ˆå¤šæ–°å¯¼å¸ˆï¼Œç”Ÿæºè´¨é‡ä¹Ÿä¸Šæ¥äº†ï¼Œä»¥åä¼šè¶Šæ¥è¶Šå¥½ï¼Œ24å…¥æµ™è½¯49å…¥å…šï¼Œè½¯å¾®å·²æ­»æµ™è½¯å½“ç«‹ï¼ è¥¿ç”µæ­æ¥ä¸Šï¼Œé¢å®Œäº†æµ™è½¯ï¼Œæ„Ÿè§‰å¤§å¯„ï¼Œå°±å»æ­å·é¢è¥¿ç”µæ­äº†ï¼Œå‡†å¤‡æ‹¿ä¸ªä¿åº•ã€‚ è¥¿ç”µæ­éœ€è¦å…ˆè”ç³»å¯¼å¸ˆï¼Œè¿™ä¸ªè€å¸ˆæ˜¯æˆ‘åœ¨æŠ¥å®Œç³»ç»Ÿåä¸»åŠ¨æ‰¾æˆ‘çš„ï¼Œç®€å•èŠäº†ä¸€ä¸‹ï¼Œæ–¹å‘ä¹Ÿè¿˜è¡Œï¼Œç„¶åå°±é€‰ä»–äº†ã€‚ å¤è¯•åˆ†ä¸ºç¬”è¯•å’Œé¢è¯•ï¼Œç¬”è¯•å†…å®¹ä¸ºé€šä¿¡ï¼Œæ•°æ®ç»“æ„ï¼Œè®¡ç»„ï¼Œè®¡ç½‘ï¼Œå¯†ç å­¦ã€‚åªä¼šå†™æ•°æ®ç»“æ„ã€‚ é¢è¯•å…ˆè‹±è¯­è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åç”¨è‹±è¯­ä»‹ç»ä¸€ä¸ªé¡¹ç›®ã€‚æ¥ç€å°±æ˜¯é—®é¡¹ç›®çš„ä¸€äº›ç»†èŠ‚ã€‚æœ€åè¿˜æœ‰æ€æ”¿é¢˜ï¼Œæ²¡ç­”ä¸Šæ¥ğŸ¤¡ã€‚ é¢å®Œæ„Ÿè§‰æ¯”è¾ƒæ°´ï¼Œç„¶åè¿‡äº†å‡ å¤©ä¹Ÿæ²¡æ¶ˆæ¯ï¼Œæˆ‘ä¹Ÿæ²¡å»è”ç³»è€å¸ˆï¼Œå…¸å‹çš„å­¦æ ¡å’Œå­¦ç”Ÿäº’é¸½ğŸ•Šï¸ï¼Œåæ­£æˆ‘æœ‰æµ™è½¯offeräº†ï¼Œä¸ç®¡ä»–äº†ã€‚ é‡å¤§è®¡ç®—æœºé‡å¤§ä»Šå¹´barå¾ˆè¿·ï¼Œè®¡ç®—æœºå¡rk1ï¼Œè½¯ä»¶å¡åŒä¸€æµï¼Œè€Œä¸”å¤è¯•è´¹150å…ƒã€‚ 26å·é¢è¯•ï¼Œäº¤äº†é’±éƒ½é¸½äº†13ã€‚é¢è¯•å†…å®¹ï¼šå…ˆè‹±è¯­è‡ªæˆ‘ä»‹ç»ï¼Œç„¶åå£è¯­å¯¹è¯ï¼ŒåŠå…¶ç®€å•ï¼Œæ„Ÿè§‰åƒæ˜¯å°å­¦ç”Ÿå¯¹è¯ï¼Œé—®äº†æˆ‘çš„sportsã€‚ç„¶åä¸“ä¸šè¯¾é—®äº†æ•°ç»„å¦‚ä½•æŸ¥è¯¢å›ºå®šåŒºé—´çš„å’Œï¼Œä½¿ç”¨å‰ç¼€å’Œã€‚æ¥ç€é—®é¡¹ç›®ï¼Œé‡å¤§çš„è€å¸ˆæ˜¯å”¯ä¸€ä¸€ä¸ªé—®äº†æˆ‘æ•°æ¨¡çš„é¡¹ç›®ï¼Œé—®çš„è¿˜æ¯”è¾ƒç»†ã€‚ç„¶åé—®äº†æˆ‘æŠ¥äº†å“ªäº›å­¦æ ¡ï¼Œæœ‰ä»€ä¹ˆofferï¼Œå…¶å®å½“æ—¶æˆ‘è¿˜æ˜¯0fferã€‚ç„¶åå°±ç»“æŸäº†ã€‚ ç”±äºçŸ¥é“æµ™è½¯è‚¯å®šèƒ½è¡¥åˆ°ï¼Œæ‰€ä»¥é‡å¤§é¢è¯•ä¹Ÿæ²¡æ€ä¹ˆä¸Šå¿ƒï¼Œè€Œä¸”é—®çš„ä¹Ÿæ¯”è¾ƒæ°´ã€‚ ç¬¬äºŒå¤©å‘Šè¯‰æˆ‘å€™è¡¥ï¼Œæ²¡æœ‰åå•ã€‚928ä¸‹åˆæ‰“ç”µè¯è¯´æˆ‘å€™è¡¥åˆ°äº†ï¼Œè®¡ç®—æœºå­¦ç¡•ï¼Œç„¶åæˆ‘æ‹’äº†ã€‚ psï¼šå¾€å¹´ç‚¹å‡»å°±é€çš„é‡å¤§ä¸è§äº†ã€‚ã€‚ã€‚ å†³æˆ˜929ä»Šå¹´ç³»ç»Ÿåˆæ”¹äº†ï¼Œ928ä¸Šåˆ9ç‚¹å¡«å¿—æ„¿ï¼Œ929ä¸Šåˆ9ç‚¹æ‹›ç”Ÿå•ä½å¼€å§‹å½•å–ï¼Œæ‰€ä»¥ä»Šå¹´çš„é¸½å­ä¼šåœ¨928å…ˆé£ä¸€æ‰¹ï¼Œç„¶å929å†é£ä¸€æ‰¹ã€‚ é¦–å…ˆç§‘æ™®ä¸€ä¸‹æ¨å…ç³»ç»Ÿ ä¸€ä¸ªå­¦ç”Ÿå¯ä»¥å¡«å†™ä¸‰ä¸ªç‹¬ç«‹å¿—æ„¿ ä¸€ä¸ªé™¢æ ¡å¯ä»¥ç»™å­¦ç”Ÿå‘æ”¾å¤è¯•ã€æ‹Ÿå½•å–é€šçŸ¥ å…ˆæ¥å—å¤è¯•ï¼Œå†æ¥å—æ‹Ÿå½•å– ä½†å¤è¯•ã€æ‹Ÿå½•å–ï¼Œéƒ½æ˜¯æœ‰æ—¶æ•ˆæ€§çš„ï¼Œæ¯”å¦‚10åˆ†é’Ÿå†…æ²¡æœ‰æ¥å—ï¼Œæ‹›ç”ŸåŠå¯èƒ½ä¼šæ”¶å›ä½ çš„offer åªè¦ä½ æ¥å—äº†æ‹Ÿå½•å–ï¼Œä½ çš„ä¿ç ”ç”Ÿæ¶¯å°±ä¼šç»“æŸ 9æœˆ28æ—¥9ç‚¹~9æœˆ29æ—¥9ç‚¹è¿™æ®µæ—¶é—´ï¼Œå­¦ç”Ÿå¯ä»¥å¡«å†™å¿—æ„¿ æ¯ä¸ªå¿—æ„¿å¡«å†™ä¹‹åè‡ªåŠ¨ä¸Šé”ï¼Œ48å°æ—¶ä¸å¯ä»¥ä¿®æ”¹ï¼ˆä½†æ˜¯é™¢æ ¡æ•™åŠ¡è€å¸ˆï¼Œå¯ä»¥å¸®ä½ è§£é”ä½ çš„å¿—æ„¿ï¼‰ 9æœˆ29æ—¥9ç‚¹ä¹‹åé™¢æ ¡æ‰å¯ä»¥å¼€å§‹å‘æ”¾å¤è¯•ã€æ‹Ÿå½•å–é€šçŸ¥ æ¯ä¸ªå¿—æ„¿æ˜¯å¹³è¡Œçš„ï¼Œé™¢æ ¡çœ‹ä¸åˆ°ä½ æ˜¯ç¬¬å‡ ä¸ªå¡«å†™çš„è¿™ä¸ªå¿—æ„¿ ä½†æ˜¯é™¢æ ¡ç»™ä½ å‘æ”¾é€šçŸ¥çš„æ—¶å€™ï¼Œå¯ä»¥çœ‹åˆ°ä½ æ¥å—äº†å“ªäº›å­¦æ ¡çš„å¤è¯• é¸½é“¾ååº”ï¼šè¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„ç°è±¡ åŸå› 1ï¼š å¯ä»¥ç†è§£ä¸º28å®šå¾‹ï¼Œ80%çš„offeråœ¨20%çš„äººä¸­ï¼Œä½†ä¹Ÿä¸å®Œå…¨æ˜¯ã€‚ åŸå› 2ï¼š æ¯”å¦‚å­¦ç”ŸAèƒ½åœ¨å¦å¤§å¤ä»¤è¥æ‹¿åˆ°ç¬¬1ï¼Œé‚£ä¹ˆä»–ç»ä¸å¯èƒ½åªæœ‰å¦å¤§è¿™ä¸ªofferï¼ŒAå¾ˆå¯èƒ½åœ¨åç§‘æ‹¿åˆ°offerç¬¬20æˆ–30ï¼Œäººå¤§æ‹¿åˆ°offerç¬¬60è¿™æ ·ï¼Œè€Œå¤æ—¦æ‹¿åˆ°å€™è¡¥åå•ç¬¬5ã€‚ ç»“æœAå‰é¢å‚åŠ å¤æ—¦å¤ä»¤è¥çš„äººåˆåŒæ—¶æ‹¿åˆ°æ¸…åŒ—ã€è®¡ç®—æ‰€çš„offeräº†ï¼Œçº·çº·é‡Šæ”¾å¤æ—¦offerï¼Œç„¶åAè¢«å€™è¡¥åˆ°äº†ï¼Œäºæ˜¯Aå°±é‡Šæ”¾å¦å¤§ã€åç§‘ã€äººå¤§çš„offerã€‚åœ¨å‰é¢ä¸‰ä¸ªå­¦æ ¡çš„äººï¼Œåˆå› ä¸ºAçš„é‡Šæ”¾è¢«å€™è¡¥åˆ°äº†ã€‚ ç„¶åè¿™äº›è¢«å€™è¡¥åˆ°çš„äººï¼Œç»§ç»­å¾€ä¸‹ä¸€å±‚é‡Šæ”¾offerï¼Œæ¯”å¦‚è¥¿ç”µã€å—èˆªç­‰ï¼Œæœ€åå€™è¡¥å’Œé¸½å­å°±ä¼šåƒæ ‘å½¢ç»“æ„ä¸€æ ·ç–¯ç‹‚ä¸‹ä¼ ã€‚ å› ä¸º929ä¹‹å‰æ‹¿çš„offeréƒ½ä¸æ˜¯é“offerï¼Œå­¦ç”Ÿè‡ªå·±ä¹Ÿå¯èƒ½è¢«å¼±comé¸½ï¼Œéœ€è¦æ‹¿å¼ºcomé™¢æ ¡ä¿åº•ã€‚ä»¥åŠå¯èƒ½å­¦ç”Ÿè‡ªèº«ä¹Ÿæœ‰å¤šä¸ªæ¢¦æ ¡ï¼Œéƒ½ä¼šå°è¯•æ‹¿offerã€‚ åŸå› 3ï¼š è¿™ä¸ªç°è±¡å¾€å¾€å‡ºç°åœ¨æ‹›ç”ŸåŠå¼€å§‹å½•å–æ—¶ï¼Œæ¯•ç«Ÿæ¯ä¸ªäººåªèƒ½å»è¯»ä¸€ä¸ªå­¦æ ¡ï¼Œä½ å¯èƒ½æœ‰å·®ä¸€ç‚¹çš„å­¦æ ¡Bçš„å‡†offerï¼Œä¹Ÿæœ‰æ¢¦æ ¡Cçš„å€™è¡¥ã€‚ æ¯”å¦‚å·®ä¸€ç‚¹å­¦æ ¡ï¼Œè¦æ±‚ä½ 1åˆ†é’Ÿæ¥å—æ‹Ÿå½•å–ï¼Œå¦åˆ™ä½œåºŸã€‚é‚£ä¹ˆä½ é¢å¯¹çš„åªæœ‰å››ç§ç»“æœ æ¥å—ï¼Œä½ æ²¡æœ‰å€™è¡¥åˆ°ï¼Œä¸€ä¸ªå¾ˆæ£’çš„ç»“æœï¼Œä½ æœ€ç»ˆå»äº†å­¦æ ¡B æ¥å—ï¼Œä½ å€™è¡¥åˆ°äº†ï¼Œä½ ç—›å¤±æ¢¦æ ¡éå¸¸é—æ†¾ï¼Œä½†å¥½åƒè¿˜èƒ½æ¥å—ï¼Œä½ æœ€ç»ˆå»äº†å­¦æ ¡B æ‹’ç»ï¼Œä½ ç­‰åˆ°äº†å€™è¡¥ï¼Œä¸Šå²¸æ¢¦æ ¡ï¼Œä½ æœ€ç»ˆå»äº†æ¢¦æ ¡C æ‹’ç»ï¼Œä½ æ²¡æœ‰ç­‰åˆ°å€™è¡¥ï¼Œä¸€ç¬é—´æ²¡æœ‰ä¹¦è¯»äº†ï¼Œæˆä¸ºloser å¾ˆå¤šäººæ‹…å¿ƒæ²¡æœ‰ä¹¦è¯»è€Œæ¥å—äº†æ‹Ÿå½•å–ï¼Œå‡è®¾å€™è¡¥åˆ°æ—¶å·²ç»ç³»ç»Ÿå·²ç»é”äº†ï¼Œåªèƒ½ç»§ç»­å¾€ä¸‹æ»šåŠ¨å€™è¡¥é˜Ÿåˆ— ä¸€äº›è§é—»1ã€åœ£ç»å°±æ˜¯åœ£ç»ï¼ 2ã€å¥½å¤šå­¦æ ¡è¢«é¸½ç©¿äº†ï¼Œè¯¥ï¼ 3ã€ä¸€å®šè¦æµ·æŠ•ï¼ 4ã€å°½é‡ä¸è¦é¸½è€å¸ˆï¼Œè¦é¸½æ—©ç‚¹é¸½ï¼Œåˆ«ç­‰åˆ°å½•å–é‚£å¤©ä¸´æ—¶é¸½ï¼Œä½ è‡ªå·±çˆ½äº†ï¼Œä¸‹ä¸€å±Šå­¦å¼Ÿå­¦å¦¹é­æ®ƒäº†ï¼Œæ›´ä¸è¦é›†é‚®ï¼ 5ã€8æœˆè”ç³»äº†ä¸€ä¸ªåŒ—é‚®è€å¸ˆï¼ˆ15ç»„ï¼‰ï¼Œè¿˜è¿›ç»„æ‰“å·¥ä¸€æ®µæ—¶é—´ï¼Œç„¶åä¸­ç§‹èŠ‚æŠŠæˆ‘é¸½äº†ã€‚ã€‚ã€‚928çš„æ—¶å€™åˆè·Ÿæˆ‘è¯´æœ‰å­¦ç¡•åé¢ğŸ¤¡ã€‚ 6ã€ä»Šå¹´æƒ³å¤–ä¿çœŸçš„æŒºéš¾çš„ï¼Œæˆ‘ä»¬å­¦é™¢å»äº†ä¸å°‘211ï¼Œç”šè‡³è¿˜æœ‰æœ¬æ ¡ã€‚ 7ã€è¿˜æœ‰å¥½å¤šååœºé¢ï¼Œæœ€åå‡ å¤©ä¹å­çœŸå¤šï¼Œå¼ºçƒˆå»ºè®®åŠ å…¥ç»¿ç¾¤ 943826679 å¦å¤–ï¼Œç»™è¿˜åœ¨å‡†å¤‡ä¿ç ”çš„uuä»¬å‘Šè¯«ï¼š é¦–å…ˆï¼Œé“­è®°ä½å¹¸å­˜è€…åå·® å…¶æ¬¡ï¼Œé€‰æ‹©å¤§äºåŠªåŠ› ä¸è¦ç›²ç›®è‡ªä¿¡ï¼Œä¸è¦æ„ŸåŠ¨è‡ªæˆ‘å¼çš„åŠªåŠ› ä¸è¦å­¤æ³¨ä¸€æ·ï¼Œå¤šä¸€ç‚¹é€‰é¡¹ï¼Œæœ‰æ—¶å€™çœŸçš„è¿æ°”å®åŠ› æ€»ç»“ä¸‰å¹´çš„é•¿è·‘ç»ˆäºç”»ä¸Šäº†å¥å·ï¼Œæœ€åé‚£ä¸€æ®µæ—¶é—´éƒ½åœ¨ç„¦è™‘ï¼Œç»ˆç©¶è¿˜æ˜¯æŒºè¿‡æ¥äº†ã€‚åœ¨å››é0ç§‘ç ”çš„æƒ…å†µå’Œä»Šå¹´åœ°ç‹±çº§çš„å¤–ä¿å½¢åŠ¿ä¸‹ï¼Œæ„Ÿè§‰å·²ç»æ˜¯æˆ‘èƒ½æ‰¾åˆ°çš„æœ€ä¼˜è§£äº†ã€‚ä¸€ä¸ªä¸ªé€‰æ‹©å¡‘é€ äº†äººç”Ÿï¼Œè¿™æ¬¡all in æµ™è½¯ï¼Œå¸Œæœ›ä¸€åˆ‡éƒ½æ˜¯æœ€å¥½çš„å®‰æ’ã€‚ æœ€åï¼Œæ„¿æ‰€æœ‰çš„ä¿ç ”erä»¬ï¼Œæœ€ç»ˆéƒ½å–å¾—å¿ƒä»ªçš„offerï¼Œä¸Šå²¸æ¢¦æ ¡","tags":["ä¿ç ”","è®¡ç®—æœº"],"categories":["ä¿ç ”"]},{"title":"æ´›è°·é¢˜å•","path":"/2024/09/19/æ´›è°·é¢˜å•/","content":"æ´›è°·ç»¼åˆé¢˜å•è¯•æœºé¢˜ ä¸‰é“è¯•æœºé¢˜ç›®ã€‚ P1000 è¶…çº§ç›ä¸½æ¸¸æˆ #include iostreamusing namespace std;int main() cout ******** ; cout ************ ;\tcout ####....#. ; cout #..###.....##.... ; cout ###.......###### ### ### ; cout ........... #...# #...# ; cout ##*####### #.#.# #.#.# ; cout ####*******###### #.#.# #.#.# ; cout ...#***.****.*###.... #...# #...# ; cout ....**********##..... ### ### ; cout ....**** *****.... ; cout #### #### ; cout ###### ###### ; cout############################################################## ; cout#...#......#.##...#......#.##...#......#.##------------------# ; cout###########################################------------------# ; cout#..#....#....##..#....#....##..#....#....##################### ; cout########################################## #----------# ; cout#.....#......##.....#......##.....#......# #----------# ; cout########################################## #----------# ; cout#.#..#....#..##.#..#....#..##.#..#....#..# #----------# ; cout########################################## ############ ; return 0; P1001 A+B Problem #include iostreamusing namespace std;int main() int a, b; cin a b; cout a + b; return 0; P1008 ä¸‰è¿å‡» #include iostream#include stringusing namespace std;bool st[10];string str;void dfs(int x) if (x == 9) int a = stoi(str.substr(0, 3)); int b = stoi(str.substr(3, 3)); int c = stoi(str.substr(6, 3)); if (a * 2 == b a * 3 == c) cout a b c endl; for (int i = 1; i 10; i++) if (!st[i]) st[i] = true; str.push_back(i + 0); dfs(x + 1); st[i] = false; str.pop_back(); int main()\tdfs(0);\treturn 0; å…¥é—¨é˜¶æ®µ æœ¬éƒ¨åˆ†å†…å®¹é’ˆå¯¹å…¥é—¨ OIer ï¼Œä¸»è¦æ˜¯è¯­è¨€åŸºç¡€å†…å®¹ã€‚ ä»é›¶å¼€å§‹ è¯­è¨€åŸºç¡€é¢˜ã€‚ P1421 å°ç‰ä¹°æ–‡å…· #include iostreamusing namespace std;int main() int a, b;\tcin a b;\tint c = a * 10 + b;\tcout c / 19; return 0; P1909 ä¹°é“…ç¬” #include iostreamusing namespace std;int main() int n, a1, a2, b1, b2, c1, c2, res1, res2, res3, res;\tcin n a1 a2 b1 b2 c1 c2;\tif (n % a1 == 0) res1 = n / a1 * a2;\telse res1 = (n / a1 + 1) * a2;\tif (n % b1 == 0) res2 = n / b1 * b2;\telse res2 = (n / b1 + 1) * b2;\tif (n % c1 == 0) res3 = n / c1 * c2;\telse res3 = (n / c1 + 1) * c2;\tres = min(res1, min(res2, res3));\tcout res; return 0; P1089 æ´¥æ´¥çš„å‚¨è“„è®¡åˆ’ #include iostreamusing namespace std;int main() int x, rem = 0; double res; for (int i = 1; i = 12; i++) cin x; rem = rem + 300 - x; if (rem 0) cout -i; return 0; else if (rem = 100) res += (rem / 100) * 100; rem %= 100; cout res * 1.2 + rem; return 0; P1085 ä¸é«˜å…´çš„æ´¥æ´¥ #include iostreamusing namespace std;int main() int a, b;\tint res = 0, mind = 0;\tfor (int i = 1; i = 7; i++) cin a b; int t = min(0, 8 - a - b); if (mind t) res = i; mind = t; cout res; return 0; P1035 çº§æ•°æ±‚å’Œ #include iostreamusing namespace std;int main() int k;\tcin k;\tdouble t;\tfor (int i = 1; i 10000000; i++) t += 1.0 / i; if (t k) cout i; break; return 0; P1980 è®¡æ•°é—®é¢˜ #include iostream using namespace std; int main() int n, x, res = 0; cin n x; for (int i = 1; i = n; i++) int t = i; while (t 0) if (t % 10 == x) res++; t /= 10; cout res; return 0; - [P1014 Cantorè¡¨](https://www.luogu.com.cn/problem/P1014)```c++#include iostream#include stringusing namespace std;const int N = 1000;string g[N][N];int main() int n, i = 1, j = 1, t = 1, flag = 1;\tcin n;\twhile (t n) if (flag == 1) j++; flag = 2; else if (flag == 2) i++; j--; if(j == 1) flag = 3; else if (flag == 3) i++; flag = 4; else if (flag == 4) i--; j++; if (i == 1) flag = 1; t++; cout i / j; return 0; P1307 æ•°å­—åè½¬ #include iostream#include string#include algorithmusing namespace std;int main() string n;\tcin n;\tif (n[0] == -) cout -; n = n.substr(1); else if (n == 0) cout 0; return 0; reverse(n.begin(), n.end());\twhile (n[0] == 0) n.erase(0, 1); cout n; return 0; ä¼˜åŒ– #include iostreamusing namespace std;int main() int n, m = 0;\tcin n;\twhile (n) m = m * 10 + n % 10; n /= 10; cout m; return 0; æ•°ç»„åŸºç¡€ æ•°ç»„å¯ä»¥ç”¨äºå­˜å‚¨å¤§é‡çš„ä¿¡æ¯ã€‚ P1046 é™¶é™¶æ‘˜è‹¹æœ #include iostreamusing namespace std;int nums[11], n, res;int main() for (int i = 0; i 10; i++) cin nums[i]; cin n;\tfor (int i = 0; i 10; i++) if (n + 30 = nums[i]) res++; cout res; return 0; P1047 æ ¡é—¨å¤–çš„æ ‘ #include iostreamusing namespace std;bool nums[10001];int main() int n, m, l, r; cin n m; for (int i = 0; i m; i++) cin l r; for (int j = l; j = r; j++) nums[j] = true; int res = 0;\tfor (int i = 0; i = n; i++) if (!nums[i]) res++;\tcout res; return 0; P1427 å°é±¼çš„æ•°å­—æ¸¸æˆ #include iostream#include vector#include algorithmusing namespace std;int main() vectorint nums; int x; while (true) cin x; if (x == 0) break; nums.push_back(x); reverse(nums.begin(), nums.end());\tfor (auto it: nums) cout it ; return 0; P2141 ç å¿ƒç®—æµ‹éªŒ #include iostream#include setusing namespace std;int nums[101];bool st[20001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; st[nums[i]] = true; setint res;\tfor (int i = 0; i n; i++) for (int j = i + 1; j n; j++) if (nums[i] == nums[j]) continue; if (st[nums[i] + nums[j]]) res.insert(nums[i] + nums[j]); cout res.size(); return 0; P5594 ã€XR-4ã€‘æ¨¡æ‹Ÿèµ› #include iostream#include set using namespace std;setint nums[1001];int main() int n, m, k, x; cin n m k; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x].insert(j); for (int i = 1; i = k; i++) cout nums[i].size() ; return 0; å­—ç¬¦ä¸²åŸºç¡€ å­—ç¬¦ä¸²æ˜¯ç‰¹æ®Šçš„æ•°ç»„ï¼Œä½†å®ƒä¹Ÿæœ‰å¾ˆå¤šè‡ªèº«çš„ç‰¹ç‚¹ã€‚ P5015 æ ‡é¢˜ç»Ÿè®¡ #include iostream#include stringusing namespace std;int main() string s; getline(cin, s); int res = 0;\tfor (int i = 0; i s.size(); i++) if (s[i] != s[i] != ) res++; cout res; return 0; P1055 ISBNå·ç  #include iostreamusing namespace std;int main() int a, b, c;\tchar d, e;\tscanf(%d-%d-%d-%c, a, b, c, d);\tint t = (a + (b / 100) * 2 + (b % 100 / 10) * 3 + (b % 10) * 4 + (c / 10000) * 5 + (c % 10000 / 1000) * 6 + (c % 1000 / 100) * 7 + (c % 100 / 10) * 8 + (c % 10) * 9 ) % 11;\tif (t == 10) e = X;\telse e = 0 + t;\tif (d == e) cout Right;\telse cout a - b - c - e; return 0; P1308 ç»Ÿè®¡å•è¯æ•° #include iostream#include stringusing namespace std;int main() string p, s;\tcin p;\tgetchar();\tfor (int i = 0; i p.size(); i++) p[i] = tolower(p[i]);\tint id = -1, cnt = 0, j = 0;\tgetline(cin, s);\tfor (int i = 0; i s.size(); i++) if (s[i] == ) continue; int j = i; for (;j s.size(); j++) if (s[j] == ) break; s[j] = tolower(s[j]); if (p == s.substr(i, j - i)) if (id == -1) id = i; cnt++; i = j; if (id == -1) cout id;\telse cout cnt id; return 0; P2010 å›æ–‡æ—¥æœŸ #include iostream#include string#include algorithmusing namespace std;int days[13] = 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;int main() int date1, date2, res = 0;\tcin date1 date2;\tfor (int i = 1; i =12; i++) for (int j = 1; j = days[i]; j++) int t = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10; t = t * 10000 + i * 100 + j; if (t = date1 t = date2) res++; cout res; return 0; P1012 æ‹¼æ•° #include iostream#include string#include algorithmusing namespace std;string nums[21];bool cmp(string a, string b) return a + b b + a;int main() int n;\tcin n;\tstring a;\tfor (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n, cmp);\tfor (int i = 0; i n; i++) cout nums[i]; return 0; P5587 æ‰“å­—ç»ƒä¹  #include iostream#include string#include vector#include algorithmusing namespace std;vectorstring s, t;int main() string str;\twhile(getline(cin, str)) if (str == EOF) break; string a; for (int i = 0; i str.size(); i++) if (str[i] == ) if (!a.empty()) a.pop_back(); else a.push_back(str[i]); s.push_back(a); while(getline(cin, str)) if (str == EOF) break; string a; for (int i = 0; i str.size(); i++) if (str[i] == ) if (!a.empty()) a.pop_back(); else a.push_back(str[i]); t.push_back(a); int time, cnt = 0;\tcin time;\tfor (int i = 0; i t.size(); i++) for (int j = 0; j min(s[i].size(), t[i].size()); j++) if (s[i][j] == t[i][j]) cnt++; cout cnt * 60 / time; return 0; å‡½æ•°ï¼Œé€’å½’åŠé€’æ¨ è¿™æ˜¯åˆå­¦è€…æœ€éš¾ç†è§£çš„éƒ¨åˆ†ï¼Œå»ºè®®ç”»å‡ºé€’å½’å›¾æ¥ç†è§£é€’å½’çš„è¿‡ç¨‹ã€‚ P1028 æ•°çš„è®¡ç®— #include iostreamusing namespace std;int nums[1001];int main() int n;\tcin n;\tfor (int i = 1; i = n; i++) for (int j = 1; j = i / 2; j++) nums[i] += nums[j]; nums[i]++; cout nums[n]; return 0; P1036 é€‰æ•° #include iostream#include vectorusing namespace std;int nums[21], n, k, res;bool st[10000001];void dfs(int a, int start, int t) if (a == k) if (!st[t]) res++; return; for (int i = start; i n; i++) dfs(a + 1, i + 1, t + nums[i]);\tint main() cin n k;\tst[0] = st[1] = true;\tfor (int i = 2; i 10000001; i++) if (!st[i]) for (int j = i + i; j 10000001; j += i) st[j] = true; for (int i = 0; i n; i++) cin nums[i];\tdfs(0, 0, 0);\tcout res; return 0; P1464 Function #include iostreamusing namespace std;typedef long long LL;LL dp[21][21][21];int main() for (int i = 0; i 21; i++) for (int j = 0; j 21; j++) dp[0][i][j] = dp[i][0][j] = dp[i][j][0] = 1; for (int i = 1; i 21; i++) for (int j = 1; j 21; j++) for (int k = 1; k 21; k++) if (i j j k) dp[i][j][k] = dp[i][j][k-1] + dp[i][j-1][k-1] - dp[i][j-1][k]; else dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j-1][k-1]; LL a, b, c;\twhile (cin a b c) if (a == -1 b == -1 c == -1) break; if (a = 0 || b = 0 || c = 0) printf(w(%lld, %lld, %lld) = 1 , a, b, c); else if (a 20 || b 20 || c 20) printf(w(%lld, %lld, %lld) = %lld , a, b, c, dp[20][20][20]); else printf(w(%lld, %lld, %lld) = %lld , a, b, c, dp[a][b][c]); return 0; P5534 ã€XR-3ã€‘ç­‰å·®æ•°åˆ— #include iostreamusing namespace std;int main() long long a, b, c;\tcin a b c;\tlong long res = c * a + c * (c - 1) * (b - a) / 2;\tcout res; return 0; P1192 å°é˜¶é—®é¢˜ #include iostreamusing namespace std;const int MOD = 100003;int dp[100001];int main() int n, k;\tcin n k;\tfor (int i = 1; i = k; i++) dp[i] = 1;\tfor (int i = 1; i = n; i++) for (int j = i - 1; j max(i - k - 1, 0); j--) dp[i] = (dp[i] + dp[j]) % MOD; cout dp[n]; return 0; P1025 æ•°çš„åˆ’åˆ† dfs #include iostreamusing namespace std;int n, k, res;void dfs(int cnt, int s, int t) if (cnt == k t == n) res++;\tif (cnt == k) return;\tfor (int i = s; t + i*(k - cnt) = n; i++) dfs(cnt + 1, i, t + i);\tint main() cin n k;\tdfs(0, 1, 0);\tcout res; return 0; dp #include iostreamusing namespace std;int dp[201][7];int main() int n, k;\tcin n k;\tfor (int i = 1; i = n; i++) dp[i][1] = 1; for (int i = 2; i = n; i++) for (int j = 2; j = k; j++) dp[i][j] += dp[i - 1][j - 1]; if (i j) dp[i][j] += dp[i - j][j]; cout dp[n][k]; return 0; P4994 ç»ˆäºç»“æŸçš„èµ·ç‚¹ #include iostream#include vectorusing namespace std;int fib[10000001];int main() int m;\tcin m;\tfib[0] = 0;\tfib[1] = 1;\tfor (int i = 2; i 10000001; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % m; int res = 0;\tfor (int i = 1; i 10000000; i++) if (fib[i] == 0 fib[i + 1] == 1) res = i; break; cout res; return 0; åŸºç¡€ç®—æ³• è¿™ä¸€éƒ¨åˆ†çš„å†…å®¹åŒ…å«äº† OI ä¸­çš„åŸºç¡€ç®—æ³•ï¼Œä¾›å„ä½å·©å›ºåŸºç¡€ã€‚ å½“ç„¶ï¼Œè¿™é‡Œé¢ä¹Ÿæœ‰ä¸€äº›éš¾åº¦æ¯”è¾ƒé«˜çš„é¢˜ç›®ã€‚ æ¨¡æ‹Ÿ æ¨¡æ‹Ÿï¼Œé¡¾åæ€ä¹‰å°±æ˜¯é¢˜ç›®è¦æ±‚ä½ åšä»€ä¹ˆä½ å°±åšä»€ä¹ˆï¼Œè¿™æ ·çš„é¢˜ç›®å¾ˆè€ƒéªŒé€‰æ‰‹çš„ä»£ç ç»„ç»‡èƒ½åŠ›ã€‚ è¿™é‡Œä¸ä»…ä»…æœ‰éå¸¸åŸºç¡€çš„æ¨¡æ‹Ÿï¼Œä¹Ÿæœ‰ä¸€äº›éå¸¸å¤æ‚çš„é¢˜ç›®ã€‚ P1003 é“ºåœ°æ¯¯ #include iostreamusing namespace std;int gg[100001][4];int main() int n, a, b, g, k, x, y, res = -1;\tcin n;\tfor (int i = 1; i = n; i++) cin a b g k; gg[i][0] = a; gg[i][1] = a + g; gg[i][2] = b; gg[i][3] = b + k; cin x y;\tfor (int i = n; i 0; i--) if (x = gg[i][0] x = gg[i][1] y = gg[i][2] y = gg[i][3]) res = i; break; cout res; return 0; P1067 å¤šé¡¹å¼è¾“å‡º #include iostreamusing namespace std;int main() int n, x;\tcin n x;\tif (n == 0) cout x; return 0; if (x 1) cout x x^ n;\telse if (x == 1) cout x^ n;\telse if (x == -1) cout -x^ n;\telse if (x -1) cout x x^ n;\tfor (int i = n - 1; i 1; i--) cin x; if (x 1) cout + x x^ i; else if (x == 1) cout +x^ i; else if (x == -1) cout -x^ i; else if (x -1) cout x x^ i; cin x;\tif (x 1) cout + x x;\telse if (x == 1) cout +x;\telse if (x == -1) cout -x;\telse if (x -1) cout x x;\tcin x;\tif (x 0) cout + x;\telse if (x 0) cout x; return 0; ä¼˜åŒ–ç‰ˆ #include iostreamusing namespace std;int main() int n, x; cin n; for (int i = n; i = 0; i--) cin x; if (x) if (x 0 i != n) cout +; if (abs(x) 1 || i == 0) cout x; if (x == -1 i) cout -; if (i 1) cout x^ i; if (i == 1) cout x; return 0; P1328 ç”Ÿæ´»å¤§çˆ†ç‚¸ç‰ˆçŸ³å¤´å‰ªåˆ€å¸ƒ #include iostreamusing namespace std;int a[401], b[401];int main() int n, na, nb; cin n na nb; for (int i = 0; i na; i++) cin a[i];\tfor (int i = 0; i nb; i++) cin b[i];\tfor (int i = na; i n + na; i += na) for (int j = 0; j na; j++) a[i + j] = a[j]; for (int i = nb; i n + nb; i += nb) for (int j = 0; j nb; j++) b[i + j] = b[j]; int resa = 0, resb = 0;\tfor (int i = 0; i n; i++) if (a[i] == b[i]) continue; if (a[i] == 0 b[i] == 2 || a[i] == 0 b[i] == 3 || a[i] == 1 b[i] == 0 || a[i] == 1 b[i] == 3 || a[i] == 2 b[i] == 1 || a[i] == 2 b[i] == 4 || a[i] == 3 b[i] == 2 || a[i] == 3 b[i] == 4 || a[i] == 4 b[i] == 0 || a[i] == 4 b[i] == 1) resa++; else resb++; cout resa resb endl; return 0; ä¼˜åŒ–ç‰ˆ #include iostreamusing namespace std;int v[5][5] = 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0;int a[201], b[201];int main() int n, na, nb, resa = 0, resb = 0; cin n na nb; for (int i = 0; i na; i++) cin a[i]; for (int i = 0; i nb; i++) cin b[i]; for (int i = 0; i n; i++) resa += v[a[i % na]][b[i % nb]]; resb += v[b[i % nb]][a[i % na]]; cout resa resb endl; return 0; P1563 ç©å…·è°œé¢˜ #include iostream#include stringusing namespace std;struct node\tbool flag;\tstring name; nums[100001];int main() int n, m, a, s; cin n m; for (int i = 0; i n; i++) cin nums[i].flag nums[i].name;\tint start = 0;\tfor (int i = 0; i m; i++) cin a s; if (nums[start].flag ^ a) start = (start + s) % n; else start = (start - s + n) % n; cout nums[start].name; return 0; P1042 ä¹’ä¹“çƒ #include iostream#include string#include vector#include mapusing namespace std;vectorpairint, int res1, res2;int main() string str;\tint a = 0, b = 0, c = 0, d = 0;\tbool flag = true; while (flag getline(cin, str)) for (auto ch: str) if (ch == W) a++; c++; if (a = 11 a - b = 2) res1.push_back(a, b); a = 0; b = 0; if (c = 21 c - d = 2) res2.push_back(c, d); c = 0; d = 0; else if (ch == L) b++; d++; if (b = 11 b - a = 2) res1.push_back(a, b); a = 0; b = 0; if (d = 21 d - c = 2) res2.push_back(c, d); c = 0; d = 0; else if (ch == E) flag = false; break; if (a || b) res1.push_back(a, b);\telse res1.push_back(0, 0);\tif (c || d) res2.push_back(c, d);\telse res2.push_back(0, 0);\tfor (auto it: res1) cout it.first : it.second endl;\tcout endl;\tfor (auto it: res2) cout it.first : it.second endl; return 0; P1179 æ•°å­—ç»Ÿè®¡ #include iostreamusing namespace std;int main() int l, r, res = 0;\tcin l r;\tfor (int i = l; i = r; i++) int t = i; while (t 1) if (t % 10 == 2) res++; t /= 10; cout res; return 0; P2615 ç¥å¥‡çš„å¹»æ–¹ #include iostreamusing namespace std;int nums[40][40];int main() int n;\tcin n;\tnums[0][n/2] = 1;\tfor (int i = 2; i = n * n; i++) bool flag = false; int j = 0, k = 0; for (j = 0; j n; j++) for (k = 0; k n; k++) if (nums[j][k] == i - 1) flag = true; break; if (flag) break; if (j == 0 k != n-1) nums[n-1][k+1] = i; if (j != 0 k == n-1) nums[j-1][0] = i; if (j == 0 k == n-1) nums[1][k] = i; if (j != 0 k != n-1) if (nums[j-1][k+1]) nums[j+1][k] = i; else nums[j-1][k+1] = i; for (int i = 0; i n; i++) for (int j = 0; j n; j++) cout nums[i][j]; if (j != n - 1) cout ; else cout endl; return 0; P3952 æ—¶é—´å¤æ‚åº¦ #include iostream#include stringusing namespace std;bool st[101][256], isin[101];int main() int t, n, com;\tstring O, x, y;\tchar op, val;\tcin t;\tfor (int i = 0; i t; i++) fill(st[0], st[0] + 101 * 256, false); fill(isin, isin + 101, false); bool flag = true, flag2 = true; cin n O; if (O[2] == 1) com = 0; else com = stoi(O.substr(4)); int cnt = 0, maxn = 0, cur = 0; for (int i = 0; i n; i++) cin op; if (op == F) cnt++; cin val x y; for (int j = 0; j cnt; j++) if (st[j][val]) flag = false; break; st[cnt][val] = true; if (x != n y == n ) bool flag3 = true; cur++; for (int j = 0; j cnt; j++) if (isin[j]) flag3 = false; break; if (flag3) maxn = max(maxn, cur); else if (x == n y != n || x != n y != n stoi(x) stoi(y)) isin[cnt] = true; else if (op == E) isin[cnt] = false; for (int i = 0; i 256; i++) st[cnt][i] = false; cnt--; if (cnt 0) flag = false; cnt = 0; cur--; if (cur 0) cur = 0; if (!flag || cnt != 0) cout ERR endl; else if (maxn == com) cout Yes endl; else cout No endl; return 0; æ’åºç®—æ³• é€šè¿‡æ’åºï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°æ®æœ‰åºåŒ–ï¼Œè¿™è®©æˆ‘ä»¬å¯¹æ•°æ®çš„å¤„ç†æ–¹ä¾¿äº†å¾ˆå¤šã€‚ P1177 ã€æ¨¡æ¿ã€‘å¿«é€Ÿæ’åº #include iostream#include algorithmusing namespace std;int nums[100001];void quick_sort(int l, int r) if (l = r) return;\tint i = l - 1, j = r + 1, t = nums[l + r 1];\twhile (i j) do i++; while (nums[i] t); do j--; while (nums[j] t); if (i j) swap(nums[i], nums[j]); quick_sort(l, j);\tquick_sort(j + 1, r);int main() int n;\tcin n;\tfor (int i = 0; i n; i++) cin nums[i];\tquick_sort(0, n - 1);\tfor (int i = 0; i n; i++) cout nums[i] ; return 0; P1059 æ˜æ˜çš„éšæœºæ•° #include iostream#include setusing namespace std;setint nums;int main() int n, x;\tcin n;\tfor (int i = 0; i n; i++) cin x; nums.insert(x); cout nums.size() endl;\tfor (auto it: nums) cout it ; return 0; P1068 åˆ†æ•°çº¿åˆ’å®š #include iostream#include algorithmusing namespace std;struct node\tint num, score; nums[5001];bool cmp(node a, node b) if (a.score != b.score) return a.score b.score;\treturn a.num b.num;int main() int n, m;\tcin n m;\tfor (int i = 0; i n; i++) cin nums[i].num nums[i].score;\tsort(nums, nums + n, cmp);\tint t = m * 1.5;\twhile (t n) if (nums[t].score == nums[t-1].score) t++; else break; cout nums[t - 1].score t endl;\tfor (int i = 0; i t; i++) cout nums[i].num nums[i].score endl; return 0; P1051 è°æ‹¿äº†æœ€å¤šå¥–å­¦é‡‘ #include iostream#include string#include algorithmusing namespace std;struct node\tstring name;\tint score1, score2, paper, money;\tchar ganbu, poor; nums[101];bool cmp(const node a, const node b) return a.money b.money;int main() int n, sum = 0;\tcin n;\tfor (int i = 0; i n; i++) int money = 0; cin nums[i].name nums[i].score1 nums[i].score2 nums[i].ganbu nums[i].poor nums[i].paper; if (nums[i].score1 80 nums[i].paper = 1) money += 8000; if (nums[i].score1 85 nums[i].score2 80) money += 4000; if (nums[i].score1 90) money += 2000; if (nums[i].score1 85 nums[i].poor == Y) money += 1000; if (nums[i].score2 80 nums[i].ganbu == Y) money += 850; nums[i].money = money; sum += money; stable_sort(nums, nums + n, cmp);\tcout nums[0].name nums[0].money sum; return 0; P1309 ç‘å£«è½® #include iostream#include algorithmusing namespace std;struct node\tint num, v, score; nums[200001], a[100001], b[100001];bool cmp(const node a, const node b) if (a.score != b.score) return a.score b.score;\telse return a.num b.num;int n;void merge() int id = 0, i = 0, j = 0;\twhile (i n j n) if (a[i].score b[j].score || a[i].score == b[j].score a[i].num b[j].num) nums[id++] = a[i++]; else nums[id++] = b[j++]; while (i n) nums[id++] = a[i++];\twhile (j n) nums[id++] = b[j++];int main() int r, q;\tscanf(%d %d %d, n, r, q);\tfor (int i = 0; i 2 * n; i++) scanf(%d, nums[i].score); nums[i].num = i + 1; for (int i = 0; i 2 * n; i++) scanf(%d, nums[i].v);\tsort(nums, nums + 2 * n, cmp);\tfor (int i = 0; i r; i++) int t = 0; for (int j = 0; j 2 * n; j += 2) if (nums[j].v nums[j+1].v) nums[j].score++; a[t] = nums[j]; b[t++] = nums[j+1]; else nums[j+1].score++; a[t] = nums[j+1]; b[t++] = nums[j]; merge(); printf(%d, nums[q - 1].num); return 0; P1908 é€†åºå¯¹ #include iostream#include vectorusing namespace std;int nums[500001];long long res;void merge_sort(int l, int r) if (l = r) return;\tint mid = l + r 1;\tmerge_sort(l, mid);\tmerge_sort(mid + 1, r);\tvectorint t;\tint i = l, j = mid + 1;\twhile (i = mid j = r) if (nums[i] = nums[j]) t.push_back(nums[i++]); else res += mid - i + 1; t.push_back(nums[j++]); while (i = mid) t.push_back(nums[i++]);\twhile (j = r) t.push_back(nums[j++]);\tfor (int k = l; k = r; k++) nums[k] = t[k - l];int main() int n;\tcin n;\tfor (int i = 0; i n; i++) cin nums[i]; merge_sort(0, n - 1);\tcout res;\treturn 0; äºŒåˆ†ç­”æ¡ˆ å¯¹ä¸€ä¸ªæ»¡è¶³å•è°ƒæ€§è´¨çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨äºŒåˆ†ç­”æ¡ˆçš„æ–¹æ³•æ¥è§£å†³ã€‚ P1024 ä¸€å…ƒä¸‰æ¬¡æ–¹ç¨‹æ±‚è§£ #include iostreamusing namespace std;double a, b, c, d, nums[201];double f(double x) return a * x * x * x + b * x * x + c * x + d;void check(double l, double r, bool flag) while (r - l 1e-6) double mid = (l + r) / 2; if (flag) if (f(mid) 0) r = mid; else l = mid; else if (f(mid) 0) r = mid; else l = mid; printf(%.2f , l);int main() cin a b c d;\tdouble i = -100;\tbool flag = false, flag2 = true;\tif (f(-100) 0) flag = true;\twhile (i = 100) if (flag2) if (f(i) * f(-100) 0) check(i - 0.5, i, flag); flag2 = false; else if (f(i) * f(-100) 0) check(i - 0.5, i, !flag); flag2 = true; i += 0.5; return 0; P2678 è·³çŸ³å¤´ #include iostreamusing namespace std;int l, n, m, nums[50005], res;bool check(int x) int cnt = 0, now = 0;\tfor (int i = 1; i = n+1; i++) if (nums[i] - nums[now] x) cnt++; else now = i; if (cnt m) return false;\treturn true;int main() cin l n m;\tfor (int i = 1; i = n; i++) cin nums[i];\tnums[n+1] = l;\tint i = 1, j = l;\twhile (i j) int mid = i + j + 1 1; if (check(mid)) i = mid; else j = mid - 1; cout i;\treturn 0; P1902 åˆºæ€å¤§ä½¿ dfs #include iostream#include cstringusing namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = -1, 1, 0, 0, dy[4] = 0, 0, -1, 1;bool visit[1005][1005], flag;void dfs(int a, int b) if (a == n - 1) flag = true; return; for (int i = 0; i 4; i++) x = a + dx[i], y = b + dy[i]; if (x = 0 x n y = 0 y m !visit[x][y] g[x][y] = mid) visit[x][y] = true; dfs(x, y); visit[x][y] = false; if (flag) return; bool check() flag = false;\tmemset(visit, false, sizeof(visit));\tdfs(0, 0);\treturn flag;int main() cin n m;\tint l = 1000, r = 0;\tfor (int i = 0; i n; i++) for (int j = 0; j m; j++) scanf(%d, g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); while (l r) mid = l + r 1; if (check()) r = mid; else l = mid + 1; cout r;\treturn 0; bfs #include iostream#include cstring#include queueusing namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = -1, 1, 0, 0, dy[4] = 0, 0, -1, 1;bool visit[1005][1005];bool bfs() memset(visit, false, sizeof(visit));\tqueuepairint, int q;\tq.push(0, 0);\twhile (!q.empty()) int a = q.front().first, b = q.front().second; q.pop(); for (int i = 0; i 4; i++) x = a + dx[i], y = b + dy[i]; if (x = 0 x n y = 0 y m !visit[x][y] g[x][y] = mid) q.push(x, y); visit[x][y] = true; if (x == n - 1) return true; return false;int main() cin n m;\tint l = 1000, r = 0;\tfor (int i = 0; i n; i++) for (int j = 0; j m; j++) scanf(%d, g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); while (l r) mid = l + r 1; if (bfs()) r = mid; else l = mid + 1; cout r;\treturn 0; P1314 èªæ˜çš„è´¨ç›‘å‘˜ #include iostreamusing namespace std;typedef long long LL;LL s, res = 1e12, t;int n, m, w[200005], v[200005], sums[200005], cnts[200005], q[200005][2], mid;bool check() t = 0;\tfor (int i = 1; i = n; i++) if (w[i-1] = mid) sums[i] = sums[i-1] + v[i-1]; cnts[i] = cnts[i-1] + 1; else sums[i] = sums[i-1]; cnts[i] = cnts[i-1]; for (int k = 0; k m; k++) int l = q[k][0], r = q[k][1]; t += (cnts[r] - cnts[l-1]) * (sums[r] - sums[l-1]); res = min(res, abs(t-s));\tif (t s) return true;\treturn false;int main() cin n m s;\tfor (int i = 0; i n; i++) cin w[i] v[i];\tfor (int i = 0; i m; i++) cin q[i][0] q[i][1];\tint l = 1, r = 1e6;\twhile (l r) mid = l + r 1; if (check()) l = mid + 1; else r = mid; cout res endl;\treturn 0; P1083 å€Ÿæ•™å®¤ #include iostreamusing namespace std;long long n, m, w[1000005], d[1000005], s[1000006], t[1000005], diff[1000005], nums[1000005], mid;bool check() fill(diff, diff + 1000005, 0);\tfor (int i = 1; i = mid; i++) diff[s[i]] += d[i]; diff[t[i] + 1] -= d[i]; for (int i = 1; i = n; i++) nums[i] = nums[i - 1] + diff[i]; if (nums[i] w[i]) return false; return true;int main() cin n m;\tfor (int i = 1; i = n; i++) cin w[i];\tfor (int i = 1; i = m; i++) cin d[i] s[i] t[i];\tint l = 1, r = n + 1;\twhile (l r) mid = l + r 1; if (check()) l = mid + 1; else r = mid; if (r n) cout 0;\telse cout -1 l endl;\treturn 0; P4343 è‡ªåŠ¨åˆ·é¢˜æœº #include iostreamusing namespace std;typedef long long LL;LL n, m, mid, nums[100005];LL check() LL cnt = 0, t = 0;\tfor (int i = 0; i n; i++) t += nums[i]; t = maxLL(0, t); if (t = mid) t = 0; cnt++; return cnt;int main() cin n m;\tfor (int i = 0; i n; i++) cin nums[i];\tLL l = 1, r = 1e18;\twhile (l r) mid = l + r 1; if (check() m) l = mid + 1; else r = mid; mid = l;\tif (check() != m) cout -1; return 0; cout l ;\tr = 1e18;\twhile (l r) mid = l + r + 1 1; if (check() m) r = mid - 1; else l = mid; cout r;\treturn 0; åˆ†æ²» åˆ†æ²»ï¼Œå³åˆ†è€Œæ²»ä¹‹ï¼Œå°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜ï¼Œåˆ†åˆ«æ±‚è§£ï¼Œæœ€ååˆå¹¶ç»“æœã€‚ P1226 å¿«é€Ÿå¹‚||å–ä½™è¿ç®— #include iostreamusing namespace std;typedef long long LL;LL qmi(int a, int b, int p) LL res = 1, t = a;\twhile (b) if (b 1) res = (res * t) % p; t = (t * t) % p; b = 1; res %= p;\treturn res;int main() LL a, b, p; cin a b p; printf(%d^%d mod %d=%d, a, b, p, qmi(a, b, p)); return 0; P1010 å¹‚æ¬¡æ–¹ #include iostreamusing namespace std;void fun(int x) while (x = 1) int t = 1, cnt = 0; do t *= 2; cnt++; while (x = t); int a = cnt - 1; if (a == 0) cout 2(0); else if (a == 1) cout 2; else cout 2(; fun(a); cout ); x -= t / 2; if (x != 0) cout +;\tint main() int n; cin n; fun(n); return 0; P1429 å¹³é¢æœ€è¿‘ç‚¹å¯¹ï¼ˆåŠ å¼ºç‰ˆï¼‰ #include iostream#include vector#include algorithm#include cmathusing namespace std;typedef long long LL;vectorvectorLL nums;bool cmp(vectorLL a, vectorLL b) return a[2] b[2];int main() int n, a, b; cin n; for (int i = 0; i n; i++) cin a b; nums.push_back(a, b, a + b); sort(nums.begin(), nums.end(), cmp);\tLL res = 1e12;\tfor (int i = 1; i n; i++) for (int k = 1; k 5; k++) int j = i - k; if (j 0) break; res = min((nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]), res); printf(%.4f, sqrt(res)); return 0; P3612 Secret Cow Code #include iostream#include stringusing namespace std;typedef long long LL;int main() string str; LL n, i; cin str n; while (n str.size()) i = str.size(); while (n i) i *= 2; i /= 2; n -= (i + 1); if (n == 0) n = i; cout n endl; cout str[n - 1]; return 0; è´ªå¿ƒ è´ªå¿ƒï¼ŒæŒ‡çš„æ˜¯å†³ç­–æ—¶éƒ½é‡‡å–å½“å‰æœ€ä¼˜è§£çš„ç®—æ³•ã€‚æœ‰çš„æ—¶å€™ï¼Œè¿™æ ·åšç¡®å®å¯ä»¥è·å¾—æœ€ä¼˜è§£ã€‚ P1208 Mixing Milk #include iostream#include vector#include algorithm#include mapusing namespace std;typedef pairint, int PII;PII nums[5005];int main() int n, m, price, cnt; cin n m; for (int i = 0; i m; i++) cin nums[i].first nums[i].second;\tsort(nums, nums + m);\tint res = 0, id = 0;\twhile (n 0) if (n = nums[id].second) res += nums[id].first * nums[id].second; n -= nums[id].second; else res += n * nums[id].first; n = 0; id++; cout res; return 0; P4995 è·³è·³ï¼ #include iostream#include algorithmusing namespace std;typedef long long LL;int nums[305];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i];\tsort(nums, nums + n);\tLL res = 0;\tint l = 0, r = n - 1, cur = 0;\twhile (l r) res += (nums[r] - cur) * (nums[r] - cur); cur = nums[r--]; if (l == r) res += (nums[r] - cur) * (nums[r] - cur);; break; res += (nums[l] - cur) * (nums[l] - cur); cur = nums[l++]; if (l == r) res += (nums[l] - cur) * (nums[l] - cur);; break; cout res; return 0; P1094 çºªå¿µå“åˆ†ç»„ #include iostream#include algorithmusing namespace std;int nums[30005];int main() int w, n; cin w n; for (int i = 0; i n; i++) cin nums[i];\tsort(nums, nums + n);\tint res = 0, l = 0, r = n - 1;\twhile (l = r) if (nums[r] + nums[l] w) res++; r--; else res++; r--; l++; cout res; return 0; P1199 ä¸‰å›½æ¸¸æˆ #include iostream#include algorithmusing namespace std;struct node\tint val, row, col; nums[250005];bool st[505], you[505];int res;bool cmp(node a, node b) return a.val b.val;void dfs(int x) if (nums[x].val res) return;\tif (you[nums[x].row] !st[nums[x].col] || you[nums[x].col] !st[nums[x].row]) res = max(res, nums[x].val); return; if (!st[nums[x].row]) st[nums[x].col] = true; st[nums[x].row] = true; you[nums[x].row] = true; dfs(x - 1); st[nums[x].col] = false; st[nums[x].row] = false; you[nums[x].row] = false; if (!st[nums[x].col]) st[nums[x].row] = true; st[nums[x].col] = true; you[nums[x].col] = true; dfs(x - 1); st[nums[x].row] = false; st[nums[x].col] = false; you[nums[x].col] = false;\tint main() int n, id = 0; cin n; for (int i = 1; i = n; i++) for (int j = i + 1; j = n; j++) cin nums[id].val; nums[id].row = i; nums[id++].col = j; sort(nums, nums + id, cmp); dfs(id - 1); cout 1 res; return 0; P2672 æ¨é”€å‘˜ #include iostream#include algorithmusing namespace std;int n, sum[100005], q[100005], h[100005];struct node int dist, fatigue; v[100005];bool cmp(node a, node b) return a.fatigue b.fatigue;int main() int n; cin n; for (int i = 1; i = n; i++) cin v[i].dist; for (int i = 1; i = n; i++) cin v[i].fatigue; sort(v + 1, v + 1 + n, cmp); for (int i = 1; i = n; i++) sum[i] = sum[i - 1] + v[i].fatigue; for (int i = 1; i = n; i++) q[i] = max(q[i - 1], 2 * v[i].dist); for (int i = n; i = 1; i--) h[i] = max(h[i + 1], 2 * v[i].dist + v[i].fatigue); for (int i = 1; i = n; i++) cout max(sum[i] + q[i], sum[i - 1] + h[i]) endl; return 0; P1080 å›½ç‹æ¸¸æˆ æ²¡æœ‰ç”¨é«˜ç²¾åº¦ï¼ˆ60åˆ†ï¼‰ #include iostream#include algorithmusing namespace std;typedef long long LL;struct node int l, r;\tdouble t; v[10005];bool cmp(node a, node b) return a.l * a.r b.l * b.r;int main() LL n, a, b; cin n a b; for (int i = 0; i n; i++) cin v[i].l v[i].r; v[i].t = (double)v[i].l / v[i].r; sort(v, v + n, cmp); LL res = 0, cur = a; for (int i = 0; i n; i++) res = max(res, (LL)a / v[i].r); a *= v[i].l; cout res; return 0; æ„é€  æ„é€ é¢˜æ˜¯ä¸€ç§å½¢å¼çµæ´»å¤šæ ·çš„é¢˜å‹ã€‚æ­£æ˜¯å› ä¸ºè¿™ä¸ªç‰¹ç‚¹ï¼Œä½¿å¾—æ„é€ é¢˜æ²¡æœ‰ä¸€ç§é€šç”¨çš„æ–¹æ³•ã€‚ P5595 æ­Œå”±æ¯”èµ› #include iostream#include string#include algorithmusing namespace std;int main() string str, res1 = , res2 = ; cin str; int cnt = 0; for (int i = 0; i str.size(); i++) if (str[i] == Z) for (int j = i + 1; j str.size(); j++) if (str[j] != Z) cout -1; return 0; break; for (int i = str.size() - 1; i = 0; i--) if (str[i] == Z) res1 += 0; res2 += 0; else if (str[i] == Y) res1 += 0; res2 += 1; else if (str[i] == X) res1 += 1; res2 += 0; reverse(res1.begin(), res1.end());\treverse(res2.begin(), res2.end());\tcout res1 res2; return 0; é«˜ç²¾åº¦ åœ¨ C++ ä¸­ï¼Œlong long éƒ½æ— æ³•è¡¨ç¤ºæˆ‘ä»¬éœ€è¦çš„æ•´æ•°æ—¶æ€ä¹ˆåŠï¼Ÿé‚£å°±ç”¨é«˜ç²¾åº¦å§ï¼ P1601 A+B Problemï¼ˆé«˜ç²¾ï¼‰ #include iostream#include string#include algorithmusing namespace std;int main() string a, b, c; cin a b; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); if (a.size() b.size()) swap(a, b); int t = 0, i = 0; for (; i b.size(); i++) c += ((a[i] - 0 + b[i] - 0 + t) % 10) + 0; t = (a[i] - 0 + b[i] - 0 + t) / 10; for (; i a.size(); i++) c += ((a[i] - 0 + t) % 10) + 0; t = (a[i] - 0 + t) / 10; if (t) c += 1;\treverse(c.begin(), c.end());\tcout c; return 0; P2142 é«˜ç²¾åº¦å‡æ³• #include iostream#include string#include algorithmusing namespace std;int main() string a, b, c; cin a b; if (a == b) cout 0; return 0; if (a.size() b.size()) int e = b.size() - a.size(); for (int i = 0; i e; i++) a = 0 + a; else if (a.size() b.size()) int e = a.size() - b.size(); for (int i = 0; i e; i++) b = 0 + b; for (int i = 0; i a.size(); i++) if (a[i] + 0 b[i] + 0) swap(a, b); cout -; break; else if (a[i] + 0 b[i] + 0) break; reverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i a.size(); i++) int d = a[i] - b[i] - t; if (d 0) c += ((d + 10) % 10) + 0; t = 1; else c += (d % 10) + 0; t = 0; reverse(c.begin(), c.end());\twhile (c[0] == 0) c.erase(c.begin());\tcout c; return 0; P1303 A*B Problem #include iostream#include string#include algorithmusing namespace std;int c[40005];int main() string a, b; cin a b; if (a[0] == 0 || b[0] == 0) cout 0; return 0; reverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i b.size(); i++) for (int j = 0; j a.size(); j++) c[i+j] += (a[j] - 0) * (b[i] - 0); for (int i = 0; i a.size() + b.size() - 1; i++) c[i] += t; if (c[i] = 10) t = c[i] / 10; c[i] %= 10; else t = 0; if (t) c[a.size() + b.size() - 1] = t; for (int i = a.size() + b.size() - 1; i = 0; i--) cout c[i]; else for (int i = a.size() + b.size() - 2; i = 0; i--) cout c[i]; return 0; P1480 AB Problem #include iostream#include string#include algorithmusing namespace std;int main() string a, c; int b; cin a b; long long t = 0; for (int i = 0; i a.size(); i++) t = t * 10 + a[i] - 0; c += (t / b) + 0; t -= t / b * b; while (c[0] == 0) c.erase(c.begin()); if (c.size()) cout c; else cout 0; return 0; P1009 é˜¶ä¹˜ä¹‹å’Œ #include iostream#include string#include algorithmusing namespace std;string s[51], fac[51];string mul(string a, int b) string c;\tint t = 0;\treverse(a.begin(), a.end());\tfor (int i = 0; i a.size(); i++) int d = (a[i] - 0) * b + t; c += (d % 10) + 0; if (d = 10) t = d / 10; else t = 0; if (t) string e = to_string(t); reverse(e.begin(), e.end()); c += e; reverse(c.begin(), c.end());\treturn c;string add(string a, string b) string c;\tint t = 0, i = 0;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end());\tfor (; i a.size(); i++) int d = a[i] - 0 + b[i] - 0 + t; c += (d % 10) + 0; if (d = 10) t = 1; else t = 0; for (; i b.size(); i++) int d = b[i] - 0 + t; c += (d % 10) + 0; if (d = 10) t = 1; else t = 0; if (t) c += 1;\treverse(c.begin(), c.end());\treturn c;int main() int n; cin n; s[1] = fac[1] = 1; for (int i = 2; i = n; i++) fac[i] = mul(fac[i - 1], i); s[i] = add(s[i - 1], fac[i]); cout s[n]; return 0; å‰ç¼€å’Œ å·®åˆ† å‰ç¼€å’Œæ˜¯ä¸€ç§é‡è¦çš„é¢„å¤„ç†ï¼Œèƒ½å¤§å¤§é™ä½æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ï¼Œè€Œå·®åˆ†åˆ™æ˜¯ä¸€ç§å’Œå‰ç¼€å’Œç›¸å¯¹çš„ç­–ç•¥ã€‚ P3131 Subsequences Summing to Sevens æš´åŠ›ï¼ˆ96åˆ†ï¼‰ #include iostreamusing namespace std;typedef long long LL;LL sums[50005];int main() int n, x; cin n; for (int i = 1; i = n; i++) cin x; sums[i] = sums[i - 1] + x; int res = 0;\tfor (int i = 1; i = n - res; i++) for (int j = i + res; j = n; j++) if ((sums[j] - sums[i - 1]) % 7 == 0) res = j - i + 1; cout res; return 0; æŠ€å·§ #include iostreamusing namespace std;int sums[50005], l[7], r[7];int main() int n, x; cin n; for (int i = 1; i = n; i++) cin x; sums[i] = (sums[i - 1] + x) % 7; for (int i = n; i = 1; i--) l[sums[i]] = i;\tl[0] = 0;\tfor (int i = 1; i = n; i++) r[sums[i]] = i;\tint res = 0;\tfor (int i = 0; i 7; i++) res = max(res, r[i] - l[i]);\tcout res; return 0; P1387 æœ€å¤§æ­£æ–¹å½¢ dp #include iostreamusing namespace std;int g[105][105], dp[105][105];int main() int n, m, res = 0; cin n m; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) cin g[i][j]; if (g[i][j] != 0) dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; res = max(res, dp[i][j]); cout res; return 0; å‰ç¼€å’Œ+äºŒåˆ† #include iostreamusing namespace std;int g[105][105] = 0, dp[105][105];int main() int n, m, x, res = 0; cin n m; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) cin x; g[i][j] = g[i-1][j] + g[i][j-1] - g[i-1][j-1] + x; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) int l = 0, r = min(n, m); while (l r) int mid = l + r + 1 1; if (i + mid n || j + mid m || g[i + mid][j+mid] - g[i+mid][j] - g[i][j+mid] + g[i][j] mid * mid) r = mid - 1; else l = mid; if (g[i+r][j+r] - g[i+r][j] - g[i][j+r] + g[i][j] == r*r) res = max(res, r); cout res; return 0; P3397 åœ°æ¯¯ #include iostreamusing namespace std;int g[1005][1005], res[1005][1005];int main() int n, m, x1, y1, x2, y2; cin n m; for (int i = 0; i m; i++) cin x1 y1 x2 y2; g[x1][y1] += 1; g[x2+1][y1] -= 1; g[x1][y2+1] -= 1; g[x2+1][y2+1] += 1; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; cout g[i][j]; if (j n) cout ; else cout endl; return 0; P2280 æ¿€å…‰ç‚¸å¼¹ #include iostreamusing namespace std;int g[5005][5005], res;int main() int n, m, x, y, v; cin n m; for (int i = 0; i n; i++) cin x y v; g[x+1][y+1] += v; for (int i = 1; i 5005; i++) for (int j = 1; j 5005; j++) g[i][j] += g[i][j - 1] + g[i - 1][j] - g[i - 1][j - 1]; for (int i = m; i 5005; i++) for (int j = m; j 5005; j++) res = max(res, g[i][j] - g[i][j - m] - g[i - m][j] + g[i - m][j - m]); cout res; return 0; P4552 IncDec Sequence #include iostreamusing namespace std;typedef long long LL;int a[100005];int main() int n; cin n; for (int i = 1; i = n; i++) cin a[i]; LL p = 0, q = 0;\tfor (int i = 2; i = n; i++) int c = a[i] - a[i - 1]; if (c 0) p += c; else q -= c; LL res1 = max(p, q);\tLL res2 = abs(p - q) + 1;\tcout res1 res2; return 0; æœç´¢ æœç´¢å…¶å®å°±æ˜¯é«˜çº§çš„æšä¸¾ï¼Œå¾ˆå¤šé¢˜ç›®éƒ½å¯ä»¥ç”¨æœç´¢å®Œæˆã€‚å°±ç®—ä¸èƒ½ï¼Œæœç´¢ä¹Ÿæ˜¯éª—åˆ†ç¥å™¨ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ï¼Œå³æŒ‰ç…§æ·±åº¦ä¼˜å…ˆçš„é¡ºåºæœç´¢çš„ç®—æ³•ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ä¸€èˆ¬ä½¿ç”¨æ ˆæ¥å®ç°ã€‚ P1219 å…«çš‡å #include iostream#include vectorusing namespace std;bool col[14], dg[28], udg[28];int n, cnt = 0;vectorint res;void dfs(int u) if (u == n) if (cnt 3) for (int i = 0; i n; i++) cout res[i] ; cout endl; cnt++; return; for (int i = 0; i n; i++) if (!col[i] !dg[u + i] !udg[n - u + i]) col[i] = dg[u + i] = udg[n - u + i] = true; if (cnt 3) res.push_back(i + 1); dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; if (cnt 3) res.pop_back(); int main() cin n;\tdfs(0);\tcout cnt; return 0; P1019 å•è¯æ¥é¾™ #include iostream#include vector#include string #include mapusing namespace std;int n, res;mapstring, int st;string strs[21], str;void dfs(string t) res = max(res, (int)t.size());\tfor (int i = 0; i n; i++) if (st[strs[i]] 0) int size = min(t.size(), strs[i].size()); for (int k = 1; k size; k++) bool flag = true; for (int p = 1; p = k; p++) if (t[t.size() - p] != strs[i][k - p]) flag = false; break; if (flag) st[strs[i]]--; dfs(t + strs[i].substr(k)); st[strs[i]]++; break; int main() cin n;\tfor (int i = 0; i n; i++) cin str; st[str] = 2; strs[i] = str; cin str;\tfor (int i = 0; i n; i++) if (str[0] == strs[i][0]) st[strs[i]]--; dfs(strs[i]); st[strs[i]]++; cout res; return 0; P5194 USACO05DEC]Scales P5440 ã€XR-2ã€‘å¥‡è¿¹ P1378 æ²¹æ»´æ‰©å±• å¹¿åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ï¼Œå³ä¼˜å…ˆæ‰©å±•æµ…å±‚èŠ‚ç‚¹ï¼Œé€æ¸æ·±å…¥çš„æœç´¢ç®—æ³•ã€‚ å¹¿åº¦ä¼˜å…ˆæœç´¢ä¸€èˆ¬ä½¿ç”¨é˜Ÿåˆ—æ¥å®ç°ã€‚ P1162 å¡«æ¶‚é¢œè‰² #include iostream#include vector#include queue#include mapusing namespace std;typedef pairint, int PII;bool visit[32][32];int g[32][32], n;int dx[5] = 0, 0, 1, -1, 0;int dy[5] = 1, -1, 0, 0, 0;vectorPII res;bool bfs(int x, int y) queuePII q;\tq.push(x, y);\tbool flag = true;\twhile (!q.empty()) auto u = q.front(); q.pop(); x = u.first, y = u.second; res.push_back(x, y); for (int i = 0; i 5; i++) int a = x + dx[i], b = y + dy[i]; if (a = 1 a = n b = 1 b = n !visit[a][b] g[a][b] == 0) if ((a == 1 || a == n || b == 1 || b == n) g[a][b] == 0) flag = false; visit[a][b] = true; q.push(a, b); return flag;int main() cin n;\tfor (int i = 1; i = n; i++) for (int j = 1; j = n; j++) cin g[i][j]; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) if (!visit[i][j] g[i][j] == 0) res.clear(); if (bfs(i, j)) for (int k = 0; k res.size(); k++) g[res[k].first][res[k].second] = 2; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) cout g[i][j] ; cout endl; return 0; P1443 é©¬çš„éå† P3956 æ£‹ç›˜ P1032 å­—ä¸²å˜æ¢ P1126 æœºå™¨äººæ¬é‡ç‰© è®°å¿†åŒ–æœç´¢ é€šè¿‡å°†å·²ç»éå†çš„çŠ¶æ€è®°å½•ä¸‹æ¥ï¼Œä»è€Œå‡å°‘é‡å¤çš„æœç´¢é‡ï¼Œè¿™å°±æ˜¯è®°å¿†åŒ–æœç´¢ã€‚ åŠ¨æ€è§„åˆ’çš„æ—¶å€™ï¼Œè®°å¿†åŒ–æœç´¢ä¹Ÿæ˜¯ä¸€ç§é«˜æ•ˆç®€æ´çš„å®ç°æ–¹å¼ã€‚ P1514 å¼•æ°´å…¥åŸ P1535 æ¸¸è¡çš„å¥¶ç‰› [P1434 SHOI2002]æ»‘é›ª P3953 é€›å…¬å›­ æœç´¢çš„å‰ªæ å¯¹äºä¸€äº›ä¸å¿…è¦æœç´¢çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥é¿å…è®¿é—®è¿™äº›çŠ¶æ€ï¼Œä»è€Œæé«˜æœç´¢æ•ˆç‡ã€‚ P1120 å°æœ¨æ£ ï¼»æ•°æ®åŠ å¼ºç‰ˆï¼½ P1312 Mayanæ¸¸æˆ P1074 é¶å½¢æ•°ç‹¬ åŠ¨æ€è§„åˆ’ åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é‡è¦çš„æ€ç»´æ–¹æ³•ï¼Œé€šè¿‡åˆ©ç”¨å·²æœ‰çš„å­é—®é¢˜ä¿¡æ¯é«˜æ•ˆæ±‚å‡ºå½“å‰é—®é¢˜çš„æœ€ä¼˜è§£ã€‚ çº¿æ€§åŠ¨æ€è§„åˆ’ çº¿æ€§åŠ¨æ€è§„åˆ’ï¼Œå³å…·æœ‰çº¿æ€§é˜¶æ®µåˆ’åˆ†çš„åŠ¨æ€è§„åˆ’ã€‚ P1216 æ•°å­—ä¸‰è§’å½¢ P1020 å¯¼å¼¹æ‹¦æˆª P1091 åˆå”±é˜Ÿå½¢ P1095 å®ˆæœ›è€…çš„é€ƒç¦» P1541 ä¹Œé¾Ÿæ£‹ P1868 é¥¥é¥¿çš„å¥¶ç‰› P2679 å­ä¸² P2501 HAOI2006]æ•°å­—åºåˆ— P3336 ZJOI2013]è¯æ—§ P3558 POI2013]BAJ-Bytecomputer P4158 SCOI2009]ç²‰åˆ·åŒ  P5301 GXOIGZOI2019]å®ç‰Œä¸€å¤§å † èƒŒåŒ…åŠ¨æ€è§„åˆ’ èƒŒåŒ…åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§åŠ¨æ€è§„åˆ’ä¸­ç‰¹æ®Šçš„ä¸€ç±»ï¼ŒNOIPä¸­è€ƒåˆ°çš„æ¬¡æ•°ä¹Ÿä¸å°‘ã€‚ P1048 é‡‡è¯ P1060 å¼€å¿ƒçš„é‡‘æ˜ P1855 æ¦¨å–kkksc03 P5020 è´§å¸ç³»ç»Ÿ P1757 é€šå¤©ä¹‹åˆ†ç»„èƒŒåŒ… P1064 é‡‘æ˜çš„é¢„ç®—æ–¹æ¡ˆ P2946 USACO09MAR]Cow Frisbee Team P1156 åƒåœ¾é™·é˜± P5322 BJOI2019]æ’å…µå¸ƒé˜µ P5289 åäºŒçœè”è€ƒ2019]çš®é… åŒºé—´åŠ¨æ€è§„åˆ’ åŒºé—´åŠ¨æ€è§„åˆ’ä¸€èˆ¬ä»¥åŒºé—´ä½œä¸ºåŠ¨æ€è§„åˆ’çš„é˜¶æ®µã€‚ P1880 NOI1995]çŸ³å­åˆå¹¶ P3146 USACO16OPEN]248 P1063 èƒ½é‡é¡¹é“¾ P1005 çŸ©é˜µå–æ•°æ¸¸æˆ P4170 CQOI2007]æ¶‚è‰² P4302 SCOI2003]å­—ç¬¦ä¸²æŠ˜å  P2466 SDOI2008]Sueçš„å°çƒ Part 4.4 æ ‘å½¢åŠ¨æ€è§„åˆ’ æ ‘å½¢åŠ¨æ€è§„åˆ’ï¼Œå³åœ¨æ ‘ä¸Šè¿›è¡Œçš„åŠ¨æ€è§„åˆ’ã€‚ å› ä¸ºæ ‘çš„é€’å½’æ€§è´¨ï¼Œæ ‘å½¢åŠ¨æ€è§„åˆ’ä¸€èˆ¬éƒ½æ˜¯é€’å½’æ±‚è§£çš„ã€‚ P1352 æ²¡æœ‰ä¸Šå¸çš„èˆä¼š P1040 åŠ åˆ†äºŒå‰æ ‘ P1122 æœ€å¤§å­æ ‘å’Œ P1273 æœ‰çº¿ç”µè§†ç½‘ P2014 é€‰è¯¾ P2585 ZJOI2006]ä¸‰è‰²äºŒå‰æ ‘ P3047 USACO12FEB]Nearby Cows P3698 CQOI2017]å°Qçš„æ£‹ç›˜ P5658 æ‹¬å·æ ‘ P2607 ZJOI2008]éª‘å£« P3177 HAOI2015]æ ‘ä¸ŠæŸ“è‰² P4395 BOI2003]Gem P4516 JSOI2018]æ½œå…¥è¡ŒåŠ¨ å­—ç¬¦ä¸² å­—ç¬¦ä¸²é—®é¢˜æœ‰å¾ˆå¤šè‡ªå·±çš„ç‰¹ç‚¹ã€‚ å­—ç¬¦ä¸²å“ˆå¸Œ å­—ç¬¦ä¸²å“ˆå¸Œé€šè¿‡ç‰ºç‰²å¾ˆå°çš„å‡†ç¡®ç‡ï¼Œè¾¾åˆ°å¿«é€Ÿè¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…çš„æ•ˆæœã€‚ P3370 ã€æ¨¡æ¿ã€‘å­—ç¬¦ä¸²å“ˆå¸Œ P5270 æ— è®ºæ€æ ·ç¥æ ‘å¤§äººéƒ½ä¼šåˆ åº“è·‘è·¯ P5537 ã€XR-3ã€‘ç³»ç»Ÿè®¾è®¡ Part 5.2 KMP KMP ç®—æ³•å¯ä»¥ç”¨æ¥è§£å†³æ¨¡å¼ä¸²åŒ¹é…é—®é¢˜ã€‚ P3375 ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é… P4391 BOI2009]Radio Transmission P3435 POI2006]OKR-Periods of Words P4824 USACO15FEB]Censoring (Silver) P2375 NOI2014]åŠ¨ç‰©å›­ P3426 POI2005]SZA-Template P3193 HNOI2008]GTè€ƒè¯• æ•°å­¦ OI ä¸­çš„æ•°å­¦çŸ¥è¯†å¾ˆå¤šï¼Œä¹Ÿæœ‰äº›æ‚ä¹±ã€‚ ä½è¿ç®— å°†åè¿›åˆ¶æ•´æ•°è½¬æ¢ä¸ºäºŒè¿›åˆ¶åï¼Œæœ‰å¾ˆå¤šæŒ‰ä½è¿ç®—çš„è¿ç®—ç¬¦ã€‚ å¦‚æœèƒ½å–„äºåˆ©ç”¨ä½è¿ç®—çš„ä¸€äº›æ€§è´¨ï¼Œå¾€å¾€èƒ½è¾¾åˆ°äº‹åŠåŠŸå€çš„æ•ˆæœã€‚ P5657 æ ¼é›·ç  P5514 MtOI2019æ°¸å¤œçš„æŠ¥åº” P5538 ã€XR-3ã€‘NamidAme P5539 ã€XR-3ã€‘Unknown Mother-Goose P5523 yLOI2019çç  æ•´é™¤ç›¸å…³ ä¸æ•´é™¤ç›¸å…³çš„æ¦‚å¿µæœ‰å¾ˆå¤šï¼Œæ¯”è¾ƒå¸¸ç”¨çš„æœ‰ç´ æ•°ï¼Œæœ€å¤§å…¬çº¦æ•°å’Œæ¬§æ‹‰å‡½æ•°ã€‚ ç´ æ•° ç´ æ•°ï¼ŒæŒ‡çš„æ˜¯é™¤ 1 å’Œå®ƒæœ¬èº«ä¹‹å¤–æ²¡æœ‰å…¶ä»–çº¦æ•°çš„æ•°ã€‚ P4718 ã€æ¨¡æ¿ã€‘Pollard-Rhoç®—æ³• P1075 è´¨å› æ•°åˆ†è§£ P2441 è§’è‰²å±æ€§æ ‘ P5535 ã€XR-3ã€‘å°é“æ¶ˆæ¯ æœ€å¤§å…¬çº¦æ•° å¦‚æœä¸¤ä¸ªæ•°æœ‰ä¸€ä¸ªå…±åŒçš„çº¦æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªçº¦æ•°å°±è¢«ç§°ä¸ºå…¬çº¦æ•°ã€‚æœ€å¤§å…¬çº¦æ•°å°±æ˜¯æŒ‡è¿™ä¸¤ä¸ªæ•°çš„æ‰€æœ‰å…¬çº¦æ•°ä¸­ï¼Œæœ€å¤§çš„ä¸€ä¸ªã€‚ æ±‚è§£ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ï¼Œå¯ä»¥é‡‡ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•è§£å†³ã€‚ P5435 ã€æ¨¡æ¿ã€‘å¿«é€Ÿ GCD P5436 ã€XR-2ã€‘ç¼˜åˆ† P1029 æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°é—®é¢˜ P1414 åˆæ˜¯æ¯•ä¸šå­£II P2152 SDOI2009]SuperGCD P1072 Hankson çš„è¶£å‘³é¢˜ æ¬§æ‹‰å‡½æ•° æ¬§æ‹‰å‡½æ•° è¡¨ç¤ºäº†å°äº çš„æ•°å­—ä¸­ï¼Œä¸ äº’è´¨çš„æ•°å­—ä¸ªæ•°ã€‚ P2158 SDOI2008ä»ªä»—é˜Ÿ P2568 GCD P2398 GCD SUM P4139 ä¸Šå¸ä¸é›†åˆçš„æ­£ç¡®ç”¨æ³• åŒä½™æ–¹ç¨‹ æ±‚è§£åŒä½™æ–¹ç¨‹å¾€å¾€å¯ä»¥å¼•å‡ºä¸å°‘è¯é¢˜ã€‚ çº¿æ€§åŒä½™æ–¹ç¨‹ä¹˜æ³•é€†å…ƒ çº¿æ€§åŒä½™æ–¹ç¨‹æ˜¯åŒä½™æ–¹ç¨‹ä¸­æœ€åŸºç¡€çš„å†…å®¹ã€‚ P4549 ã€æ¨¡æ¿ã€‘è£´èœ€å®šç† P2613 ã€æ¨¡æ¿ã€‘æœ‰ç†æ•°å–ä½™ P3811 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ P5431 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ2 P1082 åŒä½™æ–¹ç¨‹ P3951 å°å‡¯çš„ç–‘æƒ‘ P1516 é’è›™çš„çº¦ä¼š ä¸­å›½å‰©ä½™å®šç† ä¸­å›½å‰©ä½™å®šç†å¯ä»¥å¿«é€Ÿè§£ä¸€å…ƒçº¿æ€§åŒä½™æ–¹ç¨‹ç»„ã€‚ P4777 ã€æ¨¡æ¿ã€‘æ‰©å±•ä¸­å›½å‰©ä½™å®šç†ï¼ˆEXCRTï¼‰ P3868 TJOI2009]çŒœæ•°å­— P2480 SDOI2010]å¤ä»£çŒªæ–‡ P4774 NOI2018]å± é¾™å‹‡å£« P5345 ã€XR-1ã€‘å¿«ä¹è‚¥å®… é«˜æ¬¡åŒä½™æ–¹ç¨‹ BSGS ç®—æ³•å¯ä»¥é«˜æ•ˆè®¡ç®—ç¦»æ•£å¯¹æ•°ã€‚ è€Œé«˜æ¬¡å‰©ä½™çš„æ±‚è§£æ›´åŠ å¤æ‚ï¼Œå…¶ä¸­äºŒæ¬¡å‰©ä½™ä½œä¸ºé«˜æ¬¡å‰©ä½™ä¸­æ¯”è¾ƒç‰¹æ®Šçš„æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨ Cipolla æ³•æ±‚è§£ã€‚ P4195 ã€æ¨¡æ¿ã€‘exBSGS P5491 ã€æ¨¡æ¿ã€‘äºŒæ¬¡å‰©ä½™ P3306 SDOI2013]éšæœºæ•°ç”Ÿæˆå™¨ P2485 SDOI2011]è®¡ç®—å™¨ åšå¼ˆè®º åšå¼ˆè®ºè€ƒè™‘æ¸¸æˆä¸­çš„ä¸ªä½“çš„é¢„æµ‹è¡Œä¸ºå’Œå®é™…è¡Œä¸ºï¼Œå¹¶ç ”ç©¶å®ƒä»¬çš„ä¼˜åŒ–ç­–ç•¥ã€‚ P2197 ã€æ¨¡æ¿ã€‘nimæ¸¸æˆ P1288 å–æ•°æ¸¸æˆII P1290 æ¬§å‡ é‡Œå¾·çš„æ¸¸æˆ P1247 å–ç«æŸ´æ¸¸æˆ P2252 å–çŸ³å­æ¸¸æˆ æ¦‚ç‡ä¸æœŸæœ› æ¦‚ç‡å’ŒæœŸæœ›æ˜¯ç´§å¯†ç›¸è¿çš„ï¼ŒOI ä¸­å¾€å¾€ä¼šå‡ºç°å’Œæ¦‚ç‡æœŸæœ›ç›¸å…³çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚ P5104 çº¢åŒ…å‘çº¢åŒ… P1850 æ¢æ•™å®¤ P3830 SHOI2012]éšæœºæ ‘ P4564 CTSC2018]å‡é¢ P2473 SCOI2008]å¥–åŠ±å…³ P2221 HAOI2012]é«˜é€Ÿå…¬è·¯ P3239 HNOI2015]äºšç‘Ÿç‹ P3750 å…­çœè”è€ƒ2017]åˆ†æ‰‹æ˜¯ç¥æ„¿ P4284 SHOI2014]æ¦‚ç‡å……ç”µå™¨ P5249 LnOI2019]åŠ ç‰¹æ—è½®ç›˜èµŒ P2081 NOI2012]è¿·å¤±æ¸¸ä¹å›­ P3343 ZJOI2015]åœ°éœ‡åçš„å¹»æƒ³ä¹¡ P3600 éšæœºæ•°ç”Ÿæˆå™¨ P5326 ZJOI2019]å¼€å…³ æ•°æ®ç»“æ„ çµæ´»åœ°è¿ç”¨æ•°æ®ç»“æ„å¯ä»¥é«˜æ•ˆåœ°æŸ¥è¯¢å¹¶å¤„ç†éœ€è¦çš„ä¿¡æ¯ã€‚ é“¾è¡¨ åœ¨ä¸€ä¸ªæ•°åˆ—ä¸­é«˜æ•ˆæ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œé“¾è¡¨æ¯«æ— ç–‘é—®æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚ P1996 çº¦ç‘Ÿå¤«é—®é¢˜ P1160 é˜Ÿåˆ—å®‰æ’ æ ˆ æ ˆï¼Œæ˜¯ä¸€ç§åè¿›å…ˆå‡ºï¼ˆFILOï¼‰çš„æ•°æ®ç»“æ„ã€‚ P1449 åç¼€è¡¨è¾¾å¼ P1739 è¡¨è¾¾å¼æ‹¬å·åŒ¹é… P1981 è¡¨è¾¾å¼æ±‚å€¼ P1175 è¡¨è¾¾å¼çš„è½¬æ¢ é˜Ÿåˆ— é˜Ÿåˆ—ï¼Œæ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰çš„æ•°æ®ç»“æ„ã€‚ P1540 æœºå™¨ç¿»è¯‘ å¹¶æŸ¥é›† å¹¶æŸ¥é›†å¸¸ç”¨äºå¤„ç†ä¸€äº›ä¸ç›¸äº¤é›†åˆçš„åˆå¹¶å’ŒæŸ¥è¯¢é—®é¢˜ã€‚ P1111 ä¿®å¤å…¬è·¯ P3958 å¥¶é…ª P1525 å…³æŠ¼ç½ªçŠ¯ P4185 USACO18JAN MooTube G P2024 NOI2001é£Ÿç‰©é“¾ P1197 JSOI2008æ˜Ÿçƒå¤§æˆ˜ P1196 NOI2002é“¶æ²³è‹±é›„ä¼ è¯´ P1955 NOI2015ç¨‹åºè‡ªåŠ¨åˆ†æ Part 7.5 äºŒå‰å † äºŒå‰å †æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå †ä¸­æŸä¸ªèŠ‚ç‚¹çš„å€¼æ€»æ˜¯ä¸å¤§äºæˆ–ä¸å°äºå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ã€‚ P3378 ã€æ¨¡æ¿ã€‘å † P1090 åˆå¹¶æœå­ P1168 ä¸­ä½æ•° P2085 æœ€å°å‡½æ•°å€¼ P2827 èš¯èš“ P3045 USACO12FEB Cow Coupons Part 7.6 STè¡¨ STè¡¨å¯ä»¥ç¦»çº¿æŸ¥è¯¢åŒºé—´æœ€å€¼ã€‚ P3865 ã€æ¨¡æ¿ã€‘STè¡¨ P2251 è´¨é‡æ£€æµ‹ P1816 å¿ è¯š P1198 JSOI2008æœ€å¤§æ•° P2880 USACO07JAN Balanced Lineup P5012 æ°´ã®æ•°åˆ— P5344 ã€XR-1ã€‘é€›æ£®æ— P2048 NOI2010 è¶…çº§é’¢ç´ Part 7.7 æ ‘çŠ¶æ•°ç»„ æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§ç®€æ´é«˜æ•ˆçš„æ ‘å½¢æ•°æ®ç»“æ„ã€‚ P3374 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 1 P3368 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 2 P1908 é€†åºå¯¹ P1966 ç«æŸ´æ’é˜Ÿ P3605 USACO17JAN Promotion Counting P1972 SDOI2009 HHçš„é¡¹é“¾ P3586 POI2015 LOG P4054 JSOI2009è®¡æ•°é—®é¢˜ P4113 HEOI2012é‡‡èŠ± P3960 åˆ—é˜Ÿ çº¿æ®µæ ‘ çº¿æ®µæ ‘çš„é€šç”¨æ€§æ¯”æ ‘çŠ¶æ•°ç»„æ›´å¼ºï¼Œå¯ä»¥å¤„ç†æ›´å¤šæ¶‰åŠåŒºé—´æ“ä½œçš„é¢˜ç›®ã€‚ P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 P3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2 P5490 ã€æ¨¡æ¿ã€‘æ‰«æçº¿ P4588 TJOI2018æ•°å­¦è®¡ç®— P1502 çª—å£çš„æ˜Ÿæ˜Ÿ P2471 SCOI2007é™é›¨é‡ P2824 HEOI2016TJOI2016æ’åº P3722 AH2017HNOI2017å½±é­” P4097 HEOI2013Segment P4198 æ¥¼æˆ¿é‡å»º P4513 å°ç™½é€›å…¬å›­ P4556 Vaniæœ‰çº¦ä¼šé›¨å¤©çš„å°¾å·´ P5324 BJOI2019åˆ æ•° P5327 ZJOI2019è¯­è¨€ å›¾è®º å›¾è®ºæ˜¯æ•°å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œå®ƒä»¥å›¾ä¸ºç ”ç©¶çš„å¯¹è±¡ã€‚ å›¾çš„å­˜å‚¨ä¸éå† è¿™é‡Œçš„å›¾è®ºå†…å®¹éƒ½æ¯”è¾ƒç®€å•ï¼Œæ¶‰åŠå›¾çš„å­˜å‚¨ä»¥åŠéå†å›¾çš„æ–¹å¼ã€‚ P2661 ä¿¡æ¯ä¼ é€’ P2921 USACO08DEC Trick or Treat on the Farm æœ€çŸ­è·¯é—®é¢˜ å¾ˆå¤šé¢˜ç›®éƒ½å¯ä»¥è½¬åŒ–ä¸ºæœ€çŸ­è·¯çš„æ¨¡å‹ã€‚å› æ­¤ï¼ŒæŒæ¡æœ€çŸ­è·¯ç®—æ³•éå¸¸é‡è¦ã€‚ P3371 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆå¼±åŒ–ç‰ˆï¼‰ P4779 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ ‡å‡†ç‰ˆï¼‰ P5905 ã€æ¨¡æ¿ã€‘Johnson å…¨æºæœ€çŸ­è·¯ P1144 æœ€çŸ­è·¯è®¡æ•° P1462 é€šå¾€å¥¥æ ¼ç‘ç›çš„é“è·¯ P1522 Cow Tours P1266 é€Ÿåº¦é™åˆ¶ P4001 ICPC-Beijing 2006ç‹¼æŠ“å…”å­ P4568 JLOI2011 é£è¡Œè·¯çº¿ P3238 HNOI2014 é“è·¯å µå¡ P5304 GXOIGZOI2019 æ—…è¡Œè€… æ ‘ä¸Šé—®é¢˜ ä½œä¸ºä¸€ç§ç‰¹æ®Šçš„å›¾ï¼Œæ ‘ä¸Šçš„é—®é¢˜å…·æœ‰å¾ˆå¤šé²œæ˜çš„ç‰¹ç‚¹ã€‚ äºŒå‰æ ‘ äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘ï¼Œå®ƒæœ‰å¾ˆå¤šç‰¹æ®Šçš„æ€§è´¨ã€‚ P1087 FBIæ ‘ P1030 æ±‚å…ˆåºæ’åˆ— P1305 æ–°äºŒå‰æ ‘ P1229 éå†é—®é¢˜ P5018 å¯¹ç§°äºŒå‰æ ‘ P5597 ã€XR-4ã€‘å¤è¯» Part 8.3.2 æ ‘çš„ç›´å¾„ æ ‘çš„ç›´å¾„è¢«å®šä¹‰ä¸ºæ ‘ä¸Šæœ€è¿œçš„ä¸¤ç‚¹é—´çš„è·ç¦»ã€‚ è®¡ç®—æ ‘çš„ç›´å¾„ï¼Œå¯ä»¥é€šè¿‡ä¸¤é DFS è§£å†³ã€‚ P2195 HXYé€ å…¬å›­ P3629 APIO2010 å·¡é€» P5536 ã€XR-3ã€‘æ ¸å¿ƒåŸå¸‚ P1099 æ ‘ç½‘çš„æ ¸ P4408 NOI2003é€ƒå­¦çš„å°å­© å…¬å…±ç¥–å…ˆ ä¸¤ä¸ªç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå³ä¸¤ä¸ªç‚¹çš„æ‰€æœ‰å…¬å…±ç¥–å…ˆä¸­ï¼Œç¦»æ ¹èŠ‚ç‚¹æœ€è¿œçš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚ æ±‚è§£æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå¸¸ç”¨çš„æ–¹æ³•æ˜¯æ ‘ä¸Šå€å¢æˆ–è€…æ ‘é“¾å‰–åˆ†ã€‚ P3379 ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ P3938 æ–æ³¢é‚£å¥‘ P4281 AHOI2008 ç´§æ€¥é›†åˆ èšä¼š ç”Ÿæˆæ ‘ ç”¨ æ¡è¾¹å°†å›¾ä¸Šçš„ ä¸ªç‚¹è¿æ¥èµ·æ¥ï¼Œå½¢æˆçš„æ ‘å°±è¢«ç§°ä¸ºç”Ÿæˆæ ‘ã€‚ P3366 ã€æ¨¡æ¿ã€‘æœ€å°ç”Ÿæˆæ ‘ [P4180 ã€æ¨¡æ¿ã€‘ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘BJWC2010] [P2872 USACO07DEC]Building Roads P1991 æ— çº¿é€šè®¯ç½‘ P1967 è´§è½¦è¿è¾“ [P4047 JSOI2010]éƒ¨è½åˆ’åˆ† æ‹“æ‰‘æ’åº å°†ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾æ’åºï¼Œä½¿å¾—æ‰€æœ‰æ’åœ¨å‰é¢çš„èŠ‚ç‚¹ä¸èƒ½ä¾èµ–äºæ’åœ¨åé¢çš„èŠ‚ç‚¹ï¼Œè¿™å°±æ˜¯æ‹“æ‰‘æ’åºã€‚ P1113 æ‚åŠ¡ P1983 è½¦ç«™åˆ†çº§ P1038 ç¥ç»ç½‘ç»œ å·®åˆ†çº¦æŸ å·®åˆ†çº¦æŸè¦è§£å†³çš„é—®é¢˜æ˜¯ï¼šæ±‚å‡ºä¸€ç»„ å…ƒä¸ç­‰å¼çš„ä¸€ç»„è§£ï¼Œä½¿å¾—æ‰€æœ‰çº¦æŸå…³ç³»éƒ½èƒ½å¾—åˆ°æ»¡è¶³ã€‚ P5960 ã€æ¨¡æ¿ã€‘å·®åˆ†çº¦æŸç®—æ³• [P3275 SCOI2011]ç³–æœ [P2294 HNOI2005]ç‹¡çŒ¾çš„å•†äºº [P4926 1007]å€æ€æµ‹é‡è€… P5590 èµ›è½¦æ¸¸æˆ å›¾çš„è¿é€šæ€§ç›¸å…³ åˆ©ç”¨ Tarjan ç®—æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è§£å†³å¾ˆå¤šä¸å›¾çš„è¿é€šæ€§ç›¸å…³çš„é—®é¢˜ã€‚ P3387 ã€æ¨¡æ¿ã€‘ç¼©ç‚¹ P3388 ã€æ¨¡æ¿ã€‘å‰²ç‚¹ï¼ˆå‰²é¡¶ï¼‰ [P2341 HAOI2006]å—æ¬¢è¿çš„ç‰› [P2863 USACO06JAN]The Cow Prom [P2746 USACO5.3]Network of Schools [P1407 å›½å®¶é›†è®­é˜Ÿ]ç¨³å®šå©šå§» [P2272 ZJOI2007]æœ€å¤§åŠè¿é€šå­å›¾ [P3225 HNOI2012]çŸ¿åœºæ­å»º [P5058 ZJOI2004]å—…æ¢å™¨ [P2515 HAOI2010]è½¯ä»¶å®‰è£…","tags":["ç®—æ³•","C++","æ´›è°·"],"categories":["ç®—æ³•"]},{"title":"åŠ›æ‰£Hot100","path":"/2024/09/09/åŠ›æ‰£Hot100/","content":"åŠ›æ‰£Hot100å“ˆå¸Œä¸¤æ•°ä¹‹å’Œclass Solution public: vectorint twoSum(vectorint nums, int target) unordered_mapint, int st; for (int i = 0; i nums.size(); i++) if (st.find(target - nums[i]) != st.end()) return i, st[target - nums[i]]; else st[nums[i]] = i; return ; ; å­—æ¯å¼‚ä½è¯åˆ†ç»„class Solution public: vectorvectorstring groupAnagrams(vectorstring strs) unordered_mapstring, vectorstring st; for (int i = 0; i strs.size(); i++) string t = strs[i]; sort(strs[i].begin(), strs[i].end()); st[strs[i]].push_back(t); vectorvectorstring res; for (auto it: st) res.push_back(it.second); return res; ; æœ€é•¿è¿ç»­åºåˆ—æ’åº class Solution public: int longestConsecutive(vectorint nums) sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i nums.size();) int t = 1; while (i nums.size() - 1) if (nums[i] == nums[i + 1]) i++; else if (nums[i] == nums[i + 1] - 1) t++; i++; else break; if (t == 1) i++; res = max(res, t); return res; ; å“ˆå¸Œ class Solution public: int longestConsecutive(vectorint nums) unordered_setint sets; for (auto num: nums) sets.insert(num); int res = 0; for (auto num: sets) if (!sets.count(num - 1)) int cur = num, t = 1; while (sets.count(cur + 1)) cur++; t++; res = max(res, t); return res; ; åŒæŒ‡é’ˆç§»åŠ¨é›¶class Solution public: void moveZeroes(vectorint nums) int l = 0, r = 0, n = nums.size(); while (r n) if (nums[r]) swap(nums[l], nums[r]); l++; r++; ; ç››æœ€å¤šæ°´çš„å®¹å™¨class Solution public: int maxArea(vectorint height) int l = 0, r = height.size()-1; int res = 0; while (l r) int t = min(height[l], height[r]) * (r - l); res = max(res, t); if (height[l] = height[r]) l++; else r--; return res; ; ä¸‰æ•°ä¹‹å’Œæš´åŠ› class Solution public: vectorvectorint threeSum(vectorint nums) unordered_mapint, int st; vectorvectorint res; sort(nums.begin(), nums.end()); for (int i = 0; i nums.size(); i++) st[nums[i]] = i; for (int i = 0; i nums.size(); i++) if (i != 0 nums[i] == nums[i-1]) continue; for (int j = i + 1; j nums.size(); j++) if (j != i + 1 nums[j] == nums[j-1]) continue; if (st[-nums[i] - nums[j]] i st[-nums[i] - nums[j]] j) res.push_back(nums[i], nums[j], -nums[i] - nums[j]); return res; ; åŒæŒ‡é’ˆ class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint res; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i n - 2; i++) if (i != 0 nums[i] == nums[i-1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] 0) continue; int j = i + 1, k = n - 1; while (j k) int s = nums[i] + nums[j] + nums[k]; if (s 0) k--; else if (s 0) j++; else res.push_back(nums[i], nums[j++], nums[k--]); while(j k nums[j] == nums[j - 1]) j++; while(j k nums[k] == nums[k + 1]) k--; return res; ; æ»‘åŠ¨çª—å£æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²class Solution public: int lengthOfLongestSubstring(string s) int nums[128]; int i = 0, j = 0, res = 0; while (j s.size()) nums[s[j]]++; while (nums[s[j]] 1) nums[s[i++]]--; res = max(res, j - i + 1); j++; return res; ; æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯class Solution public: vectorint findAnagrams(string s, string p) int l = 0, r = 0, valid = 0; unordered_mapchar, int need, window; vectorint res; for (char ch: p) need[ch]++; while (r s.size()) char c = s[r++]; if (need.count(c)) window[c]++; if (window[c] == need[c]) valid++; while (r - l = p.size()) if (valid == need.size()) res.push_back(l); char d = s[l++]; if (need.count(d)) if (window[d] == need[d]) valid--; window[d]--; return res; ; å­—ä¸²å’Œä¸º K çš„å­æ•°ç»„class Solution public: int subarraySum(vectorint nums, int k) int res = 0, s[20005]; for (int i = 0; i nums.size(); i++) s[i + 1] = s[i] + nums[i]; unordered_mapint, int cnt; for (int i = 0; i = nums.size(); i++) if (cnt.contains(s[i] - k)) res += cnt[s[i] - k]; cnt[s[i]]++; return res; ; æ»‘åŠ¨çª—å£æœ€å¤§å€¼ä¼˜å…ˆé˜Ÿåˆ— class Solution public: vectorint maxSlidingWindow(vectorint nums, int k) int n = nums.size(); priority_queuepairint, int q; for (int i = 0; i k; i++) q.push(nums[i], i); vectorint res = q.top().first; for (int i = k; i n; i++) q.push(nums[i], i); while (q.top().second = i - k) q.pop(); res.push_back(q.top().first); return res; ; å•è°ƒé˜Ÿåˆ— class Solution public: vectorint maxSlidingWindow(vectorint nums, int k) int n = nums.size(); dequeint q; vectorint res; int l = 0; for (int i = 0; i k; i++) while (!q.empty() nums[i] = nums[q.back()]) q.pop_back(); q.push_back(i); res.push_back(nums[q.front()]); for (int i = k; i n; i++) while (!q.empty() nums[i] = nums[q.back()]) q.pop_back(); q.push_back(i); while (q.front() = i - k) q.pop_front(); res.push_back(nums[q.front()]); return res; ; æ™®é€šæ•°ç»„æœ€å¤§å­æ•°ç»„å’ŒåŠ¨æ€è§„åˆ’ class Solution public: int maxSubArray(vectorint nums) int dp[100005], res = -0x3f3f3f3f; dp[0] = nums[0]; for (int i = 1; i nums.size(); i++) dp[i] = max(nums[i], dp[i - 1] + nums[i]); for (int i = 0; i nums.size(); i++) res = max(res, dp[i]); return res; ; åˆå¹¶åŒºé—´class Solution public: vectorvectorint merge(vectorvectorint intervals) sort(intervals.begin(), intervals.end()); vectorvectorint res; for (int i = 0; i intervals.size();) int t = intervals[i][1]; int j = i + 1; while (j intervals.size() intervals[j][0] = t) t = max(t, intervals[j][1]); j++; res.push_back(intervals[i][0], t); i = j; ; return res; ; è½®è½¬æ•°ç»„class Solution public: void rotate(vectorint nums, int k) int t[100005], size = nums.size(); for (int i = 0; i size; i++) t[(i + k) % size] = nums[i]; for (int i = 0; i size; i++) nums[i] = t[i]; ; çŸ©é˜µçŸ©é˜µç½®é›¶class Solution public: void setZeroes(vectorvectorint matrix) int row[205], col[205], n = matrix.size(), m = matrix[0].size(); for (int i = 0; i n; i++) for (int j = 0; j m; j++) if (matrix[i][j] == 0) row[i] = 1; col[j] = 1; for (int i = 0; i n; i++) for (int j = 0; j m; j++) if (row[i] || col[j]) matrix[i][j] = 0; ; èºæ—‹çŸ©é˜µclass Solution public: vectorint spiralOrder(vectorvectorint matrix) int n = matrix.size(), m = matrix[0].size(); int l = 0, r = m - 1, u = 0, d = n - 1; vectorint res; while (true) for (int i = l; i = r; i++) res.push_back(matrix[u][i]); u++; if (u d) break; for (int i = u; i = d; i++) res.push_back(matrix[i][r]); r--; if (l r) break; for (int i = r; i = l; i--) res.push_back(matrix[d][i]); d--; if (u d) break; for (int i = d; i = u; i--) res.push_back(matrix[i][l]); l++; if (l r) break; return res; ; é“¾è¡¨äºŒå‰æ ‘å›¾è®ºå›æº¯äºŒåˆ†æŸ¥æ‰¾35. æœç´¢æ’å…¥ä½ç½®class Solution public: int searchInsert(vectorint nums, int target) int l = 0, r = nums.size() - 1; while(l r) int mid = l + r 1; if (nums[mid] target) l = mid + 1; else r = mid; if (l == nums.size() - 1 nums[l] target) return l + 1; else return l; ; 74. æœç´¢äºŒç»´çŸ©é˜µclass Solution public: bool searchMatrix(vectorvectorint matrix, int target) int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n - 1; while (l r) int mid = l + r 1; if (matrix[mid].back() target) l = mid + 1; else r = mid; int t = l; l = 0, r = m - 1; while (l r) int mid = l + r 1; if (matrix[t][mid] target) l = mid + 1; else r = mid; return matrix[t][l] == target; ; 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®class Solution public: vectorint searchRange(vectorint nums, int target) vectorint res; if (nums.empty()) res.push_back(-1); res.push_back(-1); return res; int n = nums.size(); int l = 0, r = n - 1; while (l r) int mid = l + r 1; if (nums[mid] target) l = mid + 1; else r = mid; if (nums[l] == target) res.push_back(l); else res.push_back(-1); l = 0, r = n - 1; while (l r) int mid = l + r + 1 1; if (nums[mid] target) r = mid - 1; else l = mid; if (nums[r] == target) res.push_back(l); else res.push_back(-1); return res; ; 33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„class Solution public: int search(vectorint nums, int target) int n = nums.size(); int l = 0, r = n - 1; while (l = r) int mid = l + r 1; if (target == nums[mid]) return mid; else if (nums[mid] nums[r]) if (nums[mid] target nums[r] = target) l = mid + 1; else r = mid - 1; else if (nums[mid] target nums[l] = target) r = mid - 1; else l = mid + 1; return -1; ; æ ˆå †è´ªå¿ƒç®—æ³•121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºclass Solution public: int maxProfit(vectorint prices) int t = prices[0], res = 0; for (int i = 0; i prices.size(); i++) t = min(t, prices[i]); res = max(res, prices[i] - t); return res; ; 55. è·³è·ƒæ¸¸æˆclass Solution public: bool canJump(vectorint nums) int dp[10005] = 0; dp[0] = nums[0]; for (int i = 1; i nums.size(); i++) if (dp[i - 1] = 0) return false; dp[i] = max(dp[i - 1] - 1, nums[i]); return true; ; 45. è·³è·ƒæ¸¸æˆ IIclass Solution public: int jump(vectorint nums) int res = 0, end = 0, maxa = 0; for (int i = 0; i nums.size() - 1; i++) maxa = max(nums[i] + i, maxa); if (i == end) end = maxa; res++; return res; ; 763. åˆ’åˆ†å­—æ¯åŒºé—´class Solution public: vectorint partitionLabels(string s) int last[26], n = s.size(); for (int i = 0; i n; i++) last[s[i] - a] = i; vectorint res; int start = 0, end = 0; for (int i = 0; i n; i++) end = max(end, last[s[i] - a]); if (i == end) res.push_back(end - start + 1); start = end + 1; return res; ; åŠ¨æ€è§„åˆ’70. çˆ¬æ¥¼æ¢¯class Solution public: int climbStairs(int n) int dp[50]; dp[1] = 1; dp[2] = 2; for (int i = 3; i = n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; ; 118. æ¨è¾‰ä¸‰è§’class Solution public: vectorvectorint generate(int numRows) vectorvectorint res; int dp[31][31]; dp[1][1] = 1; for (int i = 2; i = numRows; i++) for (int j = 1; j = i; j++) dp[i][j] = dp[i-1][j - 1] + dp[i-1][j]; for (int i = 1; i = numRows; i++) vectorint t; for (int j = 1; j = i; j++) t.push_back(dp[i][j]); res.push_back(t); return res; ; 198. æ‰“å®¶åŠ«èˆclass Solution public: int rob(vectorint nums) int dp[105], res; if (nums.size() == 1) res = nums[0]; else if (nums.size() == 2) res = max(nums[0], nums[1]); else dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i nums.size(); i++) dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); res = dp[nums.size() - 1]; return res; ; 279. å®Œå…¨å¹³æ–¹æ•°class Solution public: int numSquares(int n) vectorint f(n + 1); for (int i = 1; i = n; i++) int minn = INT_MAX; for (int j = 1; j * j = i; j++) minn = min(minn, f[i - j * j]); f[i] = minn + 1; return f[n]; ; 322. é›¶é’±å…‘æ¢class Solution public: int coinChange(vectorint coins, int amount) int dp[10005]; fill(dp, dp + amount + 1, 10005); dp[0] = 0; for (int i = 1; i = amount; i++) for (int j = 0; j coins.size(); j++) if (i - coins[j] = 0) dp[i] = min(dp[i], dp[i - coins[j]] + 1); if (dp[amount] == 10005) return -1; else return dp[amount]; ; 139. å•è¯æ‹†åˆ†class Solution public: bool wordBreak(string s, vectorstring wordDict) vectorbool dp(s.size() + 1); dp[0] = true; for (int i = 1; i = s.size(); i++) for (auto word: wordDict) int sz = word.size(); if (i - sz = 0 s.substr(i - sz, sz) == word) dp[i] = dp[i] || dp[i - sz]; return dp[s.size()]; ; å¤šç»´åŠ¨æ€è§„åˆ’62. ä¸åŒè·¯å¾„class Solution public: int uniquePaths(int m, int n) int dp[m][n]; for (int i = 0; i m; i++) dp[i][0] = 1; for (int i = 0; i n; i++) dp[0][i] = 1; for (int i = 1; i m; i++) for (int j = 1; j n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; ; 64. æœ€å°è·¯å¾„å’Œ class Solution public: int minPathSum(vectorvectorint grid) int dp[205][205], n = grid.size(), m = grid[0].size(); for (int i = 1; i = m; i++) dp[1][i] = dp[1][i - 1] + grid[0][i - 1]; for (int i = 1; i = n; i++) dp[i][1] = dp[i - 1][1] + grid[i - 1][0]; for (int i = 2; i = n; i++) for (int j = 2; j = m; j++) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; return dp[n][m]; ; æŠ€å·§","tags":["ç®—æ³•","LeetCode","C++"],"categories":["ç®—æ³•"]},{"title":"PAT ç”²çº§","path":"/2024/08/30/PATç”²çº§/","content":"1001 A+B Format#include iostream#include stringusing namespace std;int main() int a, b; cin a b; int c = a + b; if (c 0) cout -; c = -c; if (c = 1000) string t = to_string(c); int d = t.size() % 3; if(d) cout t.substr(0, d) ,; for (int i = d; i t.size(); i += 3) cout t.substr(i, 3); if (i + 3 t.size()) cout ,; else cout c; return 0; æŸ³å©¼çš„ #include iostream#include stringusing namespace std;int main() int a, b; cin a b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i len; i++) cout s[i]; if (s[i] == -) continue; if ((i + 1) % 3 == len % 3 i != len - 1) cout ,; return 0; 1002 A+B for Polynomials#include iostreamusing namespace std;const int N = 1001;double nums[N];int main() int n, a; double b; cin n; for (int i = 0; i n; i++) cin a b; nums[a] = b; cin n; for (int i = 0; i n; i++) cin a b; nums[a] += b; int cnt = 0; for (int i = 1000; i = 0; i--) if (nums[i]) cnt++; cout cnt; for (int i = 1000; i = 0; i--) if (nums[i]) printf( %d %.1f, i, nums[i]); return 0; 1003 Emergency#include iostream#include vector#include map#include algorithmusing namespace std;typedef pairint, int PII;const int N = 501;const int INF = 0x3f3f3f3f;int vals[N], d[N], num[N], val[N];bool visit[N];vectorPII g[N];void djkstra(int s, int n) fill(d, d + N, INF); d[s] = 0; val[s] = vals[s]; num[s] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; num[v] = num[u]; val[v] = val[u] + vals[v]; else if (d[u] + dis == d[v]) num[v] = num[v] + num[u]; val[v] = max(val[v], val[u] + vals[v]); int main() int n, m, c1, c2, u, v, w; cin n m c1 c2; for (int i = 0; i n; i++) cin vals[i]; for (int i = 0; i m; i++) cin u v w; g[u].push_back(v, w); g[v].push_back(u, w); djkstra(c1, n); cout num[c2] val[c2]; return 0; 1004 Counting Leavesbfs #include iostream#include queue#include vectorusing namespace std;vectorint trees[101];void bfs(int u) queueint q; q.push(u); while (!q.empty()) int len = q.size(); int t = 0; while (len--) u = q.front(); q.pop(); for (int i = 0; i trees[u].size(); i++) q.push(trees[u][i]); if (trees[u].empty()) t++; cout t; if (!q.empty()) cout ; int main() int n, m, id1, k, id2; cin n m; for (int i = 0; i m; i++) cin id1 k; for (int j = 0; j k; j++) cin id2; trees[id1].push_back(id2); bfs(1); return 0; dfs #include iostream#include queue#include vector#include algorithmusing namespace std;vectorint trees[101];int res[101], maxdepth;void dfs(int u, int depth) if (trees[u].size() == 0) res[depth]++; maxdepth = max(maxdepth, depth); for (int i = 0; i trees[u].size(); i++) dfs(trees[u][i], depth + 1); int main() int n, m, id1, k, id2; cin n m; for (int i = 0; i m; i++) cin id1 k; for (int j = 0; j k; j++) cin id2; trees[id1].push_back(id2); dfs(1, 0); for (int i = 0; i = maxdepth; i++) cout res[i]; if (i maxdepth) cout ; return 0; 1005 Spell It Right#include iostream#include stringusing namespace std;int main() string str; cin str; string words[10] = zero, one, two, three, four, five, six, seven, eight, nine; int res = 0; for (int i = 0; i str.length(); i++) res += str[i] - 0; string res2 = to_string(res); for (int i = 0; i res2.length(); i++) cout words[res2[i] - 0]; if (i res2.length() - 1) cout ; return 0; 1006 Sign In and Sign Out#include iostream#include stringusing namespace std;int main() int n; cin n; string name, start, end, res1_name, res1_start = 23:59:59, res2_name, res2_end = 00:00:00; for (int i = 0; i n; i++) cin name start end; if (start res1_start) res1_name = name; res1_start = start; if (end res2_end) res2_name = name; res2_end = end; cout res1_name res2_name; return 0; 1007 Maximum Subsequence Sum#include iostreamusing namespace std;const int INF = 0x3f3f3f3f;int nums[10001], dp[10001];int main() int n; cin n; fill(dp, dp + n, -INF); for (int i = 0; i n; i++) cin nums[i]; dp[0] = nums[0]; for (int i = 1; i n; i++) dp[i] = max(dp[i - 1] + nums[i], nums[i]); int res = -INF, start = 0, end = n - 1, t = 0; for (int i = 0; i n; i++) if (res dp[i]) res = dp[i]; end = i; if (res == 0) start = end; else if (res 0) for (int i = end; i = 0; i--) if (t res) t += nums[i]; start = i; else res = 0; start = 0; end = n - 1; cout res nums[start] nums[end]; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int nums[100001];int main() int n; cin n; int left = 0, right = n - 1, res = -1, temp = 0, tempindex = 0; for (int i = 0; i n; i++) cin nums[i]; temp = temp + nums[i]; if (temp 0) temp = 0; tempindex = i + 1; else if (temp res) res = temp; left = tempindex; right = i; if (res 0) res = 0; cout res nums[left] nums[right]; return 0; 1008 Elevator#include iostreamusing namespace std;int main() int n, pre = 0, now, res = 0; cin n; for (int i = 0; i n; i++) cin now; if (now pre) res += (now - pre) * 6 + 5; else res += (pre - now) * 4 + 5; pre = now; cout res; return 0; 1009 Product of Polynomials#include iostreamusing namespace std;const int N = 1001;double nums[N], res[N * N];int main() int k, a, cnt = 0; double b; cin k; for (int i = 0; i k; i++) cin a b; nums[a] = b; cin k; for (int i = 0; i k; i++) cin a b; for (int j = 0; j N; j++) res[a + j] += b * nums[j]; for (int i = 0; i N * N; i++) if (res[i]) cnt++; cout cnt; for (int i = N * N - 1; i = 0; i--) if (res[i]) printf( %d %.1f, i, res[i]); return 0; 1010 Radix#include iostream#include string#include algorithm#include cmathusing namespace std;typedef long long LL;LL convert(string s, int k) LL sum = 0, idx = 0; for (int i = s.length() - 1; i = 0; i--) int t = isdigit(s[i]) ? s[i] - 0 : s[i] - a + 10; sum += t * pow(k, idx++); return sum;LL find(string s, LL num) char maxt = *max_element(s.begin(), s.end()); LL low = isdigit(maxt) ? maxt - 0 + 1 : maxt - a + 11; LL high = max(low, num); while (low = high) LL mid = low + high 1; LL t = convert(s, mid); if (t 0 | t num) high = mid - 1; else if (t == num) return mid; else low = mid + 1; return -1;int main() string n1, n2; int tag, radix, res; cin n1 n2 tag radix; if (tag == 1) res = find(n2, convert(n1, radix)); else res = find(n1, convert(n2, radix)); if (res == -1) cout Impossible; else cout res; return 0; 1011 World Cup Betting#include iostreamusing namespace std;double fun(double a, double b, double c) double res = 1; if (b = a b = c) cout T ; res *= b; else if (a = b a = c) cout W ; res *= a; else cout L ; res *= c; return res;int main() double a, b, c; double res = 1; for (int i = 0; i 3; i++) cin a b c; res *= fun(a * 0.65, b, c); printf(%.2f, 2 * (res - 1)); return 0; 1012 The Best Rank#include iostream#include algorithmusing namespace std;struct student int num, c, m, e; double a; student(int _num, int _c, int _m, int _e, double _a) num = _num, c = _c, m = _m, e = _e, a = _a; student(); nums[2000];bool cmp_a(student a, student b) return a.a b.a;bool cmp_c(student a, student b) return a.c b.c;bool cmp_m(student a, student b) return a.m b.m;bool cmp_e(student a, student b) return a.e b.e;int A[1000000], C[1000000], M[1000000], E[1000000];bool isin[1000000];int main() int n, m, num, c1, m1, e1; cin n m; for (int i = 0; i n; i++) cin num c1 m1 e1; double a1 = (c1 + m1 + e1) / 3.0; nums[i] = student(num, c1, m1, e1, a1); isin[num] = true; int idx = 1; sort(nums, nums + 2000, cmp_a); A[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].a == nums[i - 1].a) A[nums[i].num] = idx; else A[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_c); C[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].c == nums[i - 1].c) C[nums[i].num] = idx; else C[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_m); M[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].m == nums[i - 1].m) M[nums[i].num] = idx; else M[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_e); E[nums[0].num] = idx; for (int i = 0; i n; i++) if (nums[i].e == nums[i - 1].e) E[nums[i].num] = idx; else E[nums[i].num] = i + 1; idx = i + 1; for (int i = 0; i m; i++) cin num; if (isin[num]) int res_rank = n, res_sub; if (res_rank A[num]) res_rank = A[num]; res_sub = A; if (res_rank C[num]) res_rank = C[num]; res_sub = C; if (res_rank M[num]) res_rank = M[num]; res_sub = M; if (res_rank E[num]) res_rank = E[num]; res_sub = E; printf(%d %c , res_rank, res_sub); else cout N/A endl; return 0; æŸ³å©¼çš„ #include iostream#include algorithmusing namespace std;struct node int id, best; int score[4], rank[4]; stu[2001];int hashtable[1000000], flag;bool cmp(node a, node b) return a.score[flag] b.score[flag];int main() int n, m, id; cin n m; for (int i = 0; i n; i++) cin stu[i].id stu[i].score[1] stu[i].score[2] stu[i].score[3]; stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; for (flag = 0; flag = 3; flag++) sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int i = 1; i n; i++) stu[i].rank[flag] = i + 1; if (stu[i].score[flag] == stu[i - 1].score[flag]) stu[i].rank[flag] = stu[i - 1].rank[flag]; for (int i = 0; i n; i++) hashtable[stu[i].id] = i + 1; stu[i].best = 0; int minn = stu[i].rank[0]; for (int j = 1; j = 3; j++) if (stu[i].rank[j] minn) minn = stu[i].rank[j]; stu[i].best = j; char c[5] = ACME; for (int i = 0; i m; i++) cin id; if (hashtable[id]) int best = stu[hashtable[id] - 1].best; printf(%d %c , stu[hashtable[id] - 1].rank[best], c[best]); else cout N/A ; return 0; 1013 Battle Over Citieså¹¶æŸ¥é›† #include iostream#include setusing namespace std;const int N = 1001;int g[N][N], fa[N];int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];int main() int n, m, k, u, v, x; cin n m k; for (int i = 0; i m; i++) cin u v; g[u][v] = g[v][u] = 1; for (int i = 0; i k; i++) cin x; for (int j = 1; j = n; j++) fa[j] = j; for (int j = 1; j = n; j++) for (int k = j + 1; k = n; k++) if (j == x || k == x) continue; if (g[j][k] == 1 find(j) != find(k)) fa[find(j)] = find(k); setint res; for (int j = 1; j = n; j++) res.insert(find(j)); cout res.size() - 2 endl; return 0; æŸ³å©¼çš„ï¼ˆdfsï¼‰ #include iostream#include setusing namespace std;const int N = 1001;int g[N][N], n;bool visit[N];void dfs(int x) visit[x] = true; for (int i = 1; i = n; i++) if (g[i][x] !visit[i]) dfs(i); int main() int m, k, u, v, x; cin n m k; for (int i = 0; i m; i++) cin u v; g[u][v] = g[v][u] = 1; for (int i = 0; i k; i++) fill(visit, visit + N, false); cin x; visit[x] = true; int cnt = 0; for (int i = 1; i = n; i++) if (!visit[i]) dfs(i); cnt++; cout cnt - 1 endl; return 0; 1014 Waiting in Lineå¤§æ¨¡æ‹Ÿï¼ˆqueueï¼‰ #include iostream#include vector#include queueusing namespace std;struct node int poptime, endtime; queueint q;;int main() int n, m, k, q, idx = 1; cin n m k q; vectorint time(k + 1), res(k + 1); for (int i = 1; i = k; i++) cin time[i]; vectornode win(n + 1); vectorbool sorry(k + 1, false); for (int i = 1; i = m; i++) for (int j = 1; j = n; j++) if (idx = k) win[j].q.push(time[idx]); if (win[j].endtime = 540) sorry[idx] = true; win[j].endtime += time[idx]; if (i == 1) win[j].poptime = win[j].endtime; res[idx] = win[j].endtime; idx++; while (idx = k) int tmin = win[1].poptime, twin = 1; for (int i = 2; i = n; i++) if (win[i].poptime tmin) twin = i; tmin = win[i].poptime; win[twin].q.pop(); win[twin].q.push(time[idx]); win[twin].poptime += win[twin].q.front(); if (win[twin].endtime = 540) sorry[idx] = true; win[twin].endtime += time[idx]; res[idx] = win[twin].endtime; idx++; for (int i = 1; i = q; i++) int query, minute; cin query; minute = res[query]; if (sorry[query]) cout Sorry endl; else printf(%02d:%02d , (minute + 480) / 60, minute % 60); return 0; 1015 Reversible Primes#include iostream#include string#include cmathusing namespace std;const int N = 100001;bool st[N];int convert1(string s, int k) int sum = 0, idx = 0; for (int i = s.size() - 1; i = 0; i--) sum += (s[i] - 0) * pow(k, idx++); return sum;string convert2(int n, int k) string res; while (n) res.push_back(n % k + 0); n /= k; return res;int main() for (int i = 2; i N; i++) if (!st[i]) for (int j = i + i; j N; j += i) st[j] = true; st[0] = st[1] = true; int a, b; while (cin a) if (a 0) break; cin b; int t = convert1(convert2(a, b), b); if (!st[t] !st[a]) cout Yes endl; else cout No endl; return 0; æŸ³å©¼çš„ #include iostream#include cmathusing namespace std;bool isprime(int n) if (n = 1) return false; for (int i = 2; i = int(sqrt(n * 1.0)); i++) if (n % i == 0) return false; return true;int main() int a, b; while (cin a) if (a 0) break; cin b; if (!isprime(a)) cout No endl; continue; int len = 0, arr[100]; do arr[len++] = a % b; a /= b; while(a != 0); for (int i = 0; i len; i++) a = a * b + arr[i]; if (isprime(a)) cout Yes endl; else cout No endl; return 0; 1016 Phone Billså¤§æ¨¡æ‹Ÿ #include iostream#include map#include vector#include algorithmusing namespace std;struct node string time, tag; node (string _time, string _tag) time = _time, tag = _tag; ;mapstring, vectornode mp;bool cmp(node a, node b) return a.time b.time;int price[25] = 0, n;double count2(string time) int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = price[hour] * min + price[24] * 60 * day; for (int i = 0; i hour; i++) res += price[i] * 60; return res / 100.0;int count1(string time) int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = day * 24 * 60 + hour * 60 + min; return res;int main() for (int i = 0; i 24; i++) cin price[i]; price[24] += price[i]; cin n; string name, time, tag, month; for (int i = 0; i n; i++) cin name time tag; month = time.substr(0, 2); mp[name].push_back(node(time.substr(3, 8), tag)); for (auto i = mp.begin(); i != mp.end(); i++) vectornode nodes = i-second; sort(nodes.begin(), nodes.end(), cmp); double money = 0; int idx = 0, minute; string start, end; vectorstring times; for (int i = 0; i nodes.size() - 1; i++) if (nodes[i].tag == on-line nodes[i + 1].tag == off-line) times.push_back(nodes[i].time); times.push_back(nodes[i + 1].time); if (times.size() 0) cout i-first month endl; for (int i = 0; i times.size(); i += 2) string start = times[i], end = times[i + 1]; minute = count1(end) - count1(start); double t = count2(end) - count2(start); money += t; printf(%s %s %d $%.2f , start.c_str(), end.c_str(), minute, t); printf(Total amount: $%.2f , money); return 0; æŸ³å©¼çš„ #include iostream#include map#include vector#include algorithmusing namespace std;struct node string name; int status, month, time, day, hour, minute;;bool cmp(node a, node b) return a.name != b.name ? a.name b.name : a.time b.time;int rate[25], n;double count(node a) double res = rate[a.hour] * a.minute + rate[24] * 60 * a.day; for (int i = 0; i a.hour; i++) res += rate[i] * 60; return res / 100.0;int main() for (int i = 0; i 24; i++) cin rate[i]; rate[24] += rate[i]; cin n; vectornode data(n); for (int i = 0; i n; i++) cin data[i].name; scanf(%d:%d:%d:%d, data[i].month, data[i].day, data[i].hour, data[i].minute); string tmp; cin tmp; data[i].status = (tmp == on-line) ? 1 : 0; data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute; sort(data.begin(), data.end(), cmp); mapstring, vectornode custom; for (int i = 1; i n; i++) if (data[i].name == data[i - 1].name data[i - 1].status == 1 data[i].status == 0) custom[data[i - 1].name].push_back(data[i - 1]); custom[data[i].name].push_back(data[i]); for (auto it: custom) vectornode tmp = it.second; printf(%s %02d , it.first.c_str(), tmp[0].month); double res = 0; for (int i = 1; i tmp.size(); i += 2) double t = count(tmp[i]) - count(tmp[i - 1]); printf(%02d:%02d:%02d %02d:%02d:%02d %d $%.2f , tmp[i - 1].day, tmp[i - 1].hour, tmp[i - 1].minute, tmp[i].day, tmp[i].hour, tmp[i].minute, tmp[i].time - tmp[i - 1].time, t); res += t; printf(Total amount: $%.2f , res); return 0; 1017 Queueing at Bank#include iostream#include map#include algorithmusing namespace std;typedef pairint, int PII;int main() int n, k, p, hour, minute, second, idx = 0, res = 0; cin n k; vectorPII nums; vectorint v(k); for (int i = 0; i n; i++) scanf(%d:%d:%d %d, hour, minute, second, p); int t = hour * 3600 + minute * 60 + second; if (t 61200) continue; nums.push_back(t, p * 60); sort(nums.begin(), nums.end()); n = nums.size(); for (int j = 0; j min(n, k); j++) if (nums[idx].first 28800) v[j] = 28800; res += 28800 - nums[idx].first; else v[j] = nums[idx].first; v[j] += nums[idx].second; idx++; while (idx n) int tmin = v[0], twin = 0; for (int i = 1; i k; i++) if (tmin v[i]) tmin = v[i]; twin = i; if (v[twin] nums[idx].first) res += v[twin] - nums[idx].first; else v[twin] = nums[idx].first; v[twin] += nums[idx].second; idx++; printf(%.1f, res / 60.0 / n); return 0; æŸ³å©¼çš„ #include iostream#include queue#include algorithmusing namespace std;const int maxn = 10005;struct person int come, time; p[maxn];int cmp(person p1, person p2) return p1.come p2.come;int n, k, cnt, total;int main() cin n k; for (int i = 0; i n; i++) int hh, ss, mm, tt; scanf(%d:%d:%d %d, hh, mm, ss, tt); int sum = hh * 3600 + mm * 60 + ss; if (sum 61200) continue; p[++cnt].time = tt * 60; p[cnt].come = sum; sort(p + 1, p + 1 + cnt, cmp); priority_queueint, vectorint, greaterint q; for (int i = 1; i = k; i++) q.push(28800); for (int i = 1; i = cnt; i++) cout i endl; if (q.top() = p[i].come) q.push(p[i].come + p[i].time); else total += q.top() - p[i].come; q.push(q.top() + p[i].time); q.pop(); if (!cnt) cout 0.0 endl; else printf(%.1f, total / 60.0 / cnt); return 0; 1018 Public Bike Managementdijkstra #include iostream#include vector#include map#include iostreamusing namespace std;typedef pairint, int PII;const int N = 501;const int INF = 0x3f3f3f3f;bool visit[N];int d[N], weight[N], n, minNeed = INF, minBack = INF;vectorPII g[N];vectorint pre[N], path, tmppath;void dijkstra(int x) fill(d, d + N, INF); d[x] = 0; for (int i = 0; i = n; i++) int u = -1, mind = INF; for (int j = 0; j = n; j++) if (!visit[j] mind d[j]) mind = d[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); else if(d[u] + dis == d[v]) pre[v].push_back(u); void dfs(int v) tmppath.push_back(v); if (v == 0) int need = 0, back = 0; for (int i = tmppath.size() - 1; i = 0; i--) int idx = tmppath[i]; if (weight[idx] 0) back += weight[idx]; else if (back -weight[idx]) back += weight[idx]; else need += (-weight[idx] - back); back = 0; if (need minNeed) minNeed = need; minBack = back; path = tmppath; else if (need == minNeed back minBack) minBack = back; path = tmppath; tmppath.pop_back(); return; for (int i = 0; i pre[v].size(); i++) dfs(pre[v][i]); tmppath.pop_back();int main() int c, s, m, u, v, w; cin c n s m; for (int i = 1; i = n; i++) cin weight[i]; weight[i] = weight[i] - c / 2; for (int i = 0; i m; i++) cin u v w; g[u].push_back(v, w); g[v].push_back(u, w); dijkstra(0); dfs(s); cout minNeed 0; for (int i = path.size() - 2; i = 0; i--) cout - path[i]; cout minBack; return 0; 1019 General Palindromic Number#include iostream#include vectorusing namespace std;int main() int n, k; cin n k; vectorint str; while (n) str.push_back(n % k); n /= k; vectorint str2(str.rbegin(), str.rend()); if (str == str2) cout Yes endl; else cout No endl; for (int i = 0; i str2.size(); i++) cout str2[i]; if (i str2.size() - 1) cout ; return 0; 1020 Tree Traversals#include iostream#include queueusing namespace std;const int N = 31;int post[N], in[N];struct node int l, r; trees[N];int build(int postl, int postr, int inl, int inr) if (postl postr) return -1; int root = post[postr], idx; for (int i = inl; i = inr; i++) if (root == in[i]) idx = i; break; int cntl = idx - inl; trees[root].l = build(postl, postl + cntl - 1, inl, idx - 1); trees[root].r = build(postl + cntl, postr - 1, idx + 1, inr); return root;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); q.pop(); cout u; if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (!q.empty()) cout ; int main() int n; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); return 0; æŸ³å©¼çš„ #include iostream#include mapusing namespace std;const int N = 31;int post[N], in[N];mapint, int level;void pre(int root, int start, int end, int idx) if (start end) return; int i = start; while (i end in[i] != post[root]) i++; level[idx] = post[root]; pre(root - 1 - end + i, start, i - 1, 2 * idx + 1); pre(root - 1, i + 1, end, 2 * idx + 2);int main() int n; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; pre(n - 1, 0, n - 1, 0); for (auto i = level.begin(); i != level.end(); i++) cout i-second; if (next(i) != level.end()) cout ; return 0; 1021 Deepest Root#include iostream#include vector#include setusing namespace std;int n, maxh = 0;vectorint g[10010], tmp;bool visit[10010];setint s;void dfs(int node, int height) if (maxh height) maxh = height; tmp.clear(); tmp.push_back(node); else if (maxh == height) tmp.push_back(node); visit[node] = true; for (int i = 0; i g[node].size(); i++) if (!visit[g[node][i]]) dfs(g[node][i], height + 1); int main() int n, u, v, cnt = 0, s1 = 0; cin n; for (int i = 0; i n - 1; i++) cin u v; g[u].push_back(v); g[v].push_back(u); for (int i = 1; i = n; i++) if (!visit[i]) dfs(i, 1); if (i == 1) if (!tmp.empty()) s1 = tmp[0]; for (int j = 0; j tmp.size(); j++) s.insert(tmp[j]); cnt++; if (cnt 1) cout Error: cnt components; else tmp.clear(); fill(visit, visit + 10010, false); maxh = 0; dfs(s1, 1); for (int i = 0; i tmp.size(); i++) s.insert(tmp[i]); for (auto it = s.begin(); it != s.end(); it++) cout *it endl; return 0; 1022 Digital Library#include iostream#include vector#include string#include algorithmusing namespace std;struct book string num, title, auther, publisher, year; vectorstring keys; books[10001];bool cmp(book a, book b) return a.num b.num;int main() int n, m, q; string key, query; scanf(%d , n); for (int i = 0; i n; i++) getline(cin, books[i].num); getline(cin, books[i].title); getline(cin, books[i].auther); while (cin key) books[i].keys.push_back(key); char c = getchar(); if (c == ) break; getline(cin, books[i].publisher); getline(cin, books[i].year); sort(books, books + n, cmp); cin m; for (int i = 0; i m; i++) bool flag = false; scanf(%d: , q); getline(cin, query); cout q : query endl; for (int i = 0; i n; i++) if (q == 1 books[i].title == query) cout books[i].num endl; flag = true; else if (q == 2 books[i].auther == query) cout books[i].num endl; flag = true; else if (q == 3) for (int j = 0; j books[i].keys.size(); j++) if (query == books[i].keys[j]) cout books[i].num endl; flag = true; else if (q == 4 books[i].publisher == query) cout books[i].num endl; flag = true; else if (q == 5 books[i].year == query) cout books[i].num endl; flag = true; if (!flag) cout Not Found endl; return 0; æŸ³å©¼çš„ #include iostream#include map#include setusing namespace std;mapstring, setint title, author, key, pub, year;void query(mapstring, setint m, string str) if(m.find(str) != m.end()) for(auto it = m[str].begin(); it != m[str].end(); it++) printf(%07d , *it); else cout Not Found ;int main() int n, m, id, num; scanf(%d, n); string ttitle, tauthor, tkey, tpub, tyear; for(int i = 0; i n; i++) scanf(%d , id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin tkey) key[tkey].insert(id); char c = getchar(); if(c == ) break; getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); scanf(%d, m); for(int i = 0; i m; i++) scanf(%d: , num); string temp; getline(cin, temp); cout num : temp ; if(num == 1) query(title, temp); else if(num == 2) query(author, temp); else if(num == 3) query(key, temp); else if(num == 4) query(pub,temp); else if(num ==5) query(year, temp); return 0; 1023 Have Fun with Numbers#include iostream#include string#include algorithmusing namespace std;int nums[10];int main() string a, b = ; cin a; int t = 0; for (int i = a.size() - 1; i = 0; i--) b += ((a[i] - 0) * 2 + t) % 10 + 0; t = ((a[i] - 0) * 2 + t) / 10; if (t) b += t + 0; reverse(b.begin(), b.end()); for (int i = 0; i a.size(); i++) nums[a[i]]++; bool flag = true; for (int i = 0; i b.size(); i++) nums[b[i]]--; if (nums[b[i]] 0) flag = false; break; if (flag) cout Yes endl; else cout No endl; cout b; return 0; 1024 Palindromic Number#include iostream#include string#include algorithmusing namespace std;string add(string a) string b(a.rbegin(), a.rend()), c = ; int t = 0; for (int i = a.size() - 1; i = 0; i--) int sum = a[i] - 0 + b[i] - 0 + t; c += sum % 10 + 0; t = sum / 10; if (t) c += t + 0; reverse(c.begin(), c.end()); return c;bool ispal(string a) string b(a.rbegin(), a.rend()); return a == b;int main() string n; int k; cin n k; for (int i = 0; i k; i++) if (ispal(n)) cout n endl; cout i; return 0; n = add(n); cout n endl; cout k; return 0; 1025 PAT Ranking#include iostream#include string#include vector#include algorithmusing namespace std;struct node1 string num; int score, locnum, locrank;;bool cmp1(node1 a, node1 b) if (a.score == b.score) return a.num b.num; else return a.score b.score; int main() int n, k, score; string num; vectornode1 nums; cin n; for (int i = 1; i = n; i++) cin k; vectornode1 tmp(k); for (int j = 0; j k; j++) cin tmp[j].num tmp[j].score; tmp[j].locnum = i; sort(tmp.begin(), tmp.end(), cmp1); tmp[0].locrank = 1; nums.push_back(tmp[0]); for (int j = 1; j k; j++) if (tmp[j].score != tmp[j - 1].score) tmp[j].locrank = j + 1; else tmp[j].locrank = tmp[j - 1].locrank; nums.push_back(tmp[j]); sort(nums.begin(), nums.end(), cmp1); int rank = 1; cout nums.size() endl; cout nums[0].num rank nums[0].locnum nums[0].locrank endl; for (int i = 1; i nums.size(); i++) if (nums[i].score != nums[i - 1].score) rank = i + 1; cout nums[i].num rank nums[i].locnum nums[i].locrank endl; return 0; 1026 Table Tennisæœ€æ¶å¿ƒçš„å¤§æ¨¡æ‹Ÿ #include iostream#include algorithm#include vectorusing namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;struct table int endtime, num; bool vip;;struct play int arrive, use, start; // åˆ°è¾¾æ—¶é—´ï¼Œä½¿ç”¨æ—¶é—´ï¼Œå¼€å§‹æ—¶é—´ bool served, vip; // æ˜¯å¦æœåŠ¡ï¼Œvip?;int cmp1(play a, play b) return a.arrive b.arrive; // å…ˆå¯¹æ•°æ®è¿›è¡Œæ’åºï¼ŒæŒ‰åˆ°è¾¾çš„æ—¶é—´å‡åºint cmp2(play a, play b) return a.start b.start; // æœ€åè¾“å‡ºçš„æ—¶å€™ä¸ºä»€ä¹ˆæ˜¯8:12:00åœ¨8:10:00çš„å‰é¢å‘¢ï¼Ÿå°±æ˜¯å› ä¸ºæ˜¯æŒ‰å¼€å§‹ä½¿ç”¨çš„æ—¶é—´å‡åºçš„vectorplay p;vectortable t;// æ‰¾åˆ°personidåŠä¹‹åçš„ï¼Œå¹¶ä¸”åˆ°è¾¾ï¼ˆarriveï¼‰æ—¶é—´ä¸æ™šäºbeforeçš„ï¼ŒæœªæœåŠ¡çš„ï¼Œä¸”ä¸ºvipçš„ person-id. å¦‚æœæ²¡æ‰¾åˆ°,åˆ™è¿”å›-1int findvip(int personId, int minendtime) for (int i = personId; i p.size() p[i].arrive = minendtime; i++) if (!p[i].served p[i].vip) return i; return -1;// æ›´æ–°ä»¥personIdçš„ç©å®¶å¯¹ï¼Œå’ŒtableIdçš„æ¡Œå­çš„ä¿¡æ¯// 1ã€å°†è¯¥ç©å®¶å¯¹çš„å¼€å§‹æ—¶é—´èµ‹å€¼ä¸ºåˆ°è¾¾æ—¶é—´å’Œå¯ç”¨æ¡Œå­ç»“æŸæ—¶é—´ä¸­çš„è¾ƒå¤§å€¼// 2ã€å°†è¯¥ç©å®¶å¯¹çš„æœåŠ¡çŠ¶æ€èµ‹å€¼ä¸ºä»¥æœåŠ¡è¿‡// 3ã€å°†æ¡Œå­çš„ç»“æŸæ—¶é—´ä¿¡æ¯æ›´æ–°ä¸ºè¯¥ç©å®¶å¯¹çš„å¼€å§‹æ—¶é—´åŠ è¯¥ç©å®¶çš„ä½¿ç”¨æ—¶é—´// 4ã€å°†è¯¥æ¡Œå­æœåŠ¡çš„ç©å®¶æ•°é‡åŠ ä¸€void update(int personid, int tableid) p[personid].start = max(p[personid].arrive, t[tableid].endtime); p[personid].served = 1; t[tableid].endtime = p[personid].start + p[personid].use; t[tableid].num++;int main() int n, m, k, vipnum; scanf(%d, n); for (int i = 0; i n; i++) int h, m, s, use, vip, arrive; scanf(%d:%d:%d %d %d, h, m, s, use, vip); arrive = h * 3600 + m * 60 + s; use = use 120 ? 7200 : use * 60; p.push_back(arrive, use, 0, 0, vip 0); sort(p.begin(), p.end(), cmp1); scanf(%d %d, k, m); for (int i = 0; i k; i++) t.push_back(28800, 0, 0); for (int i = 0; i m; i++) scanf(%d, vipnum); t[vipnum - 1].vip = 1; for (int i = 0; i p.size();) // æ‰¾åˆ°æœ€å…ˆç©ºé—²çš„æ¡Œå­,å¦‚æœå¤šä¸ªæ¡Œå­åŒæ—¶ç©ºé—²ï¼Œåˆ™è¿”å›æ¡Œå­å·æœ€å°çš„é‚£ä¸ª int minendtime = INF, minendid; for (int j = 0; j k; j++) if (minendtime t[j].endtime) minendtime = t[j].endtime; minendid = j; // å¦‚æœæœ€å…ˆç©ºé—²çš„æ¡Œå­ç©ºé—²çš„å¤ªæ™šäº†ï¼Œæˆ–è€…å½“å‰åºåˆ—ä¸­çš„ç¬¬ä¸€ä½ç©å®¶å¯¹è¾¾åˆ°çš„æ—¶é—´å¤ªæ™šäº†ï¼Œå°±é€€å‡ºå¾ªç¯ if (minendtime = 75600 || p[i].arrive = 75600) break; // å£°æ˜æ–°çš„å˜é‡ï¼ŒpersonIdä¸ºç»è¿‡è°ƒæ•´é€‰æ‹©åæœ€ç»ˆçš„å¼€å§‹ä½¿ç”¨æ¡Œå­çš„ç©å®¶å¯¹ç´¢å¼•ï¼ŒtableIdä¸ºä¸ºç»è¿‡è°ƒæ•´é€‰æ‹©åæœ€ç»ˆçš„å¼€å§‹è¢«ä½¿ç”¨çš„æ¡Œå­ int personid = i, tableid = minendid; // å¦‚æœå½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­ç©ºé—²æ—¶ï¼Œå­˜åœ¨ç©å®¶å¯¹å·²ç»åœ¨ç­‰å¾…äº† if (minendtime = p[i].arrive) // å¹¶ä¸”å½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­æ˜¯vipï¼Œå¯»æ‰¾æ˜¯vipçš„ä¸”æœªæœåŠ¡è¿‡çš„ï¼Œç©å®¶å¯¹åˆ°è¾¾æ—¶é—´ä¸æ™šäºminEndTimeçš„ç©å®¶å¯¹ç´¢å¼• if (t[tableid].vip) int vipid = findvip(personid, minendtime); personid = vipid != -1 ? vipid : personid; else if (p[i].vip) // è™½ç„¶å½“å‰çš„æœ€æ—©ç©ºé—²ä¸”å·æœ€å°çš„æ¡Œå­ä¸æ˜¯vipï¼Œä½†æ˜¯è¿˜å¯èƒ½å­˜åœ¨åŒæ—¶ç©ºé—²ï¼Œæ¡Œå·æ›´å¤§çš„æ¡Œå­æ˜¯vip for (int j = 0; j k; j++) if (t[j].vip t[j].endtime = p[personid].arrive) tableid = j; break; // å¦‚æœå½“å‰çš„æ¡Œå­évipï¼Œä¸”å½“å‰çš„åºåˆ—çš„ç¬¬ä¸€ä¸ªç©å®¶å¯¹évipï¼Œé¡ºåºé€‰æ‹©å³å¯ï¼Œæ¢å¥è¯è¯´ï¼ŒpersonIdå’ŒtableIdæ— éœ€è°ƒæ•´ else /* å¦‚æœå½“å‰çš„æœ€æ—©ç©ºé—²çš„æ¡Œå­ç©ºé—²æ—¶ï¼Œæ²¡æœ‰ç©å®¶åœ¨ç­‰å¾…åºåˆ—ä¸­ï¼Œå³å½“ä¸€ä¸ªç©å®¶åˆ°è¾¾æ—¶ï¼Œåº”è¯¥æ˜¯è‡³å°‘æœ‰ä¸€ä¸ªæ¡Œå­æ˜¯ç©ºé—²çš„ æˆ‘ä»¬æ€»æ˜¯å¸Œæœ›é€‰æ‹©ç©ºé—²ä¸­çš„æ¡Œå­ä¸­æ¡Œå­å·æœ€å°çš„ï¼Œå¦‚æœåˆ°è¾¾äº†ä¸€ä¸ªvipç©å®¶å¯¹ï¼Œå¹¶ä¸”å­˜åœ¨ç©ºé—²çš„vipæ¡Œå­ï¼Œæˆ‘ä»¬é€‰æ‹©ç©ºé—²ä¸­çš„vipæ¡Œä¸­å·æœ€å°çš„ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸ç®¡æ˜¯å¦æ˜¯vipï¼Œå…ˆå¾—åˆ°ç©ºé—²ä¸­çš„æ¡Œå­ä¸­æ¡Œå­å·æœ€å°çš„ï¼Œå¦‚æœå½“å‰åˆ°è¾¾çš„ç©å®¶å¯¹æœªvipï¼Œå¹¶ä¸”å­˜åœ¨ç©ºé—²çš„vipæ¡Œå­ï¼Œ æˆ‘ä»¬ç”¨ç©ºé—²ä¸­çš„vipæ¡Œä¸­å·æœ€å°çš„é‚£ä¸ªæ¡Œå­è¦†ç›–ä¹‹å‰å¾—åˆ°çš„tableId */ for (int j = 0; j k; j++) if (t[j].endtime = p[personid].arrive) tableid = j; break; if (p[personid].vip) for (int j = 0; j k; j++) // å°è¯•å¯»æ‰¾ç©ºé—²çš„vipæ¡Œå­å¹¶è°ƒæ•´tableIdï¼Œé¡ºåºæ‰¾åˆ°å³é€€å‡ºå¾—åˆ°çš„å°±æ˜¯å·ç æœ€å°çš„ if (t[j].vip t[j].endtime = p[personid].arrive) tableid = j; break; update(personid, tableid); while (i p.size() p[i].served) i++; sort(p.begin(), p.end(), cmp2); for (int i = 0; i p.size(); i++) if (p[i].served) int wait = p[i].start - p[i].arrive; printf(%02d:%02d:%02d %02d:%02d:%02d %d , p[i].arrive / 3600, p[i].arrive % 3600 / 60, p[i].arrive % 60, p[i].start / 3600, p[i].start % 3600 / 60, p[i].start % 60, (int)(1.0 * wait / 60 + 0.5)); for (int i = 0; i k; i++) if (i != 0) printf( ); printf(%d, t[i].num); return 0; æŸ³å©¼çš„ #include iostream#include vector#include queue#include mapusing namespace std;int n, m, k, H, M, S, t, table, vtable, cnt, now, nowt, T[100000], V[100000], num[10001], AnsI[10001], AnsO[10001], vip[10001];mapint, int Table;queueint Wait, vWait;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d:%d:%d, H, M, S); t = H * 3600 + M * 60 + S; scanf(%d %d, T[t], V[t]); T[t] = min(T[t], 120) * 60; scanf(%d %d, m, k); for (int i = 0; i k; i++) scanf(%d, t); vip[t] = 1; for (int Time = 28800; Time 75600; Time++, table = vtable = now = 0) if (T[Time] V[Time]) vWait.push(Time); else if (T[Time]) Wait.push(Time); for (int i = 1; i = m; i++) if (Table[i] 0) Table[i]--; if (Table[i] == 0 vip[i] vtable == 0) vtable = i; if (Table [i] == 0 table == 0) table = i; if (!vWait.empty() (table || vtable)) now = vWait.front(); nowt = vtable; if (vtable != 0) vWait.pop(); else nowt = table; if (!Wait.empty() Wait.front() vWait.front()) now = Wait.front(); Wait.pop(); else vWait.pop(); else if (!Wait.empty() (table || vtable)) if (table != 0) nowt = table; else nowt = vtable; now = Wait.front(); Wait.pop(); if (now == 0) continue; Table[nowt] = T[now]; AnsI[cnt] = now; AnsO[cnt++] = Time; num[nowt]++; for (int i = 0; i cnt; i++) printf(%02d:%02d:%02d %02d:%02d:%02d %d , AnsI[i] / 3600, AnsI[i] % 3600 / 60, AnsI[i] % 60, AnsO[i] / 3600, AnsO[i] % 3600 / 60, AnsO[i] % 60, (AnsO[i] - AnsI[i] + 30) / 60); for (int i = 1; i = m; i++) if (i != 1) printf( ); printf(%d, num[i]); return 0; 1027 Colors in Mars#include iostream#include string#include algorithmusing namespace std;string convert(int n) string res = ; while (n) if (n % 13 9) res += n % 13 + A - 10; else res += n % 13 + 0; n /= 13; while (res.size() 2) res += 0; reverse(res.begin(), res.end()); return res;int main() int red, green, blue; cin red green blue; cout # convert(red) convert(green) convert(blue); return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main() char c[14] = 0123456789ABC; cout #; for (int i = 0; i 3; i++) int num; cin num; cout c[num / 13] c[num % 13]; return 0; 1028 List Sorting#include iostream#include string#include algorithm#include vectorusing namespace std;struct node string num, name; int score; nums[100001];bool cmp1 (node a, node b) return a.num b.num;bool cmp2 (node a, node b) if (a.name == b.name) return a.num b.num; else return a.name b.name;bool cmp3 (node a, node b) if (a.score == b.score) return a.num b.num; else return a.score b.score;int main() int n, c, score; string num, name; cin n c; for (int i = 0; i n; i++) cin nums[i].num nums[i].name nums[i].score; if (c == 1) sort(nums, nums + n, cmp1); else if (c == 2) sort(nums, nums + n, cmp2); else if (c == 3) sort(nums, nums + n, cmp3); for (int i = 0; i n; i++) cout nums[i].num nums[i].name nums[i].score endl; 1029 Median#include iostream#include vector#include algorithmusing namespace std;typedef long long LL;vectorLL nums;int main() LL n, x; scanf(%lld, n); for (int i = 0; i n; i++) scanf( %lld, x); nums.push_back(x); scanf(%lld, n); for (int i = 0; i n; i++) scanf( %lld, x); nums.push_back(x); sort(nums.begin(), nums.end()); cout nums[(nums.size() - 1) / 2]; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;const int N = 200005;int n, m, a1[N], a2[N];int main() cin n; for (int i = 1; i = n; i++) scanf(%d, a1[i]); cin m; for (int i = 1; i = m; i++) scanf(%d, a2[i]); int target = (n + m + 1) / 2; int i = 1, j = 1, cnt = 0, res; while (i = n j = m) res = a1[i] = a2[j] ? a1[i++] : a2[j++]; if (++cnt == target) break; if (i = n cnt target) res = a1[i + target - cnt - 1]; else if (j = m cnt target) res = a2[j + target - cnt - 1]; cout res; return 0; 1030 Travel Plandijkstra #include iostream#include vectorusing namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node int v, dis; node (int _v, int _dis) v = _v, dis = _dis; ;vectornode g[N];vectorint pre[N];int n, s, d[N], cost[N][N], mincost = INF;bool visit[N];void dijkstra(int s) fill(d, d + N, INF); d[s] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v; int dis = g[u][j].dis; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); else if (d[u] + dis == d[v]) pre[v].push_back(u); vectorint tmp, res;void dfs(int t) tmp.push_back(t); if (s == t) int minc = 0; for (int i = 0; i tmp.size() - 1; i++) int id = tmp[i], nexti = tmp[i + 1]; minc += cost[id][nexti]; if (minc mincost) mincost = minc; res = tmp; tmp.pop_back(); return; for (int i = 0; i pre[t].size(); i++) dfs(pre[t][i]); tmp.pop_back();int main() int m, t, u, v, w, c; cin n m s t; for (int i = 0; i m; i++) cin u v w c; cost[u][v] = cost[v][u] = c; g[u].push_back(node(v, w)); g[v].push_back(node(u, w)); dijkstra(s); dfs(t); for (int i = res.size() - 1; i = 0; i--) cout res[i] ; cout d[t] mincost; return 0; 1031 Hello World for U#include iostream#include stringusing namespace std;int main() string str; cin str; int len = str.size() + 2; int n = len / 3; int n2 = len - n * 3 + n - 2; for (int i = 0; i n - 1; i++) cout str[i]; for (int j = 0; j n2; j++) cout ; cout str[str.size() - 1 - i] endl; for (int i = n - 1; i n + n2 + 1; i++) cout str[i]; return 0; 1032 Sharing#include iostreamusing namespace std;const int N = 100001;struct node int next; char data; bool flag; nodes[N];int main() int s1, s2, n, add, next; char data; cin s1 s2 n; for (int i = 0; i n; i++) cin add data next; nodes[add] = next, data, false; for (int i = s1; i != -1; i = nodes[i].next) nodes[i].flag = true; for (int i = s2; i != -1; i = nodes[i].next) if (nodes[i].flag) printf(%05d, i); return 0; cout -1; return 0; 1033 To Fill or Not to Fillé”™è¯¯ç­”æ¡ˆï¼ˆæ²¡æœ‰è€ƒè™‘åˆ°æ²¹ç®±ä¸Šé™ï¼‰ #include iostream#include vector#include map#include queue#include algorithmusing namespace std;typedef pairdouble, double PII;vectorPII sites;int main() double c_max, d_max, d_avg, n,price, dis; cin c_max d_max d_avg n; for (int i = 0; i n; i++) cin price dis; if (dis = d_max) continue; sites.push_back(dis, price); sort(sites.begin(), sites.end()); int cur_site = 0; double res = 0, cur_dis = 0, diff = 0; priority_queuePII, vectorPII, greaterPII q; if (sites[0].first != 0) cout The maximum travel distance = 0.00; return 0; while (cur_dis d_max cur_site sites.size()) if (cur_site == sites.size() - 1) diff = d_max - cur_dis; else diff = sites[cur_site + 1].first - cur_dis; q.push(sites[cur_site++].second, c_max); while (!q.empty()) PII t = q.top(); q.pop(); if (d_avg * t.second = diff) res += t.first * t.second; diff -= d_avg * t.second; cur_dis += d_avg * t.second; else res += diff * t.first / d_avg; cur_dis += diff; q.push(t.first, t.second - diff / d_avg); diff = 0; break; if (diff 0) break; if (cur_dis == d_max) printf(%.2f, res); else printf(The maximum travel distance = %.2f, cur_dis); return 0; æŸ³å©¼çš„ï¼ˆè´ªå¿ƒï¼‰ #include iostream#include vector#include map#include algorithmusing namespace std;const int INF = 0x3f3f3f3f;typedef pairdouble, double PII;int main() double c_max, d_max, d_avg, n; cin c_max d_max d_avg n; vectorPII sta(n + 1); sta[0] = d_max, 0; for (int i = 1; i = n; i++) cin sta[i].second sta[i].first; sort(sta.begin(), sta.end()); double cur_dis = 0, max_dis = 0, cur_price = 0, total_price = 0, left_dis = 0; if (sta[0].first != 0) cout The maximum travel distance = 0.00; return 0; else cur_price = sta[0].second; while (cur_dis d_max) max_dis = cur_dis + c_max * d_avg; double min_price_dis = 0, min_price = INF; int flag = 0; for (int i = 1; i = n sta[i].first = max_dis; i++) if (sta[i].first = cur_dis) continue; if (sta[i].second = cur_price) total_price += (sta[i].first - cur_dis - left_dis) * cur_price / d_avg; left_dis = 0; cur_price = sta[i].second; cur_dis = sta[i].first; flag = 1; break; if (sta[i].second min_price) min_price = sta[i].second; min_price_dis = sta[i].first; if (flag == 0 min_price != INF) total_price += (cur_price * (c_max - left_dis / d_avg)); left_dis = c_max * d_avg - (min_price_dis - cur_dis); cur_price = min_price; cur_dis = min_price_dis; if (flag == 0 min_price == INF) cur_dis += c_max * d_avg; printf(The maximum travel distance = %.2f, cur_dis); return 0; printf(%.2f, total_price); return 0; 1034 Head of a Gangå¹¶æŸ¥é›†ï¼ˆå†™å¤æ‚äº†ï¼‰ #include iostream#include set#include vector#include map#include algorithmusing namespace std;typedef pairstring, int PII;const int N = 20000;int fa[N], sum[N], maxs[N];int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];int convert1(string x) return (x[0] - A) * 26 * 26 + (x[1] - A) * 26 + x[2] - A;string convert2(int x) string res = ; res += x / (26 * 26) + A; res += x % (26 * 26) / 26 + A; res += x % 26 + A; return res;setint nums;struct node int a, b, time;;vectornode relations;int main() int n, k, time; cin n k; string a, b; for (int i = 0; i n; i++) cin a b time; nums.insert(convert1(a)); nums.insert(convert1(b)); relations.push_back(convert1(a), convert1(b), time); for (auto i = nums.begin(); i != nums.end(); i++) fa[*i] = *i; for (int i = 0; i relations.size(); i++) int a = relations[i].a, b = relations[i].b, time = relations[i].time; if (fa[a] != fa[b]) sum[find(b)] = max(sum[find(a)], sum[find(b)]); fa[find(a)] = find(b); sum[find(b)] += time; maxs[a] += time; maxs[b] += time; setint bangs; for (auto i = nums.begin(); i != nums.end(); i++) if (sum[find(*i)] k) bangs.insert(find(*i)); vectorPII res; for (auto i = bangs.begin(); i != bangs.end(); i++) setint tmp; int m = 0, r; for (int j = 0; j relations.size(); j++) if (find(*i) == find(relations[j].a)) tmp.insert(relations[j].a); tmp.insert(relations[j].b); if (m maxs[relations[j].a]) m = maxs[relations[j].a]; r = relations[j].a; if (m maxs[relations[j].b]) m = maxs[relations[j].b]; r = relations[j].b; if (tmp.size() 2) res.push_back(convert2(r), tmp.size()); cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; return 0; æŸ³å©¼çš„ï¼ˆdfsï¼‰ #include iostream#include map#include string#include algorithmusing namespace std;mapstring, int stringToInt;mapint, string intToString;mapstring, int res;int id = 1, k;int stoifun(string s) if (stringToInt[s] == 0) stringToInt[s] = id; intToString[id] = s; return id++; else return stringToInt[s]; int g[2010][2010], weight[2010];bool vis[2010];void dfs(int u, int head, int numMember, int totalweight) vis[u] = true; numMember++; if (weight[u] weight[head]) head = u; for (int v = 1; v id; v++) if (g[u][v] 0) totalweight += g[u][v]; g[u][v] = g[v][u] = 0; if (!vis[v]) dfs(v, head, numMember, totalweight); void dfsTrave() for (int i = 1; i id; i++) if (!vis[i]) int head = i, numMember = 0, totalweight = 0; dfs(i, head, numMember, totalweight); if (numMember 2 totalweight k) res[intToString[head]] = numMember; int main() int n, w; cin n k; string s1, s2; for (int i = 0; i n; i++) cin s1 s2 w; int id1 = stoifun(s1); int id2 = stoifun(s2); weight[id1] += w; weight[id2] += w; g[id1][id2] += w; g[id2][id1] += w; dfsTrave(); cout res.size() endl; for (auto it = res.begin(); it != res.end(); it++) cout it-first it- second endl; return 0; 1035 Password#include iostream#include vector#include map#include stringusing namespace std;string convert(string a) string b = ; for (int i = 0; i a.size(); i++) if (a[i] == 1) b += @; else if (a[i] == 0) b += %; else if (a[i] == l) b += L; else if (a[i] == O) b += o; else b += a[i]; return b;int main() int n; cin n; string name, password; vectorpairstring, string res; for (int i = 0; i n; i++) cin name password; if (password != convert(password)) res.push_back(name, convert(password)); if (res.size() 1) cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; else if (n == 1) cout There is 1 account and no account is modified; else cout There are n accounts and no account is modified; return 0; 1036 Boys vs Girls#include iostream#include string#include algorithmusing namespace std;struct node string name, id; int grade;;bool cmp(node a, node b) return a.grade b.grade;vectornode males, famales;int main() int n; cin n; string name, gender, id; int grade; for (int i = 0; i n; i++) cin name gender id grade; if (gender == M) males.push_back(name, id, grade); else famales.push_back(name, id, grade); bool flag = false; int diff; sort(males.begin(), males.end(), cmp); sort(famales.begin(), famales.end(), cmp); if (famales.size() 0) cout famales[famales.size() - 1].name famales[famales.size() - 1].id endl; diff = famales[famales.size() - 1].grade; else cout Absent endl; flag = true; if (males.size() 0) cout males[0].name males[0].id endl; diff += -males[0].grade; else cout Absent endl; flag = true; if (flag) cout NA; else cout diff; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main() int n; scanf(%d, n); string female, male; int femalescore = -1, malescore = 101; for(int i = 0; i n; i++) string name, sex, num; int score; cin name sex num; scanf(%d, score); if(sex == F) if(femalescore score) femalescore = score; female = name + + num; else if(malescore score) malescore = score; male = name + + num; if(femalescore != -1) cout female endl; else printf(Absent ); if(malescore != 101) cout male endl; else printf(Absent ); if(femalescore != -1 malescore != 101) printf(%d, femalescore - malescore); else printf(NA); return 0; 1037 Magic Coupon#include iostream#include algorithmusing namespace std;const int N = 100001;int a[N], b[N];int main() int n, m; cin n; for (int i = 0; i n; i++) cin a[i]; cin m; for (int i = 0; i m; i++) cin b[i]; sort(a, a + n); sort(b, b + m); int al = 0, bl = 0, ar = n - 1, br = m - 1, res = 0; while(al n bl n a[al] 0 b[bl] 0) res += a[al++] * b[bl++]; while (ar = 0 br = 0 a[ar] 0 b[br] 0) res += a[ar--] * b[br--]; cout res; return 0; 1038 Recover the Smallest Number#include iostream#include string#include vector#include algorithmusing namespace std;bool cmp(string a, string b) return a + b b + a;typedef long long LL;int main() int n; string x; cin n; vectorstring nums(n); for (int i = 0; i n; i++) cin nums[i]; sort(nums.begin(), nums.end(), cmp); bool flag = true, first = true; for (int i = 0; i (LL)nums.size(); i++) if (first) int j = 0; for (; j (LL)nums[i].size(); j++) if (nums[i][j] != 0) break; if (j (LL)nums[i].size()) first = false; for (; j (LL)nums[i].size(); j++) cout nums[i][j]; flag = false; else cout nums[i]; if (flag) cout 0; return 0; æŸ³å©¼çš„ #include iostream#include string#include vector#include algorithmusing namespace std;bool cmp(string a, string b) return a + b b + a;string str[10010];int main() int n; cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n, cmp); string s; for (int i = 0; i n; i++) s += str[i]; while (s.size() != 0 s[0] == 0) s.erase(s.begin()); if (s.size() == 0) cout 0; cout s; return 0; 1039 Course List for Student#include iostream#include string#include map#include vector#include algorithmusing namespace std;mapstring, vectorint students;int main() int n, k, courseId, m; string name; cin n k; for (int i = 0; i k; i++) cin courseId m; for (int j = 0; j m; j++) cin name; students[name].push_back(courseId); for (int i = 0; i n; i++) cin name; cout name students[name].size(); sort(students[name].begin(), students[name].end()); for (int j = 0; j students[name].size(); j++) cout students[name][j]; cout endl; return 0; æŸ³å©¼çš„ #include cstdio#include vector#include algorithmusing namespace std;int getid(char *name) int id = 0; for(int i = 0; i 3; i++) id = 26 * id + (name[i] - A); id = id * 10 + (name[3] - 0); return id;const int maxn = 26 * 26 * 26 * 10 + 10;vectorint v[maxn];int main() int n, k, no, num, id = 0; char name[5]; scanf(%d %d, n, k); for(int i = 0; i k; i++) scanf(%d %d, no, num); for(int j = 0; j num; j++) scanf(%s, name); id = getid(name); v[id].push_back(no); for(int i = 0; i n; i++) scanf(%s, name); id = getid(name); sort(v[id].begin(), v[id].end()); printf(%s %lu, name, v[id].size()); for(int j = 0; j v[id].size(); j++) printf( %d, v[id][j]); printf( ); return 0; 1040 Longest Symmetric String#include iostream#include stringusing namespace std;const int N = 1005;bool dp[N][N];int main() string str; getline(cin, str); int n = str.size(), res = 1; for (int i = 1; i n; i++) dp[i][i] = true; if (i n - 1 str[i] == str[i + 1]) dp[i][i + 1] = true; res = 2; for (int len = 3; len = n; len++) for (int l = 0; l n - len + 1; l++) int r = l + len - 1; if (str[l] == str[r] dp[l + 1][r - 1]) dp[l][r] = true; res = len; cout res; return 0; 1041 Be Unique#include iostreamusing namespace std;const int N = 100005;int nums[N], cnt[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; cnt[nums[i]] ++; for (int i = 0; i n; i++) if (cnt[nums[i]] == 1) cout nums[i]; return 0; cout None; return 0; 1042 Shuffling Machine#include iostream#include stringusing namespace std;string nums[55] = ,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,H1,H2,H3,H4,H5,H6,H7,H8,H9,H10,H11,H12,H13,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13,J1, J2;int shuff[55];int main () int n; cin n; for (int i = 1; i 55; i++) cin shuff[i]; for (int i = 0; i n; i++) string tmps[55]; for (int j = 1; j 55; j++) tmps[shuff[j]] = nums[j]; copy(begin(tmps), end(tmps), begin(nums)); for (int i = 1; i 55; i++) cout nums[i]; if (i 54) cout ; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main () int cnt; cin cnt; int start[55], end[55], scan[55]; for (int i = 1; i 55; i++) cin scan[i]; end[i] = i; for (int i = 0; i cnt; i++) for (int j = 1; j 55; j++) start[j] = end[j]; for (int k = 1; k 55; k++) end[scan[k]] = start[k]; char c[6] = SHCDJ; for (int i = 1; i 55; i++) end[i] = end[i] - 1; cout c[end[i] / 13] end[i] % 13 + 1; if (i != 54) cout ; return 0; 1043 Is It a Binary Search Tree#include iostream#include vectorusing namespace std;bool isMirror;vectorint pre, post;void getpost(int root, int tail) if (root tail) return; int i = root + 1, j = tail; if (!isMirror) while (i = tail pre[root] pre[i]) i++; while (j root pre[root] = pre[j]) j--; else while (i = tail pre[root] = pre[i]) i++; while (j root pre[root] pre[j]) j--; if (i - j != 1) return; getpost(root + 1, j); getpost(i, tail); post.push_back(pre[root]);int main() int n; cin n; pre.resize(n); for (int i = 0; i n; i++) cin pre[i]; getpost(0, n - 1); if (post.size() != n) isMirror = true; post.clear(); getpost(0, n - 1); if (post.size() == n) cout YES endl; for (int i = 0; i n; i++) cout post[i]; if (i n - 1) cout ; else cout NO; return 0; 1044 Shopping in Marsæ»‘åŠ¨çª—å£ #include iostream#include vector#include mapusing namespace std;const int N = 100005;vectorpairint, int res;int nums[N];int main() int n, m; cin n m; for (int i = 0; i n; i++) cin nums[i]; int tmp = 0, maxn = 0x3f3f3f3f; int l = 0, r = 0; while (r n) tmp += nums[r]; if (tmp = m tmp maxn) maxn = tmp; if (tmp == maxn) res.push_back(l + 1, r + 1); while (l r tmp = m) if (maxn tmp) maxn = tmp; res.clear(); if (tmp == maxn) res.push_back(l + 1, r + 1); tmp -= nums[l++]; if (tmp == maxn) res.push_back(l + 1, r + 1); r++; for (int i = 0; i res.size(); i++) cout res[i].first - res[i].second endl; return 0; æŸ³å©¼çš„ï¼ˆäºŒåˆ†ï¼‰ #include iostream#include vectorusing namespace std;vectorint sum, res;int n, m;void search(int i, int j, int tmp) int l = i, r = n; while (l r) int mid = (l + r) / 2; if (sum[mid] - sum[i - 1] = m) r = mid; else l = mid + 1; j = r; tmp = sum[j] - sum[i - 1];int main() cin n m; sum.resize(n + 1); for (int i = 1; i = n; i++) cin sum[i]; sum[i] += sum[i - 1]; int minres = sum[n]; for (int i = 1; i = n; i++) int j, tmpsum; search(i, j, tmpsum); if (tmpsum minres) continue; if (tmpsum = m) if (tmpsum minres) res.clear(); minres = tmpsum; res.push_back(i); res.push_back(j); for (int i = 0; i res.size(); i += 2) cout res[i] - res[i + 1] endl; return 0; 1045 Favorite Color StripeåŠ¨æ€è§„åˆ’ #include iostream#include algorithmusing namespace std;int dp[10001], b[201], a[10001];int main() int n, m, x, l, num = 0, res = 0; cin n m; for (int i = 1; i = m; i++) cin x; b[x] = i; cin l; for (int i = 0; i l; i++) cin x; if (b[x] = 1) a[num++] = b[x]; for (int i = 0; i num; i++) dp[i] = 1; for (int j = 0; j i; j++) if (a[i] = a[j]) dp[i] = max(dp[i], dp[j] + 1); res = max(dp[i], res); cout res; return 0; 1046 Shortest Distanceå‰ç¼€å’Œ #include iostream#include algorithmusing namespace std;const int N = 200001;int nums[N], sums[N];int main() int n, m, a, b; cin n; for (int i = 1; i = n; i++) cin nums[i]; nums[i + n] = nums[i]; sums[i] = sums[i - 1] + nums[i]; for (int i = n + 1; i n + n; i++) sums[i] = sums[i - 1] + nums[i]; cin m; for (int i = 0; i m; i++) cin a b; if (a b) swap(a, b); cout min(sums[b - 1] - sums[a - 1], sums[a + n - 1] - sums[b - 1]) endl; return 0; 1047 Student List for Course#include iostream#include vector#include string#include algorithmusing namespace std;vectorstring course[2501];int main() int n, k, c, x; string name; cin n k; for (int i = 0; i n; i++) cin name c; for (int j = 0; j c; j++) cin x; course[x].push_back(name); for (int i = 1; i = k; i++) cout i course[i].size() endl; sort(course[i].begin(), course[i].end()); for (int j = 0; j course[i].size(); j++) printf(%s , course[i][j].c_str()); return 0; 1048 Find CoinsåŒæŒ‡é’ˆ #include iostream#include algorithmusing namespace std;const int N = 100005;int nums[N];int main() int n, m, cnt = 0, x; cin n m; for (int i = 0; i n; i++) cin x; if (x m) nums[cnt++] = x; sort(nums, nums + cnt); int l = 0, r = cnt - 1, tmp = nums[l] + nums[r]; while (l r) if (tmp == m) cout nums[l] nums[r]; return 0; else if (tmp m) r--; else l++; tmp = nums[l] + nums[r]; cout No Solution; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int nums[1001];int main() int n, m, cnt = 0, x; cin n m; for (int i = 0; i n; i++) cin x; nums[x] ++; for (int i = 0; i 1001; i++) if (nums[i]) nums[i]--; if (m i nums[m - i]) cout i m - i; return 0; cout No Solution; return 0; 1049 Counting Onesæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ #include iostreamusing namespace std;int main() int n, cnt = 0; cin n; for (int i = 1; i = n; i++) int a = i; while (a) if (a % 10 == 1) cnt++; a /= 10; cout cnt; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main() int n, left = 0, right = 0, a = 1, now = 1, res = 0; cin n; while (n / a) left = n / (a * 10), now = n / a % 10, right = n % a; if (now == 0) res += left * a; else if (now == 1) res += left * a + right + 1; else res += (left + 1) * a; a = a * 10; cout res; return 0; 1050 String Subtraction#include iostream#include string#include setusing namespace std;string s1, s2;bool nums[129];int main() getline(cin, s1); getline(cin, s2); for (auto i: s2) nums[i] = true; for (auto i: s1) if (!nums[i]) cout i; return 0; 1051 Pop Sequence#include iostream#include stackusing namespace std;int main() int m, n, k, x; cin m n k; for (int i = 0; i k; i++) int cnt = 1; stackint st; bool flag = true; for (int j = 0; j n; j++) cin x; while (x = cnt st.size() m cnt = n) st.push(cnt); cnt++; if (st.top() != x) flag = false; while (j++ n - 1) cin x; break; st.pop(); cout (flag ? YES : NO) endl; return 0; 1052 Linked List Sorting#include iostream#include algorithm#include mapusing namespace std;typedef pairint, int PII;struct node int add, key, next;;bool cmp(PII a, PII b) return a.second b.second;const int INF = 0x3f3f3f3f;const int N = 100001;node nums[N];vectorPII nums2;int main() int n, head, add, key, nex; cin n head; if (head == -1) cout 0 -1; return 0; for (int i = 0; i n; i++) cin add key nex; nums[add] = add, key, nex; while (head != -1) nums2.push_back(head, nums[head].key); head = nums[head].next; sort(nums2.begin(), nums2.end(), cmp); printf(%d %05d , nums2.size(), nums2[0].first); for (int i = 0; i nums2.size() - 1; i++) printf(%05d %d %05d , nums2[i].first, nums2[i].second, nums2[i + 1].first); printf(%05d %d -1 , nums2[nums2.size() - 1].first, nums2[nums2.size() - 1].second); return 0; 1053 Path of Equal Weight#include iostream#include vector#include algorithmusing namespace std;const int N = 100;int weight[N], sum, s;vectorint trees[N], tmp;vectorvectorint res;bool cmp(const vectorint a, const vectorint b) for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] b[i]; void dfs(int x) if (sum == s trees[x].empty()) res.push_back(tmp); return; if (sum s) return; for (int i = 0; i trees[x].size(); i++) sum += weight[trees[x][i]]; tmp.push_back(weight[trees[x][i]]); dfs(trees[x][i]); sum -= weight[trees[x][i]]; tmp.pop_back(); int main() int n, m, cur, k, child; cin n m s; for (int i = 0; i n; i++) cin weight[i]; s -= weight[0]; tmp.push_back(weight[0]); for (int i = 0; i m; i++) cin cur k; for (int j = 0; j k; j++) cin child; trees[cur].push_back(child); dfs(0); sort(res.begin(), res.end(), cmp); for (int i = 0; i res.size(); i++) for (int j = 0; j res[i].size(); j++) printf(%d, res[i][j]); if (j res[i].size() - 1) printf( ); else printf( ); return 0; 1054 The Dominant Color#include iostream#include map#include algorithmusing namespace std;mapint, int nums;vectorpairint, int res;bool cmp(pairint, int a, pairint, int b) return a.second b.second;int main() int m, n, x; cin m n; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x]++; for (auto it: nums) res.push_back(it); sort(res.begin(), res.end(), cmp); cout res[0].first; return 0; æŸ³å©¼çš„ #include iostream#include mapusing namespace std;mapint, int nums;int main() int m, n, x; cin m n; int half = m * n / 2; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x]++; if (nums[x] half) cout x; return 0; return 0; 1055 The Worldâ€™s Richest#include iostream#include vector#include string#include algorithmusing namespace std;struct node string name; int age, worth;;bool cmp(node a, node b) if (a.worth != b.worth) return a.worth b.worth; else if (a.age != b.age) return a.age b.age; else return a.name b.name;vectornode nums[201];int main() int n, k, age, worth, m, start, end; cin n k; string name; for (int i = 0; i n; i++) cin name age worth; nums[age].push_back(name, age, worth); for (int i = 1; i = k; i++) cin m start end; if (start 1) start = 1; if (end 200) end = 200; vectornode tmp; for (int j = start; j = end; j++) for (auto it: nums[j]) tmp.push_back(it.name, it.age, it.worth); sort(tmp.begin(), tmp.end(), cmp); printf(Case #%d: , i); for (int j = 0; j min((int)tmp.size(), m); j++) printf(%s %d %d , tmp[j].name.c_str(), tmp[j].age, tmp[j].worth); if (tmp.empty()) printf(None); return 0; æŸ³å©¼çš„ #include iostream#include vector#include string#include algorithmusing namespace std;struct node string name; int age, worth; nums[100001];bool cmp(node a, node b) if (a.worth != b.worth) return a.worth b.worth; else if (a.age != b.age) return a.age b.age; else return a.name b.name;int main() int n, k, age, worth, m, start, end; cin n k; string name; for (int i = 0; i n; i++) cin nums[i].name nums[i].age nums[i].worth; sort(nums, nums + n, cmp); for (int i = 1; i = k; i++) printf(Case #%d: , i); cin m start end; int cnt = 0; for (int j = 0; j n; j++) if (nums[j].age = start nums[j].age = end) printf(%s %d %d , nums[j].name.c_str(), nums[j].age, nums[j].worth); cnt++; if (cnt == m) break; if (cnt == 0) printf(None); return 0; 1056 Mice and Rice#include iostream#include vector#include algorithmusing namespace std;int weight[10001], ranks[10001];vectorint tmp, res[300];int main() int np, ng, x; cin np ng; for (int i = 0; i np; i++) cin weight[i]; for (int i = 0; i np; i++) cin x; tmp.push_back(x); int depth = 0, d = np / ng + 1; while (d--) for (int i = 0; i tmp.size(); i += ng) int ma = 0, idx = 0; for (int j = i; j min(ng + i, (int)tmp.size()); j++) if (weight[tmp[j]] ma) ma = weight[tmp[j]]; idx = tmp[j]; res[depth + 1].push_back(idx); for (int j = i; j min(ng + i, (int)tmp.size()); j++) if (tmp[j] != idx) res[depth].push_back(tmp[j]); tmp.clear(); tmp = res[depth + 1]; res[depth + 1].clear(); depth++; int rank = 1; ranks[tmp[0]] = rank++; for (int i = depth - 1; i = 0; i--) for (auto it: res[i]) ranks[it] = rank; rank += res[i].size(); for (int i = 0; i np; i++) cout ranks[i]; if (i np - 1) cout ; return 0; 1057 Stackæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ #include iostream#include string#include stack#include vector#include algorithmusing namespace std;stackint st;vectorint tmp;int main() int n, x; string op; cin n; for (int i = 0; i n; i++) cin op; if (op == Pop) if (st.empty()) cout Invalid endl; else cout st.top() endl; tmp.erase(find(tmp.begin(), tmp.end(), st.top())); st.pop(); else if (op == Push) cin x; st.push(x); tmp.push_back(x); else if (op == PeekMedian) if (st.empty()) cout Invalid endl; else sort(tmp.begin(), tmp.end()); if (tmp.size() % 2) cout tmp[(tmp.size() - 1) / 2] endl; else cout tmp[tmp.size() / 2 - 1] endl; return 0; æŸ³å©¼çš„ï¼ˆæ ‘çŠ¶æ•°ç»„ï¼‰ #include iostream#include stackusing namespace std;#define lowbit(i) ((i) (-i))const int N = 100010;int c[N];stackint s;void update(int x, int v) for (int i = x; i N; i += lowbit(i)) c[i] += v;int getsum(int x) int sum = 0; for (int i = x; i = 1; i -= lowbit(i)) sum += c[i]; return sum;void PeekMedian() int left = 1, right = N, mid, k = (s.size() + 1) / 2; while (left right) mid = (left + right) / 2; if (getsum(mid) = k) right = mid; else left = mid + 1; printf(%d , left);int main() int n, tmp; scanf(%d, n); char str[15]; for (int i = 0; i n; i++) scanf(%s, str); if (str[1] == u) scanf(%d, tmp); s.push(tmp); update(tmp, 1); else if (str[1] == o) if (!s.empty()) update(s.top(), -1); printf(%d , s.top()); s.pop(); else printf(Invalid ); else if (!s.empty()) PeekMedian(); else printf(Invalid ); return 0; 1058 A+B in Hogwarts - PAT (Advanced Level) Practice (pintia.cn)#include iostreamint main() int a1, a2, a3, b1, b2, b3, c1, c2, c3, t; scanf(%d.%d.%d %d.%d.%d, a1, a2, a3, b1, b2, b3); c3 = (a3 + b3) % 29; t = (a3 + b3) / 29; c2 = (a2 + b2 + t) % 17; t = (a2 + b2 + t) / 17; c1 = a1 + b1 + t; printf(%d.%d.%d, c1, c2, c3); return 0; 1059 Prime Factors#include iostream#include cmathusing namespace std;typedef long long LL;int main() LL n; cin n; cout n =; if (n == 1) cout 1; for (LL i = 2; i = sqrt(n); i++) int cnt = 0; if (n % i == 0) while (n % i == 0) cnt++; n /= i; if (cnt 1) cout i ^ cnt; else if (cnt == 1) cout i; if (cnt != 0 n 1) cout *; if (n 1) cout n; return 0; 1060 Are They Equal#include iostream#include stringusing namespace std;string convert(string str, int n) int idx = 0, len = str.size(), k = 0; string t; while (idx len str[idx] == 0) idx++; if (str[idx] == .) idx++; while (idx len str[idx] == 0) idx++; k--; bool flag = false; while (t.size() n idx len) t.push_back(str[idx++]); flag = true; while (t.size() n) t.push_back(0); if (!flag) k = 0; else for (int j = idx; str[j] != . j len; j++) k++; while (str[idx] != . t.size() n idx len) t.push_back(str[idx++]); if (t.size() n) idx++; while (idx len t.size() n) t.push_back(str[idx++]); while (t.size() n) t.push_back(0); return 0. + t + *10^ + to_string(k);int main() int n; string a, b; cin n a b; a = convert(a, n); b = convert(b, n); if (a == b) cout YES a; else cout NO a b; return 0; 1061 Dating#include iostream#include stringusing namespace std;int main() string a, b, c, d; cin a b c d; int sa = a.size(), sb = b.size(), sc = c.size(), sd = d.size(); int week, hour, minute, cnt = 0; string weeks[7] = MON, TUE, WED, THU, FRI, SAT, SUN; bool is_first = true; for (int i = 0; i min(sa, sb); i++) if (a[i] == b[i] a[i] = A a[i] = G is_first) week = a[i] - A; is_first = false; continue; if (!is_first a[i] == b[i] ((a[i] = A a[i] = N) || isdigit(a[i]))) if (a[i] = A a[i] = N) hour = a[i] - A + 10; else if (isdigit(a[i])) hour = a[i] - 0; break; for (int i = 0; i min(sc, sd); i++) if (c[i] == d[i] isalpha(c[i])) minute = i; break; printf(%s %02d:%02d, weeks[week].c_str(), hour, minute); return 0; 1062 Talent and Virtue#include iostream#include string#include vector#include algorithmusing namespace std;struct node int num, virtue, talent, sum;;bool cmp(node a, node b) if (a.sum != b.sum) return a.sum b.sum; else if (a.virtue != b.virtue) return a.virtue b.virtue; else if (a.talent != b.talent) return a.talent b.talent; else return a.num b.num;vectornode sage, nobleman, fool, small;int main() int n, l, h, num, virtue, talent; cin n l h; for (int i = 0; i n; i++) cin num virtue talent; int sum = virtue + talent; if (virtue = h talent = h) sage.push_back(num, virtue, talent, sum); else if (virtue = h talent = l) nobleman.push_back(num, virtue, talent, sum); else if (virtue = talent talent = l) fool.push_back(num, virtue, talent, sum); else if (virtue = l talent = l) small.push_back(num, virtue, talent, sum); sort(sage.begin(), sage.end(), cmp); sort(nobleman.begin(), nobleman.end(), cmp); sort(fool.begin(), fool.end(), cmp); sort(small.begin(), small.end(), cmp); cout sage.size() + nobleman.size() + fool.size() + small.size() endl; for (auto it: sage) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: nobleman) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: fool) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: small) printf(%08d %d %d , it.num, it.virtue, it.talent); return 0; 1063 Set Similarity#include iostream#include mapusing namespace std;mapint, bool nums[51];int main() int n, m, x, k, a, b; cin n; for (int i = 1; i = n; i++) cin m; for (int j = 0; j m; j++) scanf(%d, x); nums[i][x] = true; cin k; for (int i = 0; i k; i++) cin a b; mapint, bool tmp; tmp = nums[a]; int common = 0, total = 0; for (auto it: nums[b]) if (tmp[it.first]) tmp[it.first] = false; common++; total++; else total++; for (auto it: tmp) if (it.second) total++; printf(%.1f\\% , common * 100.0 / total); return 0; 1064 Complete Binary Search Tree#include iostream#include algorithmusing namespace std;const int N = 1001;int in[N], level[N], n, idx = 0;void dfs(int root) if (root = n) return; dfs(root * 2 + 1); level[root] = in[idx++]; dfs(root * 2 + 2);int main() cin n; for (int i = 0; i n; i++) cin in[i]; sort(in, in + n); dfs(0); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; return 0; 1065 A+B and C (64bit)#include iostreamusing namespace std;typedef long long LL;int main() int n; LL a, b, c; cin n; for (int i = 1; i = n; i++) cin a b c; LL t = a + b; if (a 0 b 0 t 0) cout Case # i : true endl; else if (a 0 b 0 t 0) cout Case # i : false endl; else if (a + b c) cout Case # i : true endl; else cout Case # i : false endl; return 0; 1066 Root of AVL Tree#include iostreamusing namespace std;struct node int val; node *left, *right;;node* rotateLeft(node* root) node *t = root-right; root-right = t-left; t-left = root; return t;node* rotateRight(node* root) node *t = root-left; root-left = t-right; t-right = root; return t;node* rotateLeftRight(node* root) root-left = rotateLeft(root-left); return rotateRight(root);node* rotateRightLeft(node* root) root-right = rotateRight(root-right); return rotateLeft(root);int getHeight(node* root) if (root == NULL) return 0; return max(getHeight(root-left), getHeight(root-right)) + 1;node* insert(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-left = NULL; root-right = NULL; else if (val root-val) root-left = insert(root-left, val); if (getHeight(root-left) - getHeight(root-right) == 2) root = val root-left-val ? rotateRight(root) : rotateLeftRight(root); else root-right = insert(root-right, val); if (getHeight(root-right) - getHeight(root-left) == 2) root = val root-right-val ? rotateLeft(root) : rotateRightLeft(root); return root;int main() int n, val; cin n; node *root = NULL; for (int i = 0; i n; i++) cin val; root = insert(root, val); cout (%d, root-val); return 0; 1067 Sort with Swap(0, i)#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n, x, res = 0; cin n; for (int i = 0; i n; i++) scanf(%d, x); nums[x] = i; for (int i = 1; i n; i++) if (nums[i] != i) while (nums[0] != 0) swap(nums[0], nums[nums[0]]); res++; if (nums[i] != i) swap(nums[0], nums[i]); res++; cout res; return 0; 1068 Find More Coinsdfs #include iostream#include vector#include algorithmusing namespace std;int nums[10001], n, m;vectorint tmp;void dfs(int x, int t) if (t == m) for (int i = 0; i tmp.size(); i++) cout tmp[i]; if (i tmp.size() - 1) cout ; exit(0); if (t m || x == n) return; tmp.push_back(nums[x]); dfs(x + 1, t + nums[x]); tmp.pop_back(); dfs(x + 1, t);int main() int sum = 0; cin n m; for (int i = 0; i n; i++) cin nums[i]; sum += nums[i]; if (sum m) cout No Solution; else sort(nums, nums + n); dfs(0, 0); cout No Solution; return 0; æŸ³å©¼çš„ï¼ˆdpï¼‰ #include iostream#include vector#include algorithmusing namespace std;int dp[100001], nums[100001];bool choice[100001][110];int main() int n, m; cin n m; for (int i = 1; i = n; i++) cin nums[i]; sort(nums + 1, nums + n + 1, greaterint()); for (int i = 1; i = n; i++) for (int j = m; j = nums[i]; j--) if (dp[j] = dp[j - nums[i]] + nums[i]) choice[i][j] = true; dp[j] = dp[j - nums[i]] + nums[i]; if (dp[m] != m) cout No Solution; else vectorint res; int v = m, idx = n; while(v 0) if (choice[idx][v] == true) res.push_back(nums[idx]); v -= nums[idx]; idx--; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1069 The Black Hole of Numbers#include iostream#include string#include algorithmusing namespace std;int main() string n; cin n; while(n.size() 4) n = 0 + n; do string a = n, b = n; sort(a.begin(), a.end()); sort(b.begin(), b.end(), greaterchar()); int c = stoi(b) - stoi(a); n = to_string(c); while(n.size() 4) n = 0 + n; cout b - a = n endl; while (n != 6174 n!= 0000); return 0; 1070 Mooncake#include iostream#include algorithmusing namespace std;struct node double amount, price, profit; nums[1001];bool cmp(node a, node b) return a.profit b.profit;int main() int n, m; cin n m; for (int i = 0; i n; i++) cin nums[i].amount; for (int i = 0; i n; i++) cin nums[i].price; nums[i].profit = nums[i].price / nums[i].amount; sort(nums, nums + n, cmp); double res; for (int i = 0; i n; i++) if (nums[i].amount = m) res += m * nums[i].profit; break; else res += nums[i].price; m -= nums[i].amount; printf(%.2f, res); return 0; 1071 Speech Patterns#include iostream#include string#include mapusing namespace std;mapstring, int nums;int main() string str; getline(cin, str); str += .; for (int i = 0; i str.size(); i++) for (int j = i; j str.size(); j++) if (isalpha(str[j])) str[j] = tolower(str[j]); if (!isalnum(str[j])) if (j != i) nums[str.substr(i, j - i)]++; i = j; break; string res = nums.begin()-first; int m = nums.begin()-second; for (auto it: nums) if (m it.second) m = it.second; res = it.first; cout res m; return 0; 1072 Gas Stationdijkstra #include iostream#include string#include vector#include mapusing namespace std;const int N = 1012;const int INF = 0x3f3f3f3f;vectorpairint, int g[N];int dist[N], n, m, sums[11], mins[11];bool visit[N];void dijkstra(int x) fill(dist, dist + N, INF); fill(visit, visit + N, false); dist[x] = 0; for (int i = 0; i n + m; i++) int u = -1, mind = INF; for (int j = 1; j = n + m; j++) if (!visit[j] mind dist[j]) mind = dist[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v] dist[v] dist[u] + dis) dist[v] = dist[u] + dis; int main() int k, d, dis, t1, t2; string p1, p2; cin n m k d; for (int i = 0; i k; i++) cin p1 p2 dis; if (p1[0] == G) t1 = n + stoi(p1.substr(1)); else t1 = stoi(p1); if (p2[0] == G) t2 = n + stoi(p2.substr(1)); else t2 = stoi(p2); g[t1].push_back(t2, dis); g[t2].push_back(t1, dis); int real_sum = INF, real_min = 0, real_id = 0; for (int i = 1; i = m; i++) dijkstra(n + i); int res = INF, sum = 0; bool flag = true; for (int j = 1; j = n; j++) if (dist[j] d) flag = false; break; sum += dist[j]; res = min(res, dist[j]); if (flag) if (real_min res) real_sum = sum; real_id = i; real_min = res; else if (real_min == res) if (real_sum sum) real_sum = sum; real_id = i; if (real_min == 0) cout No Solution; else printf(G%d %.1f %.1f, real_id, (double)real_min, (double)real_sum / n); return 0; 1073 Scientific Notation#include iostream#include stringusing namespace std;int main() string str; cin str; if (str[0] == -) cout -; int exp, i; for (i = 3; i str.size(); i++) if (str[i] == E) break; if (str[i + 1] == -) exp = stoi(str.substr(i + 2)); cout 0.; for (int j = 0; j exp - 1; j++) cout 0; cout str[1] str.substr(3, i - 3); else exp = stoi(str.substr(i + 1)); if (str[1] != 0) cout str[1]; if (exp i - 3) for (int j = 0; j exp; j++) cout str[j + 3]; cout .; for (int j = exp; j i - 3; j++) cout str[j + 3]; else for (int j = 0; j exp; j++) if (j i - 3) cout str[j + 3]; else cout 0; return 0; æŸ³å©¼çš„ #include iostream#include stringusing namespace std;int main() string s; cin s; int i = 0; while (s[i] != E) i++; string t = s.substr(1, i - 1); int n = stoi(s.substr(i + 1)); if (s[0] == -) cout -; if (n 0) cout 0.; for (int j = 0; j abs(n) - 1; j++) cout 0; for (int j = 0; j t.length(); j++) if (t[j] != .) cout t[j]; else cout t[0]; int cnt, j; for (j = 2, cnt = 0; j t.length() cnt n; j++, cnt++) cout t[j]; if (j == t.length()) for (int k = 0; k n - cnt; k++) cout 0; else cout .; for (int k = j; k t.length(); k++) cout t[k]; return 0; 1074 Reversing Linked Listæ•°ç»„æ¨¡æ‹Ÿ #include iostream#include string#include vector#include mapusing namespace std;struct node string addr, nex; int val; ;mapstring, node nums1;vectornode nums2;int main() int n, k, val; string start, addr, nex; cin start n k; for (int i = 0; i n; i++) cin addr val nex; nums1[addr] = addr, nex, val; while (start != -1) nums2.push_back(nums1[start].addr, nums1[start].nex, nums1[start].val); start = nums1[start].nex; for (i = 0; i = nums2.size() - k; i += k) for (int j = i + k - 1; j i; j--) cout nums2[j].addr nums2[j].val nums2[j - 1].addr endl; cout nums2[i].addr nums2[i].val ; if (i + 2 * k = nums2.size()) cout nums2[i + 2 * k - 1].addr endl; else if (i + k nums2.size()) cout nums2[i + k].addr endl; else cout -1 ; for (int j = i; j nums2.size(); j++) cout nums2[j].addr nums2[j].val nums2[j].nex endl; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;const int N = 100005;int datas[N], nexts[N], list[N], res[N];int main() int first, k, n, sum = 0, tmp; cin first n k; for (int i = 0; i n; i++) cin tmp; cin datas[tmp] nexts[tmp]; while (first != -1) list[sum++] = first; first = nexts[first]; for (int i = 0; i sum; i++) res[i] = list[i]; for (int i = 0; i (sum - sum % k); i++) res[i] = list[i / k * k + k - 1 - i % k]; for (int i = 0; i sum - 1; i++) printf(%05d %d %05d , res[i], datas[res[i]], res[i + 1]); printf(%05d %d -1, res[sum - 1], datas[res[sum - 1]]); return 0; 1075 PAT Judge#include iostream#include algorithmusing namespace std;struct node int userId = 99999, totle, s[6] = -1, -1, -1, -1, -1, -1, perfect; bool isShow; nums[10001];bool cmp(node a, node b) if (a.totle != b.totle) return a.totle b.totle; else if (a.perfect != b.perfect) return a.perfect b.perfect; return a.userId b.userId;int w[6];int main() int n, k, m; cin n k m; for (int i = 1; i = k; i++) cin w[i]; int userId, problemId, score; for (int i = 0; i m; i++) cin userId problemId score; nums[userId].userId = userId; if (score 1) nums[userId].s[problemId] = max(0, nums[userId].s[problemId]); if (score = 0) nums[userId].isShow = true; if (score nums[userId].s[problemId]) if (score == w[problemId]) nums[userId].perfect++; nums[userId].totle += score - max(0, nums[userId].s[problemId]); nums[userId].s[problemId] = score; sort(nums, nums + 10001, cmp); int rank = 1; for (int i = 0; i 10000; i++) if (!nums[i].isShow) break; if (i != 0 nums[i].totle != nums[i - 1].totle) rank = i + 1; printf(%d %05d %d , rank, nums[i].userId, nums[i].totle); for (int j = 1; j = k; j++) if (nums[i].s[j] 0) cout -; else cout nums[i].s[j]; if (j k) cout ; else cout endl; return 0; 1076 Forwards on Weibo#include iostream#include vector#include queueusing namespace std;vectorint g[1001];bool visit[1001];int bfs(int u, int l) queueint q; q.push(u); fill(visit, visit + 1001, false); visit[u] = true; int res = 0, cnt = 0; while (!q.empty()) if (cnt = l) break; int len = q.size(); for (int i = 0; i len; i++) u = q.front(); q.pop(); for (int j = 0; j g[u].size(); j++) if (!visit[g[u][j]]) visit[g[u][j]] = true; res++; q.push(g[u][j]); cnt++; return res;int main() int n, l, m, x, k, query; cin n l; for (int i = 1; i = n; i++) cin m; for (int j = 0; j m; j++) cin x; g[x].push_back(i); cin k; for (int i = 0; i k; i++) cin query; int res = bfs(query, l); cout res endl; return 0; 1077 Kuchiguse#include iostream#include string#include algorithmusing namespace std;string strs[101];int main() int n, len = 257; cin n; getchar(); for (int i = 0; i n; i++) getline(cin, strs[i]); len = min((int)strs[i].size(), len); string res = ; for (int i = 1; i = len; i++) char ch = strs[0][strs[0].size() - i]; for (int j = 0; j n; j++) if (strs[j][strs[j].size() - i] != ch) if (res.empty()) cout nai; else cout res; return 0; res = ch + res; cout res; return 0; 1078 Hashing#include iostream#include algorithm#include vectorusing namespace std;const int N = 20001;vectorint primes;bool st[N];bool res[N];int main() int m, n, x; cin m n; for (int i = 2; i N; i++) if (!st[i]) primes.push_back(i); if (i = m) m = i; break; for (int j = i * 2; j N; j += i) st[j] = true; for (int i = 0; i n; i++) cin x; bool flag = false; for (int j = 0; j m; j++) if (!res[(x + j * j) % m]) cout (x + j * j) % m; res[(x + j * j) % m] = true; flag = true; break; if (!flag) cout -; if (i n - 1) cout ; return 0; 1079 Total Sales of Supply Chain#include iostream#include vectorusing namespace std;struct node int val; vectorint child; trees[100001];double r, res;void dfs(int u, double p) if (trees[u].child.empty()) res += trees[u].val * p; return; for (int i = 0; i trees[u].child.size(); i++) dfs(trees[u].child[i], p + p * r); int main() int n, k, x; double p; cin n p r; r /= 100; for (int i = 0; i n; i++) cin k; if (k == 0) cin x; trees[i].val = x; else for (int j = 0; j k; j++) cin x; trees[i].child.push_back(x); dfs(0, p); printf(%.1f, res); return 0; 1080 Graduate Admission#include iostream#include algorithm#include vectorusing namespace std;struct student int num, ge, gi, total, apps[6], rank; students[40001];int limits[101];vectorint schools[101];bool cmp(student a, student b) if (a.total != b.total) return a.total b.total; else if (a.ge != b.ge) return a.ge b.ge; else return a.num b.num;int main() int n, m, k, ge, gi, total, rank = 1; cin n m k; for (int i = 0; i m; i++) cin limits[i]; for (int i = 0; i n; i++) cin students[i].ge students[i].gi; students[i].total = students[i].ge + students[i].gi; for (int j = 0; j k; j++) cin students[i].apps[j]; students[i].num = i; sort(students, students + n, cmp); for (int i = 0; i n; i++) if (i != 0 (students[i].total != students[i - 1].total || students[i].ge != students[i - 1].ge)) rank++; students[i].rank = rank; for (int i = 0; i n; i++) for (int j = 0; j k; j++) int t = students[i].apps[j]; if (limits[t]) schools[t].push_back(students[i].num); limits[t]--; while (limits[t] == 0 i n - 1 students[i].rank == students[i + 1].rank) schools[t].push_back(students[i + 1].num); i++; break; for (int i = 0; i m; i++) sort(schools[i].begin(), schools[i].end()); for (int j = 0; j schools[i].size(); j++) cout schools[i][j]; if (j schools[i].size() - 1) cout ; cout endl; return 0; 1081 Rational Sum#include iostreamusing namespace std;typedef long long LL;LL gcd(LL a, LL b) if (b == 0) return a; else return gcd(b, a % b);void convert(LL a, LL b) if (a * b 0) cout -; a = abs(a); b = abs(b); LL t = a / b; if (t) cout t; a -= b * t; if (a == 0) if (t == 0) cout 0; return; if (t != 0) cout ; cout a / b;int main() LL n, numerator, denominator, a, b; cin n; for (int i = 0; i n; i++) scanf(%lld/%lld, a, b); if (i != 0) LL c = numerator * b + denominator * a; LL d = denominator * b; LL t = gcd(c, d); numerator = c / t; denominator = d / t; else numerator = a, denominator = b; convert(numerator, denominator); return 0; 1082 Read Number in Chineseå¤§æ¨¡æ‹Ÿ #include iostream#include vector#include stringusing namespace std;int main() string dicts[10] = ling, yi, er, san, si, wu, liu, qi, ba, jiu; int n; vectorstring res; cin n; if (n == 0) cout ling; return 0; if (n 0) res.push_back(Fu); n = -n; int raw = n; if (n = 100000000) res.push_back(dicts[n / 100000000]); res.push_back(Yi); n = n % 100000000; bool zero = false; if (n = 10000) if (n / 10000000) res.push_back(dicts[n / 10000000]); res.push_back(Qian); n %= 10000000; else if (raw 10000000) zero = true; if (n / 1000000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 1000000]); res.push_back(Bai); n %= 1000000; else if (raw 1000000) zero = true; if (n / 100000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 100000]); res.push_back(Shi); n %= 100000; else if (raw 100000) zero = true; if (n / 10000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 10000]); n %= 10000; res.push_back(Wan); zero = false; if (n / 1000) res.push_back(dicts[n / 1000]); res.push_back(Qian); n %= 1000; else if (raw 1000) zero = true; if (n / 100) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 100]); res.push_back(Bai); n %= 100; else if (raw 100) zero = true; if (n / 10) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 10]); res.push_back(Shi); n %= 10; else if (raw 10) zero = true; if (n % 10) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n % 10]); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; ä¼˜åŒ– #include iostream#include vector#include stringusing namespace std;int main() string nums[10] = ling, yi, er, san, si, wu, liu, qi, ba, jiu; string wei[5] = Shi, Bai, Qian, Wan, Yi; string str; cin str; int len = str.length(); int left = 0, right = len - 1; if (str[0] == -) cout Fu; left++; while (left + 4 = right) right -= 4; while (left len) bool flag = false, isPrint = false; while (left = right) if (left 0 str[left] == 0) flag = true; else if (flag == true) cout ling; flag = false; if (left 0) cout ; cout nums[str[left] - 0]; isPrint = true; if (left != right) cout wei[right - left - 1]; left++; if (isPrint == true right != len - 1) cout wei[(len - 1 - right) / 4 + 2]; right += 4; return 0; 1083 List Grades#include iostream#include string#include algorithmusing namespace std;struct node string name, num; int grade; nums[100001];bool cmp(node a, node b) return a.grade b.grade;int main() int n, left, right; cin n; for (int i = 0; i n; i++) cin nums[i].name nums[i].num nums[i].grade; cin left right; sort(nums, nums + n, cmp); bool flag = true; for (int i = 0; i n; i++) if (nums[i].grade = left nums[i].grade = right) cout nums[i].name nums[i].num endl; flag = false; if (flag) cout NONE; return 0; 1084 Broken Keyboard#include iostream#include stringusing namespace std;bool st[256];int main() string a, b; cin a b; for (int i = 0; i a.size(); i++) if (isalpha(a[i])) a[i] = tolower(a[i]); st[a[i]] = true; for (int i = 0; i b.size(); i++) if (isalpha(b[i])) b[i] = tolower(b[i]); st[b[i]] = false; for (int i = 0; i a.size(); i++) if (st[a[i]]) char t = a[i]; if (isalpha(t)) t = toupper(t); cout t; st[a[i]] = false; return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main() string s1, s2, res; cin s1 s2; for (int i = 0; i s1.size(); i++) if (s2.find(s1[i]) == string::npos res.find(toupper(s1[i])) == string::npos) res += toupper(s1[i]); cout res; return 0; 1085 Perfect Sequenceæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ #include iostream#include algorithmusing namespace std;typedef long long LL;LL nums[100001], res = 1, p;void dfs(LL l, LL r) if (res r - l + 1) return; if (nums[l] * p nums[r]) dfs(l + 1, r); dfs(l, r - 1); else res = max(res, r - l + 1); int main() int n; cin n p; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); dfs(0, n - 1); cout res; return 0; æŸ³å©¼çš„ #include iostream#include algorithmusing namespace std;typedef long long LL;LL nums[100001];int main() int n, p, res = 1; cin n p; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); for (int i = 0; i n; i++) // res = max((int)(upper_bound(nums, nums + n, nums[i] * p) - (nums + i)), res); for (int j = i + res; j n; j++) if (nums[i] * p = nums[j]) res = max(res, j - i + 1); else break; cout res; return 0; 1086 Tree Traversals Again#include iostream#include stack#include string#include vectorusing namespace std;struct node int l, r; trees[31];stackint st;vectorint in, pre, post;int build(int preL, int preR, int inL, int inR) if (preL preR) return -1; int root = in[inL], idx = preL; for (int i = preL; i = preR; i++) if (root == pre[i]) idx = i; break; int cntL = idx - preL; trees[root].l = build(preL, preL + cntL - 1, inL + 1, inL + cntL); trees[root].r = build(idx + 1, preR, inL + cntL + 1, inR); return root;void dfs(int root) if (root == -1) return; dfs(trees[root].l); dfs(trees[root].r); post.push_back(root);int main() int n, x; string ops; cin n; for (int i = 0; i 2 * n; i++) cin ops; if (ops == Push) cin x; st.push(x); in.push_back(x); else pre.push_back(st.top()); st.pop(); int root = build(0, n - 1, 0, n - 1); dfs(root); for (int i = 0; i post.size(); i++) cout post[i]; if (i post.size() - 1) cout ; return 0; æŸ³å©¼çš„ #include iostream#include stack#include string#include vectorusing namespace std;stackint st;vectorint pre, in, post, value;void postorder(int root, int start, int end) if (start end) return; int i = start; while (i end in[i] != pre[root]) i++; postorder(root + 1, start, i - 1); postorder(root + 1 + i - start, i + 1, end); post.push_back(pre[root]);int main() int n, x, key = 0; string ops; cin n; for (int i = 0; i 2 * n; i++) cin ops; if (ops == Push) cin x; value.push_back(x); pre.push_back(key); st.push(key++); else in.push_back(st.top()); st.pop(); postorder(0, 0, n - 1); for (int i = 0; i n; i++) cout value[post[i]]; if (i n - 1) cout ; return 0; 1087 All Roads Lead to Rome#include iostream#include vector#include map#include stringusing namespace std;typedef pairint, int PII;const int N = 201;const int INF = 0x3f3f3f3f;mapstring, int strToInt;string intToStr[N], start;vectorPII g[N];int d[N], haps[N], pre[N], cnt[N], happys[N], cnt2[N], n;bool visit[N];void dijkstra(int a) fill(d, d + n, INF); d[a] = 0; cnt2[a] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] d[j] mind) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first, dis = g[u][j].second; if (!visit[v]) if (d[v] d[u] + dis) d[v] = d[u] + dis; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; cnt2[v] = cnt2[u]; pre[v] = u; else if (d[v] == d[u] + dis) if (happys[v] happys[u] + haps[v]) happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; pre[v] = u; else if (happys[v] == happys[u] + haps[v]) if (cnt[v] cnt[u] + 1) cnt[v] = cnt[u] + 1; pre[v] = u; cnt2[v] += cnt2[u]; vectorint res;void dfs(int u) res.push_back(u); if (u == strToInt[start]) for (int i = res.size() - 1; i = 0; i--) cout intToStr[res[i]]; if (i 0) cout -; else dfs(pre[u]); int main() string city1, city2; int k, hap, cost; cin n k start; for (int i = 0; i n - 1; i++) cin city1 hap; strToInt[city1] = i; intToStr[i] = city1; haps[i] = hap; strToInt[start] = n - 1; intToStr[n - 1] = start; for (int i = 0; i k; i++) cin city1 city2 cost; g[strToInt[city1]].push_back(strToInt[city2], cost); g[strToInt[city2]].push_back(strToInt[city1], cost); dijkstra(strToInt[start]); cout cnt2[strToInt[ROM]] d[strToInt[ROM]] happys[strToInt[ROM]] happys[strToInt[ROM]] / cnt[strToInt[ROM]] endl; dfs(strToInt[ROM]); return 0; 1088 Rational Arithmetic#include iostream#include stringusing namespace std;typedef long long LL;LL gcd(LL a, LL b) if (b == 0) return a; return gcd(b, a % b);string convert(LL a, LL b) string res; if (b == 0) return Inf; LL tt = a; if (tt 0) res += (-; a = abs(a), b = abs(b); LL d = gcd(a, b); a /= d; b /= d; LL t = a / b; a -= t * b; if (t a) res += to_string(t) + + to_string(a) + / + to_string(b); else if(t a == 0) res += to_string(t); else if(t == 0 a) res += to_string(a) + / + to_string(b); else res += 0; if (tt 0) res += ); return res;string add(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2 + a2 * b1; b = b1 * b2; return convert(a, b);string sub(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2 - a2 * b1; b = b1 * b2; return convert(a, b);string mul(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * a2; b = b1 * b2; return convert(a, b);string div(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2; b = b1 * a2; if (b 0) a = -a, b = -b; return convert(a, b);int main() LL a1, b1, a2, b2; scanf(%lld/%lld %lld/%lld, a1, b1, a2, b2); cout convert(a1, b1) + convert(a2, b2) = add(a1, b1, a2, b2) endl; cout convert(a1, b1) - convert(a2, b2) = sub(a1, b1, a2, b2) endl; cout convert(a1, b1) * convert(a2, b2) = mul(a1, b1, a2, b2) endl; cout convert(a1, b1) / convert(a2, b2) = div(a1, b1, a2, b2) endl; return 0; 1089 Insert or Merge#include iostream#include algorithmusing namespace std;const int N = 101;int nums[N], now[N], tmp[N], tmp2[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) cin now[i]; int id = 0; for (int i = 0; i n - 1; i++) if (now[i + 1] now[i]) id = i; break; bool isInsert = true; for (int j = id + 1; j n; j++) if (nums[j] != now[j]) isInsert = false; break; if (isInsert) cout Insertion Sort endl; sort(nums, nums + id + 2); else cout Merge Sort endl; bool flag = true; int k = 1; while (flag) flag = false; for (int i = 0; i n; i++) if (nums[i] != now[i]) flag = true; k *= 2; for (int i = 0; i n / k; i++) sort(nums + i * k, nums + (i + 1) * k); sort(nums + n / k * k, nums + n); for (int i = 0; i n; i++) cout nums[i]; if (i n - 1) cout ; return 0; 1090 Highest Price in Supply Chain#include iostream#include vectorusing namespace std;vectorint g[100001];int cnt[100001], res = 0;void dfs(int n, int t) if (res t) res = t; cnt[t] = 1; else cnt[t]++; for (int i = 0; i g[n].size(); i++) dfs(g[n][i], t + 1); int main() int n, x; double p, r; cin n p r; for (int i = 0; i n; i++) cin x; if (x == -1) g[n].push_back(i); else g[x].push_back(i); dfs(n, 0); for (int i = 0; i res - 1; i++) p *= (100 + r) / 100.0; printf(%.2f %d, p, cnt[res]); return 0; 1091 Acute Stroke#include iostream#include queueusing namespace std;int g[61][1287][129], m, n, l, t;bool v[61][1287][129];struct node int i, j, k;;int x[6] = 1, -1, 0, 0, 0, 0;int y[8] = 0, 0, 1, -1, 0, 0;int z[8] = 0, 0, 0, 0, 1, -1;int bfs(int i, int j, int k) v[i][j][k] = true; int cnt = 1; queuenode q; q.push(i, j, k); while (!q.empty()) node u = q.front(); q.pop(); i = u.i, j = u.j, k = u.k; for (int id = 0; id 6; id++) int a = i + x[id], b = j + y[id], c = k + z[id]; if (a = 0 a l b = 0 b m c = 0 c n !v[a][b][c] g[a][b][c] == 1) cnt++; v[a][b][c] = true; q.push(a, b, c); if (cnt t) return 0; else return cnt;int main() cin m n l t; for (int i = 0; i l; i++) for (int j = 0; j m; j++) for (int k = 0; k n; k++) scanf(%d, g[i][j][k]); int res = 0; for (int i = 0; i l; i++) for (int j = 0; j m; j++) for (int k = 0; k n; k++) if (!v[i][j][k] g[i][j][k]) res += bfs(i, j, k); cout res; return 0; 1092 To Buy or Not to Buy#include iostream#include stringusing namespace std;int nums[256];int main() string a, b; cin a b; for (int i = 0; i a.size(); i++) nums[a[i]]++; bool flag = true; int cnt = 0; for (int i = 0; i b.size(); i++) if (nums[b[i]] = 0) flag = false; cnt++; nums[b[i]]--; if (flag) cout Yes a.size() - b.size(); else cout No cnt; return 0; 1093 Count PATâ€™s#include iostream#include stringusing namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() string str; cin str; int res = 0; for (int i = 1; i str.size(); i++) p[i] = p[i - 1]; if (str[i - 1] == P) p[i]++; for (int i = str.size() - 1; i = 0; i--) t[i] = t[i + 1]; if (str[i + 1] == T) t[i]++; for (int i = 1; i str.size() - 1; i++) if (str[i] == A) res = (res + p[i] * t[i] % MOD) % MOD; cout res; return 0; æŸ³å©¼çš„ #include iostream#include stringusing namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() string s; cin s; int res = 0, len = s.size(), p = 0, t = 0; for (int i = 0; i len; i++) if (s[i] == T) t++; for (int i = 0; i len; i++) if (s[i] == P) p++; if (s[i] == T) t--; if (s[i] == A) res = (res + p * t % MOD) % MOD; cout res; return 0; 1094 The Largest Generation#include iostream#include vector#include queueusing namespace std;vectorint trees[101];int res, cntn;void bfs(int u) queueint q; q.push(u); int depth = 1; while (!q.empty()) int cnt = q.size(); for (int i = 0; i cnt; i++) u = q.front(); q.pop(); for (int j = 0; j trees[u].size(); j++) q.push(trees[u][j]); if (cntn cnt) res = depth; cntn = cnt; depth++; return;int main() int n, m, id, k, x; cin n m; for (int i = 0; i m; i++) cin id k; for (int j = 0; j k; j++) cin x; trees[id].push_back(x); bfs(1); cout cntn res; return 0; 1095 Cars on Campus#include iostream#include string#include vector#include map#include algorithmusing namespace std;struct node int time; string op;;bool cmp(node a, node b) return a.time b.time;mapstring, int strToInt;mapint, string intToStr;vectornode nums[10001], finall;int times[86401];int main() string a, op; int n, k, h, m, s, id = 1; cin n k; for (int i = 0; i n; i++) cin a; if (!strToInt[a]) strToInt[a] = id; intToStr[id++] = a; scanf(%d:%d:%d, h, m, s); cin op; int time = h * 60 * 60 + m * 60 + s; nums[strToInt[a]].push_back(time, op); int total[id + 1]; for (int i = 1; i id; i++) sort(nums[i].begin(), nums[i].end(), cmp); for (int j = 0; j nums[i].size() - 1; j++) if (nums[i][j].op == in nums[i][j + 1].op == out) finall.push_back(nums[i][j]); finall.push_back(nums[i][j + 1]); total[i] += nums[i][j + 1].time - nums[i][j].time; sort(finall.begin(), finall.end(), cmp); int t = 0; for (int i = 0; i = 86400; i++) if (i != 0) times[i] = times[i - 1]; while (finall[t].time == i) if (finall[t].op == in) times[i]++; else times[i]--; t++; if (t == finall.size()) break; for (int i = 0; i k; i++) scanf(%d:%d:%d, h, m, s); int time = h * 60 * 60 + m * 60 + s; cout times[time] endl; int maxTime = 0; vectorstring res; for (int i = 0; i id; i++) if (maxTime total[i]) maxTime = total[i]; res.clear(); res.push_back(intToStr[i]); else if (maxTime == total[i]) res.push_back(intToStr[i]); for (auto it: res) cout it ; h = maxTime / 3600, m = maxTime % 3600 / 60, s = maxTime % 60; printf(%02d:%02d:%02d, h, m, s); return 0; 1096 Consecutive Factors#include iostream#include cmathusing namespace std;typedef long long LL;int main() LL n, t; cin n; int l = 0, j = 0, res = 0; for (int i = 2; i sqrt(n) + 1; i++) t = 1; for (j = i; j sqrt(n) + 1; j++) t *= j; if (n % t != 0) break; if (j - i l) l = j - i; res = i; if (l == 0) cout 1 n; else cout l endl; for (int k = res; k l + res; k++) cout k; if (k l + res - 1) cout *; return 0; 1097 Deduplication on a Linked List#include iostream#include vectorusing namespace std;const int N = 100001;struct node int add, key, nex; nums[N];bool st[N];int main() int start, n, add, key, nex; cin start n; for (int i = 0; i n; i++) cin add key nex; nums[add] = add, key, nex; vectornode list, red; while (start != -1) if (!st[abs(nums[start].key)]) list.push_back(nums[start]); st[abs(nums[start].key)] = true; else red.push_back(nums[start]); start = nums[start].nex; if (!list.empty()) for (int i = 0; i list.size() - 1; i++) printf(%05d %d %05d , list[i].add, list[i].key, list[i + 1].add); printf(%05d %d -1 , list[list.size() - 1].add, list[list.size() - 1].key); if (!red.empty()) for (int i = 0; i red.size() - 1; i++) printf(%05d %d %05d , red[i].add, red[i].key, red[i + 1].add); printf(%05d %d -1 , red[red.size() - 1].add, red[red.size() - 1].key); return 0; 1098 Insertion or Heap Sorté”™è¯¯ç­”æ¡ˆ #include iostream#include algorithmusing namespace std;const int N = 101;int a[N], b[N];int main() int n; cin n; for (int i = 0; i n; i++) cin a[i]; for (int i = 0; i n; i++) cin b[i]; int id = 0; for (int i = 1; i n; i++) if (b[i] = b[i - 1]) id = i; else break; bool isInsert = true; for (int j = id + 1; j n; j++) if (a[j] != b[j]) isInsert = false; break; if (isInsert) cout Insertion Sort endl; sort(b, b + id + 2); else cout Heap Sort endl; int i = 0, t = b[0]; while(2 * i + 1 n) if (b[2 * i + 1] b[2 * i + 2]) swap(b[2 * i + 1], b[2 * i + 2]); if (b[i] b[2 * i + 2]) swap(b[i], b[2 * i + 2]); i = 2 * i + 2; else if (b[i] b[2 * i + 1]) swap(b[i], b[2 * i + 1]); i = 2 * i + 1; else break; for (int i = 0; i n; i++) cout b[i]; if (i n - 1) cout ; return 0; æŸ³å©¼çš„ #include iostream#include vector#include algorithmusing namespace std;void down(vectorint b, int low, int high) int i = 1, j = i * 2; while (j = high) if (j + 1 = high b[j] b[j + 1]) j = j + 1; if (b[i] = b[j]) break; swap(b[i], b[j]); i = j; j = i * 2; int main() int n, p = 2; cin n; vectorint a(n + 1), b(n + 1); for (int i = 1; i = n; i++) cin a[i]; for (int i = 1; i = n; i++) cin b[i]; while (p = n b[p - 1] = b[p]) p++; int idx = p; while (p = n a[p] == b[p]) p++; if (p == n + 1) cout Insertion Sort ; sort(b.begin() + 1, b.begin() + idx + 1); else cout Heap Sort ; p = n; while(p 2 b[p] = b[1]) p--; swap(b[1], b[p]); down(b, 1, p - 1); for (int i = 1; i = n; i++) cout b[i]; if (i n) cout ; return 0; 1099 Build A Binary Search Tree#include iostream#include vector#include queue#include algorithmusing namespace std;const int N = 101;struct node int data, l, r; a[N];int b[N], cnt;vectorint res;void dfs(int root) if (root == -1) return; dfs(a[root].l); a[root].data = b[cnt++]; dfs(a[root].r);void bfs(int root) queueint q; q.push(root); while (!q.empty()) root = q.front(); q.pop(); res.push_back(a[root].data); if (a[root].l != -1) q.push(a[root].l); if (a[root].r != -1) q.push(a[root].r); int main() int n; cin n; for (int i = 0; i n; i++) cin a[i].l a[i].r; for (int i = 0; i n; i++) cin b[i]; sort(b, b + n); dfs(0); bfs(0); for (int i = 0; i n; i++) cout res[i]; if (i n - 1) cout ; return 0; 1100 Mars Numbers#include iostream#include stringusing namespace std;int main() int n; string x; string shi[12] = tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou; string ge[12] = jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec; cin n; getchar(); for (int i = 0; i n; i++) getline(cin, x); if (x == 0) cout tret endl; else if (isdigit(x[0])) int t = stoi(x); int a = t / 13; int b = t % 13; if (a b) cout shi[a - 1] ge[b - 1] endl; else if (a) cout shi[a - 1] endl; else if (b) cout ge[b - 1] endl; else if (x == tret) cout 0 endl; else if (x.size() 3) int a = 0; for (int i = 0; i 12; i++) if (x.substr(0, 3) == shi[i]) a += (i + 1) * 13; if (x.substr(4, 3) == ge[i]) a += i + 1; cout a endl; else for (int i = 0; i 12; i++) if (x == shi[i]) cout (i + 1) * 13 endl; if (x == ge[i]) cout i + 1 endl; return 0; 1101 Quick Sort#include iostream#include vector#include algorithmusing namespace std;const int N = 100001;const int INF = 0x3f3f3f3f;int nums[N], minr[N], maxl[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; fill(minr, minr + n, INF); for (int i = 1; i n; i++) maxl[i] = max(maxl[i - 1], nums[i - 1]); for (int i = n - 2; i = 0; i--) minr[i] = min(minr[i + 1], nums[i + 1]); vectorint res; for (int i = 0; i n; i++) if (nums[i] = maxl[i] nums[i] = minr[i]) res.push_back(nums[i]); cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; cout endl; return 0; æŸ³å©¼çš„ #include iostream#include vector#include algorithmusing namespace std;int v[100001];int main() int n, max = 0, cnt = 0; cin n; vectorint a(n), b(n); for (int i = 0; i n; i++) cin a[i]; b[i] = a[i]; sort(a.begin(), a.end()); for (int i = 0; i n; i++) if (a[i] == b[i] b[i] max) v[cnt++] = b[i]; if (b[i] max) max = b[i]; cout cnt endl; for (int i = 0; i cnt; i++) cout v[i]; if (i cnt - 1) cout ; cout endl; return 0; 1102 Invert a Binary Tree#include iostream#include vector#include queueusing namespace std;struct node int l, r; trees[11];bool st[11];vectorint level, in;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); level.push_back(u); q.pop(); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); void dfs(int u) if (u == -1) return; dfs(trees[u].l); in.push_back(u); dfs(trees[u].r);int main() int n, root; char a, b; cin n; for (int i = 0; i n; i++) cin a b; if (isdigit(a)) trees[i].r = a - 0; st[a - 0] = true; else trees[i].r = -1; if (isdigit(b)) trees[i].l = b - 0; st[b - 0] = true; else trees[i].l = -1; for (int i = 0; i n; i++) if (!st[i]) root = i; bfs(root); dfs(root); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; else cout endl; for (int i = 0; i n; i++) cout in[i]; if (i n - 1) cout ; return 0; 1103 Integer Factorizationdfs #include iostream#include vector#include cmathusing namespace std;vectorint res, tmp, v;int n, k, p, t, m, sumt, mint = -1;void dfs(int idx, int a) if (a == k t == n) if (sumt mint) mint = sumt; res = tmp; return; if (a = k || t = n) return; for (int i = idx; i = 0; i--) t += v[i]; sumt += i; tmp.push_back(i + 1); dfs(i, a + 1); tmp.pop_back(); sumt -= i; t -= v[i]; int main() cin n k p; for (int i = 1; i = n; i++) int b = pow(i, p); v.push_back(b); if (b n) break; dfs(v.size() - 1, 0); if (mint == -1) cout Impossible; else cout n = ; for (int i = 0; i res.size(); i++) cout res[i] ^ p; if (i res.size() - 1) cout + ; return 0; 1104 Sum of Number Segmentsç²¾åº¦é—®é¢˜ï¼ˆå‘ï¼‰ #include iostreamusing namespace std;const int N = 100001;double nums[N];int n;int main() cin n; for (int i = 0; i n; i++) cin nums[i]; long long res = 0; for (int i = 0; i n; i++) res += (long long)(nums[i] * 1000) * i * (n - i + 1); printf(%.2f, res / 1000.0); return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int main() int n; double tmp; long long res; cin n; for (int i = 1; i = n; i++) cin tmp; res += (long long)(tmp * 1000) * i * (n - i + 1); printf(%.2f, res / 1000.0); return 0; 1105 Spiral Matrix#include iostream#include algorithm#include cmathusing namespace std;int nums[10001], id, res[100][100];int main() int t, n, m, mi = 10001; cin t; for (int i = 0; i t; i++) cin nums[i]; sort(nums, nums + t, greaterint()); for (int i = 1; i * i = t; i++) if (t % i == 0) n = i; m = t / n; int l = 0, r = n - 1, u = 0, d = m - 1; while (l = r u = d) for (int i = l; i = r; i++) res[u][i] = nums[id++]; u++; if (u d) break; for (int i = u; i = d; i++) res[i][r] = nums[id++]; r--; if (r l) break; for (int i = r; i = l; i--) res[d][i] = nums[id++]; d--; if (u d) break; for (int i = d; i = u; i--) res[i][l] = nums[id++]; l++; if (l r) break; for (int i = 0; i m; i++) for (int j = 0; j n; j++) cout res[i][j]; if (j n - 1) cout ; cout endl; return 0; 1106 Lowest Price in Supply Chain#include iostream#include vector#include queue#include cmathusing namespace std;vectorint trees[100001];int depth = 1, cnt = 0;void bfs(int u) queueint q; q.push(u); bool flag = false; while (!q.empty()) int size = q.size(); cnt = 0; for (int i = 0; i size; i++) u = q.front(); q.pop(); if (trees[u].empty()) flag = true; cnt++; for (int i = 0; i trees[u].size(); i++) q.push(trees[u][i]); if (flag) return; depth++; int main() int n, k, x; double p, r; cin n p r; for (int i = 0; i n; i++) cin k; for (int j = 0; j k; j++) cin x; trees[i].push_back(x); bfs(0); printf(%.4f %d, p * pow(1 + r / 100, depth - 1), cnt); return 0; 1107 Social Clusters#include iostream#include stringusing namespace std;int main() int n, cnt = 0; string x; double sum, t; cin n; for (int i = 0; i n; i++) cin x; try t = stod(x); if (t 1000 || t -1000) cout ERROR: x is not a legal number endl; continue; int j = 0; bool flag = true; while (j x.size() x[j] != .) j++; if (j != x.size() j + 3 x.size()) cout ERROR: x is not a legal number endl; continue; if (flag) cnt++; sum += t; catch(exception) cout ERROR: x is not a legal number endl; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; 1108 Finding Average#include iostream#include stringusing namespace std;int main() int n, cnt = 0; string x; double sum, t; cin n; for (int i = 0; i n; i++) cin x; try t = stod(x); if (t 1000 || t -1000) cout ERROR: x is not a legal number endl; continue; int j = 0; bool flag = true; while (j x.size() x[j] != .) j++; if (j != x.size() j + 3 x.size()) cout ERROR: x is not a legal number endl; continue; if (flag) cnt++; sum += t; // cout t sum cnt endl; catch(exception) cout ERROR: x is not a legal number endl; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; æŸ³å©¼çš„ #include iostream#include cstringusing namespace std;int main() int n, cnt = 0; char a[50], b[50]; double t, sum; cin n; for (int i = 0; i n; i++) cin a; sscanf(a, %lf, t); sprintf(b, %.2f, t); bool flag = false; for (int j = 0; j strlen(a); j++) if (a[j] != b[j]) flag = true; if (flag || t -1000 || t 1000) cout ERROR: a is not a legal number endl; continue; else sum += t; cnt++; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; 1109 Group Photo#include iostream#include string#include map#include algorithmusing namespace std;typedef pairstring, int PII;PII nums[10001];bool cmp(PII a, PII b) if (a.second != b.second) return a.second b.second; return a.first b.first;void fun(int start, int n) if (n % 2 == 0) for (int i = n - 1; i = 1; i-=2) cout nums[start + i].first ; for (int i = 0; i n; i+=2) cout nums[start + i].first; if (i + 2 == n) cout endl; else cout ; else for (int i = n - 2; i = 1; i-=2) cout nums[start + i].first ; for (int i = 0; i n; i+=2) cout nums[start + i].first; if (i + 1 == n) cout endl; else cout ; int main() int n, k, height; string name; cin n k; for (int i = 0; i n; i++) cin name height; nums[i] = name, height; sort(nums, nums + n, cmp); int num = n / k; int last = n - num * k + num; fun(0, last); for (int j = 1; j k; j++) fun(last + (j - 1) * num, num); return 0; 1110 Complete Binary Treebfs #include iostream#include string#include queueusing namespace std;struct node int l = -1, r = -1; nums[100];bool st[100], isCBT = true, flag;int bfs(int u) queueint q; q.push(u); int cnt = 1, a = 0; while(!q.empty()) u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (flag) isCBT = false; else flag = true; if (nums[u].r != -1) q.push(nums[u].r); if (flag) isCBT = false; else flag = true; return u;int main() int n, root = 0; string l, r; cin n; for (int i = 0; i n; i++) cin l r; if (l != -) nums[i].l = stoi(l); st[stoi(l)] = true; if (r != -) nums[i].r = stoi(r); st[stoi(r)] = true; for (int i = 0; i n; i++) if (!st[i]) root = i; int last = bfs(root); if (!isCBT) cout NO root; else cout YES last; return 0; dfs #include iostream#include string#include queueusing namespace std;struct node int l = -1, r = -1; nums[100];bool st[100];int maxn = -1, last;void dfs(int root, int index) if (maxn index) maxn = index; last = root; if (nums[root].l != -1) dfs(nums[root].l, index * 2); if (nums[root].r != -1) dfs(nums[root].r, index * 2 + 1);int main() int n, root = 0; string l, r; cin n; for (int i = 0; i n; i++) cin l r; if (l != -) nums[i].l = stoi(l); st[stoi(l)] = true; if (r != -) nums[i].r = stoi(r); st[stoi(r)] = true; for (int i = 0; i n; i++) if (!st[i]) root = i; dfs(root, 1); if (maxn != n) cout NO root; else cout YES last; return 0; 1111 Online Mapdijkstra #include iostream#include vectorusing namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node int v, dist, time;;vectornode g[N];int d[N], cost1[N], cost2[N], cnt[N], pre[N], start, dest, n;bool visit[N];void dijkstra1(int a) fill(d, d + N, INF); d[a] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) mind = d[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (d[u] + dist d[v]) d[v] = d[u] + dist; cost1[v] = cost1[u] + time; pre[v] = u; else if (d[u] + dist == d[v]) if (cost1[v] cost1[u] + time) pre[v] = u; cost1[v] = cost1[u] + time; vectorint res1;void dfs1(int x) if (x != start) res1.push_back(x); dfs1(pre[x]); else res1.push_back(start);void dijkstra2(int a) fill(cost2, cost2 + N, INF); fill(visit, visit + N, false); cost2[a] = 0; cnt[a] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind cost2[j]) mind = cost2[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (cost2[u] + time cost2[v]) cost2[v] = cost2[u] + time; cnt[v] = cnt[u] + 1; pre[v] = u; else if (cost2[u] + time == cost2[v]) if (cnt[v] cnt[u] + 1) pre[v] = u; cnt[v] = cnt[u] + 1; vectorint res2;void dfs2(int x) if (x != start) res2.push_back(x); dfs2(pre[x]); else res2.push_back(start);int main() int m, v1, v2, one, len, time; cin n m; for (int i = 0; i m; i++) cin v1 v2 one len time; g[v1].push_back(v2, len, time); if (!one) g[v2].push_back(v1, len, time); cin start dest; dijkstra1(start); dfs1(dest); dijkstra2(start); dfs2(dest); if (res1 == res2) cout Distance = d[dest] ; Time = cost2[dest] : ; for (int i = res1.size() - 1; i = 0; i--) cout res1[i]; if (i 0) cout - ; else cout Distance = d[dest] : ; for (int i = res1.size() - 1; i = 0; i--) cout res1[i]; if (i 0) cout - ; else cout endl; cout Time = cost2[dest] : ; for (int i = res2.size() - 1; i = 0; i--) cout res2[i]; if (i 0) cout - ; return 0; 1112 Stucked Keyboard#include iostream#include stringusing namespace std;int st[257];int main() int k, i = 0; string a; cin k a; for (; i = a.size() - k; i++) char t = a[i]; bool flag = false; for (int j = i + 1; j i + k; j++) if (a[j] != t) flag = true; break; if (flag) st[t] = 1; else i += k - 1; for (; i a.size(); i++) st[a[i]] = 1; for (int i = 0; i a.size(); i++) if (!st[a[i]]) cout a[i]; st[a[i]] = 2; cout endl; for (int i = 0; i a.size(); i++) if (st[a[i]] == 1) cout a[i]; else if (st[a[i]] == 2) cout a[i]; i += k - 1; return 0; 1113 Integer Set Partition#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); long long res = 0; for (int i = 0; i n / 2; i++) res += nums[n - i - 1] - nums[i]; if (n % 2 == 0) cout 0 res; else res += nums[n / 2]; cout 1 res; return 0; 1114 Family Property#include iostream#include vector#include set#include algorithmusing namespace std;const int N = 10001;struct node int fa, mo, set, area; vectorint childs; nums[N];struct family int id, cnt; double set, area;;bool cmp(family a, family b) if (a.area != b.area) return a.area b.area; return a.id b.id;bool visit[N];int fa[N], cnt[N];setint ids, ids2, resid;int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];void union1(int a, int b) ids.insert(b); int fa1 = find(a); int fb = find(b); if (fa1 != fb) if (fa1 fb) fa[fb] = fa1; else fa[fa1] = fb; int main() int n, id, k, child; for (int i = 1; i N; i++) fa[i] = i; cin n; for (int i = 0; i n; i++) cin id; ids.insert(id); ids2.insert(id); cin nums[id].fa nums[id].mo k; if (nums[id].fa != -1) union1(id, nums[id].fa); if (nums[id].mo != -1) union1(id, nums[id].mo); for (int i = 0; i k; i++) cin child; nums[id].childs.push_back(child); union1(id, child); cin nums[id].set nums[id].area; for (auto id: ids) cnt[find(id)]++; resid.insert(find(id)); family tmp[N]; for (int i = 0; i N; i++) if (cnt[i]) tmp[i] = i, cnt[i], 0, 0; for (auto id: ids2) tmp[find(id)].set += nums[id].set; tmp[find(id)].area += nums[id].area; vectorfamily res; for (auto id: resid) tmp[id].set /= tmp[id].cnt; tmp[id].area /= tmp[id].cnt; res.push_back(tmp[id]); sort(res.begin(), res.end(), cmp); cout res.size() endl; for (int i = 0; i res.size(); i++) printf(%04d %d %.3f %.3f , res[i].id, res[i].cnt, res[i].set, res[i].area); return 0; 1115 Counting Nodes in a Binary Search Tree#include iostream#include queueusing namespace std;struct node int data, l = -1, r = -1; nums[1001];int idx = 0, last = 0, llast = 0;void insert(int x, int root) if (x = nums[root].data) if (nums[root].l == -1) nums[root].l = idx; nums[idx++].data = x; else insert(x, nums[root].l); else if (nums[root].r == -1) nums[root].r = idx; nums[idx++].data = x; else insert(x, nums[root].r); void bfs(int u) queueint q; q.push(u); while (!q.empty()) int size = q.size(); llast = last; last = size; for (int i = 0; i size; i++) u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (nums[u].r != -1) q.push(nums[u].r); int main() int n, root, x; cin n root; nums[idx++].data = root; for (int i = 1; i n; i++) cin x; insert(x, 0); bfs(0); cout last + llast = last + llast; return 0; 1116 Come on! Letâ€™s C#include iostream#include mapusing namespace std;const int N = 10001;bool st[N], visit[N];mapint, int nums;int main() for (int i = 2; i N; i++) if (!st[i]) for (int j = i * 2; j N; j += i) st[j] = true; int n, x; cin n; for (int i = 1; i = n; i++) cin x; nums[x] = i; cin n; for (int i = 0; i n; i++) cin x; if (nums[x] == 0) printf(%04d: Are you kidding? , x); else if (visit[x]) printf(%04d: Checked , x); else if (nums[x] == 1) printf(%04d: Mystery Award , x); visit[x] = true; else if (!st[nums[x]]) printf(%04d: Minion , x); visit[x] = true; else printf(%04d: Chocolate , x); visit[x] = true; return 0; 1117 Eddington Number#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n, greaterint()); int res = 0; for (int i = 1; i = n; i++) if (i = nums[i - 1]) break; else res = i; cout res; return 0; 1118 Birds in Forest#include iostream#include setusing namespace std;const int N = 10001;int fa[N], cnt[N], maxb;setint birds;int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];void union1(int a, int b) int faa = find(a); int fbb = find(b); if (faa != fbb) fa[fbb] = faa; int main() for (int i = 1; i N; i++) fa[i] = i; int n, k, x, y; cin n; for (int i = 0; i n; i++) cin k x; maxb = max(maxb, x); for (int j = 1; j k; j++) cin y; maxb = max(maxb, y); union1(x, y); int mtree = 0; for (int i = 1; i = maxb; i++) if (find(i) == i) mtree++; cout mtree maxb endl; cin k; for (int i = 0; i k; i++) cin x y; if (fa[x] != fa[y]) cout No endl; else cout Yes endl; return 0; 1119 Pre- and Post-order Traversals#include iostream#include vectorusing namespace std;const int N = 31;int pre[N], post[N];vectorint in;bool flag = true;void getIn(int preleft, int preright, int postleft, int postright) if (preleft == preright) in.push_back(pre[preleft]); return; if (pre[preleft] == post[postright]) int i = preleft + 1; while (i = preright pre[i] != post[postright - 1]) i++; if (i - preleft 1) getIn(preleft + 1, i - 1, postleft, postleft + (i - preleft - 1) - 1); else flag = false; in.push_back(post[postright]); getIn(i, preright, postleft + (i - preleft - 1), postright - 1); int main() int n; cin n; for (int i = 0; i n; i++) cin pre[i]; for (int i = 0; i n; i++) cin post[i]; getIn(0, n - 1, 0, n - 1); if (flag) cout Yes endl; else cout No endl; for (int i = 0; i in.size(); i++) cout in[i]; if (i in.size() - 1) cout ; else cout endl; return 0; 1120 Friend Numbers#include iostream#include vectorusing namespace std;int nums[40];int main() int n, x; cin n; for (int i = 0; i n; i++) cin x; int t = 0; while (x 0) t += x % 10; x /= 10; nums[t]++; vectorint res; for (int i = 0; i 40; i++) if (nums[i]) res.push_back(i); cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1121 Damn Single#include iostream#include vector#include algorithmusing namespace std;const int N = 100001;int g[N], tmp[N];int main() fill(g, g + N, -1); fill(tmp, tmp + N, -1); int n, a, b, m, c; cin n; for (int i = 0; i n; i++) cin a b; g[a] = b; g[b] = a; cin m; vectorint tmp1, res; for (int i = 0; i m; i++) cin c; if (g[c] == -1) res.push_back(c); else if (tmp[g[c]] == -1) tmp[g[c]] = 1; tmp1.push_back(c); for (auto i: tmp1) if (tmp[i] == -1) res.push_back(i); sort(res.begin(), res.end()); cout res.size() endl; for (int i = 0; i res.size(); i++) printf(%05d, res[i]); if (i res.size() - 1) cout ; return 0; 1122 Hamiltonian Cycle#include iostream#include vectorusing namespace std;int n, g[201][201];bool visit[201];bool check(int q) bool flag = true; if (q != n + 1) flag = false; fill(visit, visit + 201, false); int x, last, start; cin last; start = last; visit[start] = true; for (int i = 1; i q; i++) cin x; if (!g[last][x]) flag = false; visit[x] = true; last = x; if (start != last) flag = false; for (int i = 1; i = n; i++) if (!visit[i]) flag = false; return flag;int main() int m, a, b, k, q; cin n m; for (int i = 0; i m; i++) cin a b; g[a][b] = 1; g[b][a] = 1; cin k; for (int i = 0; i k; i++) cin q; if (check(q)) cout YES endl; else cout NO endl; return 0; æŸ³å©¼çš„ #include iostream#include vector#include setusing namespace std;int main() int n, m, cnt, k, a[201][201] = 0; cin n m; for (int i = 0; i m; i++) int t1, t2; cin t1 t2; a[t1][t2] = a[t2][t1] = 1; cin cnt; while (cnt--) cin k; vectorint v(k); setint s; int flag1 = 1, flag2 = 1; for (int i = 0; i k; i++) cin v[i]; s.insert(v[i]); if (s.size() != n || k - 1 != n || v[0] != v[k - 1]) flag1 = 0; for (int i = 0; i k - 1; i++) if (a[v[i]][v[i+1]] == 0) flag2 = 0; printf(%s, flag1 flag2 ? YES : NO ); return 0; 1123 Is It a Complete AVL Tree#include iostream#include queueusing namespace std;struct node int val; node *left, *right;;node* rotateLeft(node* root) node *t = root-right; root-right = t-left; t-left = root; return t;node* rotateRight(node* root) node *t = root-left; root-left = t-right; t-right = root; return t;node* rotateLeftRight(node* root) root-left = rotateLeft(root-left); return rotateRight(root);node* rotateRightLeft(node* root) root-right = rotateRight(root-right); return rotateLeft(root);int getHeight(node* root) if (root == NULL) return 0; return max(getHeight(root-left), getHeight(root-right)) + 1;node* insert(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-left = NULL; root-right = NULL; else if (val root-val) root-left = insert(root-left, val); if (getHeight(root-left) - getHeight(root-right) == 2) root = val root-left-val ? rotateRight(root) : rotateLeftRight(root); else root-right = insert(root-right, val); if (getHeight(root-right) - getHeight(root-left) == 2) root = val root-right-val ? rotateLeft(root) : rotateRightLeft(root); return root;vectorint res;bool bfs(node* u) queuenode* q; q.push(u); int t = 1; bool flag1 = true, flag2 = true; while (!q.empty()) u = q.front(); q.pop(); if (u == NULL) flag1 = false; else if (!flag1) flag2 = false; res.push_back(u-val); q.push(u-left); q.push(u-right); return flag2;int main() int n, val; cin n; node * root = NULL; for (int i = 0; i n; i++) cin val; root = insert(root, val); int flag = bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; if (flag) cout YES; else cout NO; return 0; 1124 Raffle for Weibo Followers#include iostream#include string#include map#include vectorusing namespace std;string nums[1001];mapstring, bool st;int main() int m, n, s; cin m n s; for (int i = 1; i = m; i++) cin nums[i]; bool flag = false; for (int i = s; i = m;) if (!st[nums[i]]) flag = true; st[nums[i]] = true; cout nums[i] endl; i += n; else i++; if (!flag) cout Keep going...; return 0; 1125 Chain the Ropes#include iostream#include algorithmusing namespace std;int nums[10001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); double res = nums[0]; for (int i = 1; i n; i++) res = (res + nums[i]) / 2; cout (int)res; return 0; 1126 Eulerian Path#include iostreamusing namespace std;const int N = 501;int degree[N], g[N][N], n;bool visit[N];void dfs(int u) visit[u] = true; for (int i = 1; i = n; i++) if (!visit[i] g[u][i]) dfs(i); int main() int m, a, b; cin n m; for (int i = 0; i m; i++) cin a b; degree[a]++; degree[b]++; g[a][b] = g[b][a] = 1; int odd = 0; for (int i = 1; i = n; i++) if (degree[i] % 2) odd++; cout degree[i]; if (i n) cout ; else cout endl; dfs(a); for (int i = 1; i = n; i++) if (!visit[i]) cout Non-Eulerian; return 0; if (odd == 0) cout Eulerian; else if (odd == 2) cout Semi-Eulerian; else cout Non-Eulerian; return 0; 1127 ZigZagging on a Tree#include iostream#include vector#include queueusing namespace std;const int N = 31;struct node int l, r; trees[N];int in[N], post[N], n;int build(int leftIn, int rightIn, int leftPost, int rightPost) if (leftIn rightIn) return -1; int root = post[rightPost], id = leftIn; for (int i = leftIn; i = rightIn; i++) if (in[i] == root) id = i; int leftCnt = id - leftIn; trees[root].l = build(leftIn, id - 1,leftPost, leftPost + leftCnt - 1); trees[root].r = build(id + 1, rightIn, leftPost + leftCnt, rightPost - 1); return root;vectorint res;void bfs(int u) queueint q; q.push(u); int depth = 1; while (!q.empty()) int size = q.size(); vectorint tmp; for (int i = 0; i size; i++) u = q.front(); q.pop(); tmp.push_back(u); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (depth % 2) for (int i = tmp.size() - 1; i = 0; i--) res.push_back(tmp[i]); else for (int i = 0; i tmp.size(); i++) res.push_back(tmp[i]); depth += 1; int main() cin n; for (int i = 0; i n; i++) cin in[i]; for (int i = 0; i n; i++) cin post[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1128 N Queens Puzzle#include iostream#include cstringusing namespace std;const int N = 1001;bool de[2*N], inde[2*N], row[N];int main() int n, k, x; cin n; for (int i = 0; i n; i++) cin k; bool flag = true; memset(de, false, sizeof(de)); memset(inde, false, sizeof(inde)); memset(row, false, sizeof(row)); for (int j = 1; j = k; j++) cin x; if (de[x+j] || inde[-x+j+k] || row[x])flag = false; else de[x+j] = inde[-x+j+k] = row[x] = true; if (flag) cout YES endl; else cout NO endl; 1129 Recommendation Systemæš´åŠ›ï¼ˆè¶…æ—¶ï¼‰ #include iostream#include map#include algorithmusing namespace std;mapint, int nums;bool cmp(pairint, int a, pairint, int b) if (a.second != b.second) return a.second b.second; return a.first b.first;int main() int n, k, x; cin n k x; nums[x]++; for (int i = 1; i n; i++) cin x; vectorpairint, int t(nums.begin(), nums.end()); sort(t.begin(), t.end(), cmp); cout x :; for (int i = 0; i min(k, (int)t.size()); i++) cout t[i].first; cout endl; nums[x]++; return 0; æŸ³å©¼çš„ #include iostream#include setusing namespace std;int nums[50001];struct node int num, val; bool operator (const node a) const if (val != a.val) return val a.val; return num a.num; ;int main() int n, k, x; cin n k x; nums[x]++; setnode st; st.insert(x, nums[x]); for (int i = 1; i n; i++) cin x; cout x :; int j = 0; for (auto it = st.begin(); j k it != st.end(); it++) cout it-num; j++; cout endl; auto t = st.find(x, nums[x]); if (t != st.end()) st.erase(t); nums[x]++; st.insert(x, nums[x]); return 0; 1130 Infix Expression#include iostream#include stringusing namespace std;struct node string x; int l, r; trees[21];bool st[21];string dfs(int u) if (trees[u].l == -1 trees[u].r == -1) return trees[u].x; if (trees[u].l == -1 trees[u].r != -1) return ( + trees[u].x + dfs(trees[u].r) + ); if (trees[u].l != -1 trees[u].r != -1) return ( + dfs(trees[u].l) + trees[u].x + dfs(trees[u].r) + );int main() int n, l, r, root; string x; cin n; for (int i = 1; i = n; i++) cin x l r; trees[i] = x, l, r; st[l] = st[r] = true; for (int i = 1; i = n; i++) if (!st[i]) root = i; string res = dfs(root); if (res[0] == () res = res.substr(1, res.size() - 2); cout res; return 0; 1131 Subway Map#include iostream#include vector#include unordered_mapusing namespace std;const int N = 10001;unordered_mapint, int line;vectorint g[N], tmp, res;int dest, mind, mint, pre, pret;bool visit[N];int cnt() int cnt = -1, pre = 0; for (int i = 1; i tmp.size(); i++) if (line[tmp[i - 1] * 10000 + tmp[i]] != pre) cnt++; pre = line[tmp[i - 1] * 10000 + tmp[i]]; return cnt;void dfs(int u, int d) if (u == dest (mind d || mind == d mint cnt())) mind = d; mint = cnt(); res = tmp; if (u == dest) return; for (int i = 0; i g[u].size(); i++) if (!visit[g[u][i]]) visit[g[u][i]] = true; tmp.push_back(g[u][i]); dfs(g[u][i], d + 1); tmp.pop_back(); visit[g[u][i]] = false; int main() int n, k, x, y; cin n; for (int i = 1; i = n; i++) cin k x; for (int j = 1; j k; j++) cin y; g[x].push_back(y); g[y].push_back(x); line[x * 10000 + y] = line[y * 10000 + x] = i; x = y; cin n; for (int i = 0; i n; i++) cin x dest; mind = 0x3f3f3f3f, mint = 0x3f3f3f3f, pre = 0, pret = x; tmp.clear(); tmp.push_back(x); visit[x] = true; dfs(x, 0); visit[x] = false; cout mind endl; for (int j = 1; j res.size(); j++) if (line[res[j - 1] * 10000 + res[j]] != pre) if (pre != 0) printf(Take Line#%d from %04d to %04d. , pre, pret, res[j - 1]); pre = line[res[j - 1] * 10000 + res[j]]; pret = res[j - 1]; printf(Take Line#%d from %04d to %04d. , pre, pret, dest); return 0; 1132 Cut Integer#include iostream#include stringusing namespace std;int main() int n; cin n; for (int i = 0; i n; i++) string z; cin z; int c = stoi(z); int a = stoi(z.substr(0, z.size() / 2)); int b = stoi(z.substr(z.size() / 2)); if (a * b == 0 || c % (a * b)) cout No endl; else cout Yes endl; return 0; 1133 Splitting A Linked List#include iostream#include vectorusing namespace std;struct node int add, val, nex; nums[100001];vectorint res1, res2, res3, res;int main() int start, n, k, add, val, nex; cin start n k; for (int i = 0; i n; i++) cin add val nex; nums[add] = add, val, nex; int t = start; while (t != -1) if (nums[t].val 0) res1.push_back(t); else if (nums[t].val = k) res2.push_back(t); else res3.push_back(t); t = nums[t].nex; for (auto it: res1) res.push_back(it); for (auto it: res2) res.push_back(it); for (auto it: res3) res.push_back(it); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); printf(%05d %d -1, nums[res[res.size() - 1]].add, nums[res[res.size() - 1]].val); return 0; 1134 Vertex Cover#include iostream#include vector#include setusing namespace std;const int N = 10001;vectorint g[N];setint res;int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a].push_back(b); g[b].push_back(a); cin k; for (int i = 0; i k; i++) cin n; res.clear(); for (int j = 0; j n; j++) cin a; for (int i = 0; i g[a].size(); i++) if (a g[a][i]) res.insert(a * 10000 + g[a][i]); else res.insert(g[a][i] * 10000 + a); if (res.size() == m) cout Yes endl; else cout No endl; return 0; æŸ³å©¼çš„ #include iostream#include vectorusing namespace std;const int N = 10001;vectorint g[N];bool st[N];int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a].push_back(i); g[b].push_back(i); cin k; for (int i = 0; i k; i++) cin n; fill(st, st + N, false); for (int j = 0; j n; j++) cin a; for (int i = 0; i g[a].size(); i++) st[g[a][i]] = true; bool flag = true; for (int j = 0; j m; j++) if (!st[j]) flag = false; break; if (flag) cout Yes endl; else cout No endl; return 0; 1135 Is It A Red-Black Tree#include iostreamusing namespace std;struct node int val; node *l, *r;;node* build(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-l = root-r = NULL; else if (abs(val) = abs(root-val)) root-l = build(root-l, val); else root-r = build(root-r, val); return root;bool judge1(node* root) if (root == NULL) return true; if (root-val 0) if (root-l != NULL root-l-val 0) return false; if (root-r != NULL root-r-val 0) return false; return judge1(root-l) judge1(root-r);int getnum(node* root) if (root == NULL) return 0; int l = getnum(root-l); int r = getnum(root-r); if (root-val 0) return max(l, r) + 1; else return max(l, r);bool judge2(node* root) if (root == NULL) return true; int l = getnum(root-l); int r = getnum(root-r); if (l != r) return false; return judge2(root-l) judge2(root-r);int main() int k, n, x, start; cin k; for (int i = 0; i k; i++) cin n; node* root = NULL; for (int j = 0; j n; j++) cin x; if (j == 0) start = x; root = build(root, x); if (start 0 || !judge1(root) || !judge2(root)) cout No endl; else cout Yes endl; return 0; 1136 A Delayed Palindrome#include iostream#include string#include algorithmusing namespace std;bool check(string s) for (int i = 0; i s.size() / 2; i++) if (s[i] != s[s.size() - i - 1]) return false; return true;string add(string a, string b) if (a.size() b.size()) swap(a, b); string res = ; int i, t = 0; for (i = 0; i b.size(); i++) t = a[a.size() - i - 1] - 0 + b[b.size() - i - 1] - 0 + t; res += (t % 10) + 0; t /= 10; for (; i a.size(); i++) t = a[a.size() - i - 1] - 0 + t; res += (t % 10) + 0; t /= 10; if (t) res += 1; reverse(res.begin(), res.end()); return res;int main() string a; int cnt = 0; cin a; while(!check(a) cnt 10) string b = a; reverse(a.begin(), a.end()); string c = add(a, b); cout b + a = c endl; a = c; cnt++; if (check(a)) cout a is a palindromic number.; else cout Not found in 10 iterations.; return 0; 1137 Final Grading#include iostream#include string#include algorithm#include vector#include map#include setusing namespace std;struct node string id; int gp, gm, gf, g;;vectornode nums;mapstring, int mgp;mapstring, int mgm;mapstring, int mgf;setstring ids;bool cmp(node a, node b) if (a.g != b.g) return a.g b.g; else return a.id b.id;int main() int p, m, n, g; string id; cin p m n; for (int i = 0; i p; i++) cin id g; mgp[id] = g; ids.insert(id); for (int i = 0; i m; i++) cin id g; mgm[id] = g; ids.insert(id); for (int i = 0; i n; i++) cin id g; mgf[id] = g; ids.insert(id); for (auto id: ids) if (mgp[id] = 200) if(mgm.find(id) == mgm.end()) mgm[id] = -1; if (mgm[id] mgf[id]) g = mgm[id] * 0.4 + mgf[id] * 0.6 + 0.5; else g = mgf[id]; if (g = 60) nums.push_back(id, mgp[id], mgm[id], mgf[id], g); sort(nums.begin(), nums.end(), cmp); for (auto it: nums) cout it.id it.gp it.gm it.gf it.g endl; return 0; 1138 Postorder Traversal#include iostreamusing namespace std;const int N = 50001;int pre[N], in[N];bool flag;void build(int preL, int preR, int inL, int inR) if (preL preR || flag) return; int root = pre[preL], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; build(preL + 1, preL + cntL, inL, id - 1); build(preL + cntL + 1, preR, id + 1, inR); if (!flag) cout root endl; flag = true; int main() int n; cin n; for (int i = 0; i n; i++) cin pre[i]; for (int i = 0; i n; i++) cin in[i]; build(0, n - 1, 0, n - 1); return 0; 1139 First Contactæ²¡è€ƒè™‘-0000 #include iostream#include vector#include algorithmusing namespace std;vectorint g[20001];bool visit[20001];int main() int n, m, k, a, b; cin n m; for (int i = 0; i m; i++) cin a b; if (a 0) a += 20000; if (b 0) b += 20000; g[a].push_back(b); g[b].push_back(a); cin k; for (int i = 0; i k; i++) cin a b; fill(visit, visit + 20001, false); if (a 0) a += 20000; if (b 0) b += 20000; visit[a] = visit[b] = true; vectorpairint, int res; if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(g[a][j], g[g[a][j]][p]); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(-g[a][j] + 20000, g[g[a][j]][p]); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(g[a][j], -g[g[a][j]][p] + 20000); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(-g[a][j] + 20000, -g[g[a][j]][p] + 20000); break; visit[g[a][j]] = false; cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) printf(%04d %04d , res[i].first, res[i].second); return 0; æŸ³å©¼çš„ #include iostream#include vector#include string#include algorithm#include unordered_mapusing namespace std;unordered_mapint, bool arr;vectorint v[10000];int main() int n, m, k; cin n m; for (int i = 0; i m; i++) string a, b; cin a b; if (a.length() == b.length()) v[abs(stoi(a))].push_back(abs(stoi(b))); v[abs(stoi(b))].push_back(abs(stoi(a))); arr[abs(stoi(a)) * 10000 + abs(stoi(b))] = arr[abs(stoi(b)) * 10000 + abs(stoi(a))] = true; cin k; for (int i = 0; i k; i++) int c, d; cin c d; vectorpairint, int res; for (int j = 0; j v[abs(c)].size(); j++) for (int k = 0; k v[abs(d)].size(); k++) if (v[abs(c)][j] == abs(d) || abs(c) == v[abs(d)][k]) continue; if (arr[v[abs(c)][j] * 10000 + v[abs(d)][k]] == true) res.push_back(v[abs(c)][j], v[abs(d)][k]); cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) printf(%04d %04d , res[i].first, res[i].second); return 0; 1140 Look-and-say Sequence#include iostreamusing namespace std;int main() string s; int n, j; cin s n; for (int cnt = 1; cnt n; cnt++) string t; for (int i = 0; i s.length(); i = j) for (j = i; j s.length() s[j] == s[i]; j++); t += s[i] + to_string(j - i); s = t; cout s; return 0; 1141 PAT Ranking of Institutions#include iostream#include string#include vector#include unordered_map#include algorithmusing namespace std;struct node string name; int tws, ns;;bool cmp(node a, node b) if (a.tws != b.tws) return a.tws b.tws; else if(a.ns != b.ns) return a.ns b.ns; else return a.name b.name;unordered_mapstring, vectordouble schools;vectornode res;int main() int n; double score; string id, school; cin n; for (int i = 0; i n; i++) cin id score school; for (int j = 0; j school.size(); j++) school[j] = tolower(school[j]); if (id[0] == B) score /= 1.5; else if (id[0] == T) score *= 1.5; schools[school].push_back(score); for (auto it: schools) double s = 0; for (double i: it.second) s += i; res.push_back(it.first, (int)s, it.second.size()); sort(res.begin(), res.end(), cmp); cout res.size() endl; int rank = 1; for (int i = 0; i res.size(); i++) if (i != 0 res[i].tws != res[i - 1].tws) rank = i + 1; cout rank res[i].name res[i].tws res[i].ns endl; return 0; 1142 Maximal Clique#include iostream#include vector#include mapusing namespace std;mapint, bool mp;int pre[10001];int main() int m, n, u, v, a; cin m n; for (int i = 0; i n; i++) cin pre[i]; mp[pre[i]] = true; for (int i = 0; i m; i++) cin u v; for (int j = 0; j n; j++) a = pre[j]; if (a = u a = v || a = v a = u) break; if (mp[u] == false mp[v] == false) printf(ERROR: %d and %d are not found. , u, v); else if (mp[u] == false || mp[v] == false) printf(ERROR: %d is not found. , mp[u] == false ? u : v); else if (a == u || a == v) printf(%d is an ancestor of %d. , a, a == u ? v : u); else printf(LCA of %d and %d is %d. , u, v, a); return 0; 1143 Lowest Common Ancestor#include iostream#include vector#include mapusing namespace std;mapint, bool mp;int pre[10001];int main() int m, n, u, v, a; cin m n; for (int i = 0; i n; i++) cin pre[i]; mp[pre[i]] = true; for (int i = 0; i m; i++) cin u v; for (int j = 0; j n; j++) a = pre[j]; if (a = u a = v || a = v a = u) break; if (mp[u] == false mp[v] == false) printf(ERROR: %d and %d are not found. , u, v); else if (mp[u] == false || mp[v] == false) printf(ERROR: %d is not found. , mp[u] == false ? u : v); else if (a == u || a == v) printf(%d is an ancestor of %d. , a, a == u ? v : u); else printf(LCA of %d and %d is %d. , u, v, a); return 0; 1144 The Missing Number#include iostream#include mapusing namespace std;int main() int n, a, num = 1; cin n; mapint, int m; for (int i = 0; i n; i++) cin a; m[a]++; while (true) if (m[num++] == 0) break; cout num - 1; return 0; 1145 Hashing - Average Search Time#include iostream#include cmathusing namespace std;int nums[10001];bool isprime(int x) if (x = 1) return false; for (int i = 2; i * i = x; i++) if (x % i == 0) return false; return true;int main() int ms, n, m, x; cin ms n m; while (!isprime(ms)) ms++; for (int i = 0; i n; i++) cin x; bool flag = false; for (int j = 0; j ms; j++) if (nums[(x + j * j) % ms] == 0) nums[(x + j * j) % ms] = x; flag = true; break; if (!flag) cout x cannot be inserted. endl; int times = m; for (int i = 0; i m; i++) cin x; bool flag = false; for (int j = 0; j ms; j++) if (nums[(x + j * j) % ms] == x || nums[(x + j * j) % ms] == 0) times += j; flag = true; break; if (!flag) times += ms; printf(%.1f, (double)times / m); return 0; 1146 Topological Order#include iostream#include vectorusing namespace std;vectorint v[1010], res;int main() int n, m, a, b, k, in[1010], tin[1010]; cin n m; for (int i = 0; i m; i++) cin a b; v[a].push_back(b); in[b]++; cin k; for (int i = 0; i k; i++) bool flag = true; for (int i = 1; i = n; i++) tin[i] = in[i]; for (int i = 0; i n; i++) cin a; if (tin[a] != 0) flag = false; for (int it :v[a]) tin[it]--; if (flag) continue; res.push_back(i); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1147 Heaps#include iostream#include vectorusing namespace std;int nums[2001], n;struct node int val, l, r;trees[1001];vectorint res;void post(int root) if (root = n) return; post(trees[root].l); post(trees[root].r); res.push_back(trees[root].val);int main() int m; cin m n; for (int i = 0; i m; i++) int flag = 0; fill(nums, nums + 2 * n, -1); for (int j = 0; j n; j++) cin nums[j]; if (nums[0] nums[1] nums[0] nums[2]) flag = 1; if (nums[0] nums[1] nums[0] nums[2]) flag = 2; for (int j = 0; j n; j++) trees[j].val = nums[j]; if (flag == 1 (2*j+1 n nums[j] nums[2*j+1] || 2*j+2 n nums[j] nums[2*j+2])) flag = 0; if (flag == 2 (2*j+1 n nums[j] nums[2*j+1] || 2*j+2 n nums[j] nums[2*j+2])) flag = 0; trees[j].l = 2 * j + 1; trees[j].r = 2 * j + 2; post(0); if (flag == 0) cout Not Heap endl; else if (flag == 1) cout Max Heap endl; else if (flag == 2) cout Min Heap endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; res.clear(); return 0; æŸ³å©¼çš„ #include iostreamusing namespace std;int a[1005], m, n;void post(int root) if (root n) return; post(root * 2); post(root * 2 + 1); printf(%d%s, a[root], root == 1 ? : );int main() cin m n; for (int j = 0; j m; j++) int minn = 1, maxn = 1; for (int i = 1; i = n; i++) cin a[i]; for (int i = 2; i = n; i++) if (a[i] a[i / 2]) maxn = 0; if (a[i] a[i / 2]) minn = 0; if (maxn == 1) cout Max Heap endl; else if (minn == 1) cout Min Heap endl; else cout Not Heap endl; post(1); return 0; 1148 Werewolf - Simple Version#include iostreamusing namespace std;int nums[101];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; for (int i = 1; i n; i++) for (int j = i + 1; j = n; j++) int t = 0, flag = 0; for (int k = 0; k n; k++) if (nums[k] 0 -nums[k] != i -nums[k] != j) t++; if ((k + 1) == i || (k + 1) == j) flag++; if (nums[k] 0 (nums[k] == i || nums[k] == j)) t++; if ((k + 1) == i || (k + 1) == j) flag++; if (t == 2 flag == 1) cout i j endl; return 0; cout No Solution endl; return 0; 1149 Dangerous Goods Packaging#include iostream#include vectorusing namespace std;const int N = 100001;bool st[N];int nums[N];vectorint g[N];int main() int n, m, a, b, k; cin n m; for (int i = 0; i n; i++) cin a b; g[a].push_back(b); g[b].push_back(a); for (int i = 0; i m; i++) cin k; bool flag = true; fill(st, st + N, false); for (int j = 0; j k; j++) cin nums[j]; st[nums[j]] = true; for (int j = 0; j k; j++) for (int r = 0; r g[nums[j]].size(); r++) if (st[g[nums[j]][r]]) flag = false; break; if (!flag) break; if (flag) cout Yes endl; else cout No endl; return 0; 1150 Travelling Salesman Problem#include iostreamusing namespace std;bool visit[205];int g[205][205], nums[205];int main() int n, m, k, t, city1, city2, d, res = 0x3f3f3f3f, id = 0; cin n m; for (int i = 0; i m; i++) cin city1 city2 d; g[city1][city2] = g[city2][city1] = d; cin k; for (int i = 1; i = k; i++) cin t; bool isCycle = true, isSimple = true, isNA = false; int dist = 0; for (int j = 0; j t; j++) cin nums[j]; fill(visit, visit + 205, false); for (int j = 1; j t; j++) if (g[nums[j]][nums[j-1]]) dist += g[nums[j]][nums[j-1]]; if (!visit[nums[j]]) visit[nums[j]] = true; else isSimple = false; else isCycle = false; isNA = true; for (int i = 1; i = n; i++) if (!visit[i]) isCycle = false; if (isCycle dist res) res = dist; id = i; if (isCycle isSimple) cout Path i : dist (TS simple cycle) endl; else if (isCycle !isSimple) cout Path i : dist (TS cycle) endl; else if (!isCycle isNA) cout Path i : NA (Not a TS cycle) endl; else if (!isCycle !isNA) cout Path i : dist (Not a TS cycle) endl; cout Shortest Dist( id ) = res; return 0; 1151 LCA in a Binary Tree#include iostream#include vector#include mapusing namespace std;mapint, int pos;vectorint in, pre;void lca(int inl, int inr, int preRoot, int a, int b) if (inl inr) return; int inRoot = pos[pre[preRoot]], aIn = pos[a], bIn = pos[b]; if (aIn inRoot bIn inRoot) lca(inl, inRoot - 1, preRoot + 1, a, b); else if ((aIn inRoot bIn inRoot) || (aIn inRoot bIn inRoot)) printf(LCA of %d and %d is %d. , a, b, in[inRoot]); else if (aIn inRoot bIn inRoot) lca(inRoot + 1, inr, preRoot + 1 + (inRoot - inl), a, b); else if (aIn == inRoot) printf(%d is an ancestor of %d. , a, b); else if (bIn == inRoot) printf(%d is an ancestor of %d. , b, a);int main() int m, n, a, b; cin m n; in.resize(n + 1); pre.resize(n + 1); for (int i = 1; i = n; i++) cin in[i]; pos[in[i]] = i; for (int i = 1; i = n; i++) cin pre[i]; for (int i = 0; i m; i++) cin a b; if (pos[a] == 0 pos[b] == 0) printf(ERROR: %d and %d are not found. , a, b); else if (pos[a] == 0 || pos[b] == 0) printf(ERROR: %d is not found. , pos[a] == 0 ? a : b); else lca(1, n, 1, a, b); return 0; 1152 Google Recruitment#include iostream#include stringusing namespace std;typedef long long LL;bool check(LL n) if (n 2) return false; for (int i = 2; i * i n; i++) if (n % i == 0) return false; return true;int main() int l, k; string str; cin l k; cin str; for (int i = 0; i = l - k; i++) if (check(stol(str.substr(i, k)))) cout str.substr(i, k); return 0; cout 404 endl; return 0; 1153 Decode Registration Card of PAT)#include iostream#include string#include vector#include map#include algorithmusing namespace std;typedef pairint, int PII;struct node string num; char ch; int site, date, score;nums[10005];bool cmp1(node a, node b) if (a.score != b.score) return a.score b.score; return a.num b.num;bool cmp2(PII a, PII b) if (a.second != b.second) return a.second b.second; return a.first b.first;int main() int n, m, flag, site, date, score, x; char ch; string num; cin n m; for (int i = 0; i n; i++) cin num score; nums[i] = num, num[0], stoi(num.substr(1, 3)), stoi(num.substr(4, 6)), score; for (int i = 1; i = m; i++) cin flag; if (flag == 1) vectornode t; cin ch; cout Case i : 1 ch endl; for (int j = 0; j n; j++) if (ch == nums[j].ch) t.push_back(nums[j]); sort(t.begin(), t.end(), cmp1); for (auto it: t) cout it.num it.score endl; if (t.empty()) cout NA endl; else if (flag == 2) cin site; cout Case i : 2 site endl; int nt = 0, ns = 0; for (int j = 0; j n; j++) if (site == nums[j].site) nt++; ns += nums[j].score; if (nt == 0) cout NA endl; else cout nt ns endl; else if (flag == 3) cin date; printf(Case %d: 3 %06d , i, date); mapint, int t; vectorpairint, int t2; for (int j = 0; j n; j++) if (date == nums[j].date) t[nums[j].site] ++; for (auto it: t) t2.push_back(it.first, it.second); sort(t2.begin(), t2.end(), cmp2); for (auto it: t2) cout it.first it.second endl; if (t2.empty()) cout NA endl; return 0; 1154 Vertex Coloring#include iostream#include vectorusing namespace std;int level[1005];struct node int val, l, r; nums[1005];int n;int build(int root) if (root = n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;vectorint t;void dfs(int root) if (root == -1) for (int i = 0; i t.size(); i++) cout t[i]; if (i t.size() - 1) cout ; else cout endl; return; t.push_back(nums[root].val); if (nums[root].l == -1 nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) dfs(nums[root].r); else if (nums[root].r == -1) dfs(nums[root].l); else dfs(nums[root].r); dfs(nums[root].l); t.pop_back();int main() cin n; for (int i = 0; i n; i++) cin level[i]; build(0); dfs(0); bool ismin = true, ismax = true; for (int i = 2; i = n; i++) if (level[i/2-1] level[i-1]) ismin = false; if (level[i/2-1] level[i-1]) ismax = false; if (ismin) cout Min Heap endl; else printf(%s, ismax ? Max Heap : Not Heap); return 0; 1155 Heap Paths#include iostream#include vectorusing namespace std;int level[1005];struct node int val, l, r; nums[1005];int n;bool ismax, ismin;int build(int root) if (root = n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;vectorint t;void dfs(int root) if (root == -1) for (int i = 0; i t.size(); i++) cout t[i]; if (i t.size() - 1) cout ; else cout endl; return; t.push_back(nums[root].val); if (nums[root].l == -1 nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) if (nums[root].val nums[nums[root].r].val) ismax = true; else if (nums[root].val nums[nums[root].r].val) ismin = true; dfs(nums[root].r); else if (nums[root].r == -1) if (nums[root].val nums[nums[root].l].val) ismax = true; else if (nums[root].val nums[nums[root].l].val) ismin = true; dfs(nums[root].l); else if (nums[root].val nums[nums[root].r].val nums[root].val nums[nums[root].l].val) ismax = true; else if (nums[root].val nums[nums[root].r].val nums[root].val nums[nums[root].l].val) ismin = true; dfs(nums[root].r); dfs(nums[root].l); t.pop_back();int main() cin n; for (int i = 0; i n; i++) cin level[i]; build(0); dfs(0); if (ismax ismin) cout Not Heap endl; else if (ismax) cout Max Heap endl; else if (ismin) cout Min Heap endl; return 0; 1156 Sexy Primes#include iostreamusing namespace std;bool check(int n) if (n 2) return false; for (int i = 2; i * i = n; i++) if (n % i == 0) return false; return true;int main() int n; cin n; if (check(n) check(n - 6)) cout Yes n - 6; else if (check(n) check(n + 6)) cout Yes n + 6; else for (int i = n + 1; ; i++) if (check(i) check(i - 6) || check(i) check(i + 6)) cout No i; break; return 0; 1157 Anniversary#include iostream#include string#include vector#include mapusing namespace std;mapstring, bool isAlumni;vectorstring alumnu, guest;int main() int n; string num; cin n; for (int i = 0; i n; i++) cin num; isAlumni[num] = true; cin n; for (int i = 0; i n; i++) cin num; if (isAlumni[num]) alumnu.push_back(num); else guest.push_back(num); cout alumnu.size() endl; if (!alumnu.empty()) string mind = alumnu[0].substr(6, 8), res = alumnu[0]; for (int i = 1; i alumnu.size(); i++) if (mind alumnu[i].substr(6, 8)) mind = alumnu[i].substr(6, 8); res = alumnu[i]; cout res; else string mind = guest[0].substr(6, 8), res = guest[0]; for (int i = 1; i guest.size(); i++) if (mind guest[i].substr(6, 8)) mind = guest[i].substr(6, 8); res = guest[i]; cout res; 1158 Telefraud Detection#include iostream#include vector#include map#include algorithmusing namespace std;int g[1005][1005] , father[1005];vectorint suspects;int find(int x) if (father[x] != x) father[x] = find(father[x]); return father[x];void union1(int a, int b) int fa = find(a); int fb = find(b); if (fa != fb) if (fa fb) father[fb] = fa; else father[fa] = fb; int main() int k, n, m, caller, receiver, duration; cin k n m; for (int i = 0; i m; i++) cin caller receiver duration; g[caller][receiver] += duration; for (int i = 1; i = n; i++) int to = 0, back = 0; for (int j = 1; j = n; j++) if (g[i][j] g[i][j] = 5) to++; if (g[i][j] g[i][j] = 5 g[j][i]) back++; if (to k back = to * 0.2) suspects.push_back(i); break; if (suspects.empty()) cout None endl; for (int i = 0; i suspects.size(); i++) father[suspects[i]] = suspects[i]; for (int i = 0; i suspects.size(); i++) for (int j = i + 1; j suspects.size(); j++) if (g[suspects[i]][suspects[j]] g[suspects[j]][suspects[i]]) union1(suspects[i], suspects[j]); mapint, vectorint res; for (int i = 0; i suspects.size(); i++) int t = find(suspects[i]); res[t].push_back(suspects[i]); for (auto it: res) sort(it.second.begin(), it.second.end()); for (int i = 0; i it.second.size(); i++) cout it.second[i]; if (i it.second.size() - 1) cout ; else cout endl; return 0; 1159 Structure of a Binary Tree#include iostream#include vector#include string#include queueusing namespace std;int post[31], in[31];struct node int l, r, parent, level; trees[1005];bool isFull = true;int build(int postL, int postR, int inL, int inR, int parent, int level) if (postL postR) return -1; int root = post[postR], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; trees[root].parent = parent; trees[root].level = level; trees[root].l = build(postL, postL + cntL - 1, inL, id - 1, root, level + 1); trees[root].r = build(postL + cntL, postR - 1, id + 1, inR, root, level + 1); if (trees[root].l * trees[root].r 0) isFull = false; return root;int main() int n, m, a, b; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1, 0, n - 1, -1, 0); cin m; string ops; for (int i = 0; i m; i++) cin ops; if (ops == It) cin ops ops ops ops; if (isFull) cout Yes endl; else cout No endl; continue; a = stoi(ops); cin ops; if (ops == is) cin ops ops; if (ops == root) if (a == root) cout Yes endl; else cout No endl; else if (ops == parent) cin ops b; if (trees[a].l == b || trees[a].r == b) cout Yes endl; else cout No endl; else if (ops == left) cin ops ops b; if (trees[b].l == a) cout Yes endl; else cout No endl; else if (ops == right) cin ops ops b; if (trees[b].r == a) cout Yes endl; else cout No endl; else if (ops == and) cin b ops ops; if (ops == siblings) if (trees[a].parent == trees[b].parent) cout Yes endl; else cout No endl; else if (ops == on) cin ops ops ops; if (trees[a].level == trees[b].level) cout Yes endl; else cout No endl; return 0; 1160 Forever#include iostream#include vector#include map#include algorithmusing namespace std;typedef long long LL;typedef pairint, LL PII;int k, m;vectorPII res;int gcd(int a, int b) if (b) return gcd(b, a % b); else return a;bool isprime(int x) if (x 2) return false; for (int i = 2; i * i = x; i++) if (x % i == 0) return false; return true;void dfs(int cnt, int sum, LL x) if (cnt k || sum m || m sum + 9*(k-cnt)) return; if (cnt == k sum == m) LL y = x + 1; int n = 0; while (y) n += y % 10; y /= 10; if (gcd(n, m) 2 isprime(gcd(n, m))) res.push_back(n, x); return; for (int i = 0; i = 9; i++) if (sum == 0 i == 0) continue; else dfs(cnt + 1, sum + i, x * 10 + i); int main() int n; cin n; for (int i = 1; i = n; i++) cout Case i endl; cin k m; res.clear(); dfs(0, 0, 0); if (res.empty()) cout No Solution endl; else sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; return 0; 1161 Merging Linked Lists#include iostream#include vectorusing namespace std;struct node int add, val, nxt; nums[100005];vectornode l1, l2, res;int main() int s1, s2, n, id; cin s2 s1 n; for (int i = 0; i n; i++) cin id; cin nums[id].val nums[id].nxt; nums[id].add = id; while (s1 != -1) l1.push_back(nums[s1]); s1 = nums[s1].nxt; while (s2 != -1) l2.push_back(nums[s2]); s2 = nums[s2].nxt; if (l1.size() l2.size()) swap(l1, l2); id = 0; for (int i = l2.size() - 1; i = 0; i--) res.push_back(l1[id++]); res.push_back(l1[id++]); res.push_back(l2[i]); for (int i = id; i l1.size(); i++) res.push_back(l1[i]); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , res[i].add, res[i].val, res[i + 1].add); printf(%05d %d -1, res.back().add, res.back().val); return 0; 1162 Postfix Expression#include iostream#include stringusing namespace std;struct node string ch; int l, r; trees[21];bool st[21];void postorder(int x) if (x == -1) return; if (trees[x].l == -1) cout ( trees[x].ch; postorder(trees[x].r); cout ); else cout (; postorder(trees[x].l); postorder(trees[x].r); cout trees[x].ch ); int main() int n, root = 1; cin n; for (int i = 1; i = n; i++) cin trees[i].ch trees[i].l trees[i].r; st[trees[i].l] = st[trees[i].r] = true; for (int i = 1; i = n; i++) if (!st[i]) root = i; postorder(root); return 0; æŸ³å©¼çš„ #include iostream#include stringusing namespace std;int n, root = 1, lc[31], rc[31], mark[32];string d[32];void deal(int x) cout (; if (lc[x] * rc[x] 1) deal(lc[x]); deal(rc[x]); cout d[x]; if (lc[x] * rc[x] 0) deal(rc[x]); cout );int main() cin n; for (int i = 1; i = n; i++) cin d[i] lc[i] rc[i]; mark[lc[i]] = mark[rc[i]] = 1; while (mark[root]) root++; deal(root); return 0; 1163 Dijkstra Sequence#include iostreamusing namespace std;const int INF = 0x3f3f3f3f;int n, m, g[1005][1005], nums[1005], d[1005];bool visit[1005];bool dijkstra(int x) fill(visit, visit + 1005, false); fill(d, d + 1005, INF); d[x] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 1; j = n; j++) if (!visit[j]) if (mind d[j]) mind = d[j]; u = j; else if (mind == d[j]) if (j == nums[i]) u = j; if (u != nums[i]) return false; visit[u] = true; for (int j = 1; j = n; j++) if (g[u][j] !visit[j] d[u] + g[u][j] d[j]) d[j] = d[u] + g[u][j]; return true;int main() int a, b, c, k; cin n m; for (int i = 0; i m; i++) cin a b c; g[a][b] = g[b][a] = c; cin k; for (int j = 0; j k; j++) for (int i = 0; i n; i++) cin nums[i]; if (dijkstra(nums[0])) cout Yes endl; else cout No endl; return 0; 1164 Good in C#include iostream#include stringusing namespace std;string alp[27][8];int main() for (int i = 0; i 26; i++) for (int j = 0; j 7; j++) cin alp[i][j]; string strs[1000], t, str; char ch; int id2 = 0; getchar(); getline(cin, t); for (int i = 0; i t.size(); i++) ch = t[i]; if (ch = A ch = Z) str.push_back(ch); else if (!str.empty()) strs[id2++] = str; str.clear(); if (!str.empty()) strs[id2++] = str; str.clear(); for (int i = 0; i id2; i++) for (int j = 0; j 7; j++) for (int k = 0; k strs[i].size(); k++) cout alp[strs[i][k] - A][j]; if (k strs[i].size() - 1) cout ; else cout endl; if (i id2 - 1) cout endl; return 0; 1165 Block Reversing#include iostream#include vectorusing namespace std;struct node int add, val, nxt; nums[100005];int main() int start, n, k, add, val, nxt; cin start n k; for (int i = 0; i n; i++) cin add; nums[add].add = add; cin nums[add].val nums[add].nxt; vectorint tmps, res; while (start != -1) tmps.push_back(start); start = nums[start].nxt; int t = tmps.size() / k; for (int i = t * k; i tmps.size(); i++) res.push_back(tmps[i]); for (int i = t * k - k; i = 0; i -= k) for (int j = 0; j k; j++) res.push_back(tmps[i + j]); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); printf(%05d %d -1, nums[res.back()].add, nums[res.back()].val); return 0; 1166 Summit#include iostream#include vectorusing namespace std;int g[205][205], nums[205];bool st[205];int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a][b] = g[b][a] = 1; cin k; for (int i = 1; i = k; i++) cout Area i; cin m; fill (st, st + 205, false); for (int j = 0; j m; j++) cin nums[j]; st[nums[j]] = true; bool flag1 = false, flag2 = false, flag3 = false; for (int p = 0; p m; p++) for (int q = p + 1; q m; q++) if (g[nums[p]][nums[q]] == 0) flag1 = true; break; if (flag1) cout needs help. endl; break; if (!flag1) for (int p = 1; p = n; p++) if (!st[p]) flag2 = false; for (int q = 0; q m; q++) if (g[p][nums[q]] == 0) flag2 = true; if (!flag2) cout may invite more people, such as p . endl; flag3 = true; break; if (!flag3) cout is OK. endl; return 0; 1167 Cartesian Tree#include iostream#include vector#include queueusing namespace std;struct node int val, l, r; trees[32];int in[32];vectorint level;int build(int l, int r) if (l r) return -1; int mind = 0x3f3f3f3f, root = l; for (int i = l; i = r; i++) if (mind in[i]) mind = in[i]; root = i; trees[root].val = mind; trees[root].l = build(l, root - 1); trees[root].r = build(root + 1, r); return root;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); q.pop(); level.push_back(trees[u].val); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); int main() int n; cin n; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1); bfs(root); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; return 0; 1168 Prime Day#include iostream#include stringusing namespace std;bool isPrime(int n) if (n 2) return false; for (int i = 2; i * i = n; i++) if (n % i == 0) return false; return true;int main() string n; cin n; bool flag = true; for (int i = 0; i 8; i++) if (isPrime(stoi(n))) cout n Yes endl; else cout n No endl; flag = false; n = n.substr(1); if (flag) cout All Prime!; return 0; 1169 The Judger#includeiostream#include vectorusing namespace std;bool st[100005], out[11];int g[12][1005];vectorint nums;bool check(int x) for (int i = 0; i nums.size(); i++) for (int j = i + 1; j nums.size(); j++) if (x == abs(nums[i] - nums[j])) return true; return false;int main() int a, b, n, m; cin a b n m; st[a] = st[b] = true; nums.push_back(a); nums.push_back(b); for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin g[i][j]; for (int i = 0; i m; i++) vectorint tmp; for (int j = 0; j n; j++) if (!out[j]) if (!st[g[j][i]] check(g[j][i])) nums.push_back(g[j][i]); st[g[j][i]] = true; else tmp.push_back(j + 1); out[j] = true; if (!tmp.empty()) for (int j = 0; j tmp.size(); j++) cout Round # i + 1 : tmp[j] is out. endl; vectorint res; for (int i = 0; i n; i++) if (!out[i]) res.push_back(i + 1); if (!res.empty()) cout Winner(s):; for (int i = 0; i res.size(); i++) cout res[i]; else cout No winner.; return 0; 1170 Safari Park#include iostream#include vector#include mapusing namespace std;int g[505][505];int main() int n, r, k, a, b; cin n r k; for (int i = 0; i r; i++) cin a b; g[a][b] = g[b][a] = 1; cin r; for (int i = 0; i r; i++) mapint, vectorint nums; for (int j = 1; j = n; j++) cin a; nums[a].push_back(j); if (nums.size() == k) bool flag = true; for (auto it: nums) for (int p = 0; p it.second.size(); p++) for (int q = p + 1; q it.second.size(); q++) if (g[it.second[p]][it.second[q]]) flag= false; if (flag) cout Yes endl; else cout No endl; else if (nums.size() k) cout Error: Too few species. endl; else if (nums.size() k) cout Error: Too many species. endl; return 0; 1171 Replacement Selection#include iostream#include queueusing namespace std;int nums[100005];int main() int n, m; cin n m; priority_queueint, vectorint, greaterint q1, q2; for (int i = 0; i n; i++) cin nums[i]; if (i m) q1.push(nums[i]); int id = m; while (q1.size()) int now = q1.top(); cout now; q1.pop(); if (id n) if (nums[id] now) q2.push(nums[id]); else q1.push(nums[id]); id++; if (q1.size()) cout ; else swap(q1, q2); cout endl; return 0; 1172 Panda and PP Milk#include iostreamusing namespace std;int nums[10005], tmps[10005];int main() int n, res = 0; cin n; fill(tmps, tmps + n, 200); for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) int t = nums[i], id = 0; for (int j = i - 1; j = 0; j--) if (t nums[j]) id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; else if (t == nums[j]) tmps[j] = max(tmps[j], 200 + id * 100); else break; t = nums[i], id = 0; for (int j = i + 1; j n; j++) if (t nums[j]) id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; else if (t == nums[j]) tmps[j] = max(tmps[j], 200 + id * 100); else break; for (int i = 0; i n; i++) res += tmps[i]; cout res; return 0; 1173 How Many Ways to Buy a Piece of Land#include iostreamusing namespace std;int nums[10005];int main() int n, m, res = 0; cin n m; for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) int t = 0; for (int j = i; j n; j++) t += nums[j]; if (t = m) res++; else break; cout res; return 0; 1174 Left-View of Binary Tree#include iostream#include vector#include queueusing namespace std;int in[25], pre[25];vectorint res;struct node int l, r; trees[200005];int build(int preL, int preR, int inL, int inR) if (preL preR) return -1; int root = pre[preL], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; trees[root].l = build(preL + 1, preL + cntL, inL, id - 1); trees[root].r = build(preL + cntL + 1, preR, id + 1, inR); return root;void bfs(int root) queueint q; q.push(root); while (!q.empty()) int size = q.size(); for (int i = 0; i size; i++) root = q.front(); q.pop(); if (i == 0) res.push_back(root); if (trees[root].l != -1) q.push(trees[root].l); if (trees[root].r != -1) q.push(trees[root].r); int main() int n; cin n; for (int i = 0; i n; i++) cin in[i]; for (int i = 0; i n; i++) cin pre[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; return 0; 1175 Professional Ability Test - PAT (Advanced Level) Practice (pintia.cn)æŸ³å©¼çš„ #include iostream#include vector#include queueusing namespace std;struct node int v, score, voucher; bool operator (const node x) const if(score != x.score) return score x.score; else return voucher x.voucher; ;struct bian int next, S, D;;vectorbian E[1005];vectorpairint,int Dis(1005, 2e9, -1);int N, M, T1, T2, S, D, f, T, in[1005], in2[1005], Last[1005];queueint DAG;int huan() vectorint S; while(DAG.size()) int now = DAG.front(); DAG.pop(); S.push_back(now); for(auto it : E[now]) in2[it.next]--; if(!in2[it.next]) DAG.push(it.next); return S.size() == N;void dijkstra() vectorint vis(1005); priority_queuenode Q; Q.push(1002, 0, 0); Dis[1002].first = Dis[1002].second = 0; while(Q.size()) node now = Q.top(); Q.pop(); if(vis[now.v]) continue; vis[now.v] = 1; Dis[now.v].first = now.score; Dis[now.v].second = now.voucher; for (auto it : E[now.v]) if(vis[it.next]) continue; if((Dis[it.next].first Dis[now.v].first + it.S) || ((Dis[it.next].first == Dis[now.v].first + it.S) (Dis[it.next].second Dis[now.v].second + it.D))) Dis[it.next].first = Dis[now.v].first + it.S; Dis[it.next].second = Dis[now.v].second + it.D; Last[it.next] = now.v; Q.push(it.next, Dis[it.next].first, Dis[it.next].second); return;int main() cin N M; for (int i = 0; i M; i++) cin T1 T2 S D; E[T1].push_back(T2, S, D); in[T2]++, in2[T2]++; for (int i = 0; i N; i++) if (in[i] == 0) E[1002].push_back(i, 0, 0); DAG.push(i); f = huan(); dijkstra(); cin T; if(f) cout Okay. ; else cout Impossible. ; for (int i = 1, q; i = T; i++) cin q; if(!in[q]) cout You may take test q directly. ; else if(!f) cout Error. ; else vectorint path; int now = q; while(q != 1002) path.push_back(q); q = Last[q]; for (int j = path.size() - 1; j = 0; j--) cout path[j]; if(j) cout -; cout ; return 0; 1176 The Closest Fibonacci Number#include iostream#include algorithmusing namespace std;int dp[43];int main() int n, res = 0, m = 0x3f3f3f3f; cin n; dp[0] = dp[1] = 1; if (n == 1) cout n; return 0; for (int i = 2; i 43; i++) dp[i] = dp[i - 1] + dp[i - 2]; if (m abs(dp[i] - n)) m = abs(dp[i] - n); res = dp[i]; cout res; return 0; 1177 Subsequence in Substring#include iostream#include stringusing namespace std;int main() string s, p; cin s p; int m = 0x3f3f3f3f, idx, l = 0, r = 0; for (int i = 0; i s.size(); i++) if (s[i] == p[0]) idx = 1; for (int j = i + 1; j s.size(); j++) if (j - i = m) break; if (s[j] == p[idx]) idx++; if (idx == p.size()) l = i, r = j; m = r - l; for (int i = l; i = r; i++) cout s[i]; return 0; 1178 File Path#include iostream#include string#include mapusing namespace std;mapstring, string superior;mapint, string last;int main() int n, k; string root, str, res; cin n root; last[1] = root; superior[root] = root; getchar(); for (int i = 1; i n; i++) getline(cin, str); int depth = 0; while (str[depth] == ) depth++; superior[str.substr(depth)] = last[depth]; last[depth + 1] = str.substr(depth); cin k; for (int i = 0; i k; i++) cin str; if (!superior.count(str)) cout Error: str is not found. endl; else res = ; while (str != root) res = - + str + res; str = superior[str]; cout root res; return 0; 1179 Chemical Equation#include iostream#include string#include vector#include algorithmusing namespace std;int n, m, k, num, used[101], res[101];string s;vectorint product, tmp;vectorvectorint equa[101];bool cmp(const vectorint a, const vectorint b) for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] b[i];void dfs(int x) if (x == m) for (int i = 0; i m; i++) for (int j = 0; j equa[product[i]][res[i]].size(); j++) if (j != 0) cout + ; printf(%02d, equa[product[i]][res[i]][j]); printf( - %02d , product[i]); exit(0); for (int i = 0; i equa[product[x]].size(); i++) int flag = 1; vectorint A = equa[product[x]][i]; for (auto it: A) if (used[it] != 1) flag = 0; break; if (flag == 0) continue; for (auto it: A) used[it] = 2; res[x] = i; dfs(x + 1); for (auto it: A) used[it] = 1; int main() cin n; for (int i = 0; i n; i++) cin num; used[num] = 1; cin m; for (int i = 0; i m; i++) cin num; if (used[num] == 1) equa[num].push_back(num); product.push_back(num); cin k; for (int i = 0; i k; i++) tmp.clear(); while (cin num s) tmp.push_back(num); if (s == -) cin num; equa[num].push_back(tmp); break; for (int i = 0; i m; i++) sort(equa[product[i]].begin(), equa[product[i]].end(), cmp); dfs(0); return 0;","tags":["ç®—æ³•","PAT","C++"],"categories":["ç®—æ³•"]},{"title":"ç®—æ³•ç¬”è®°","path":"/2024/07/29/ç®—æ³•ç¬”è®°(c++)/","content":"åˆ·é¢˜åœ°å€ï¼šæ™´é—®ç®—æ³• (sunnywhy.com) å…¥é—¨æ¨¡æ‹Ÿç®€å•æ¨¡æ‹Ÿ3N+1çŒœæƒ³ #include cstdioint main() int n, res = 0; scanf(%d, n); while (n != 1) if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; res ++; printf(%d, res); return 0; åˆ¤æ–­ä¸‰è§’å½¢ #include cstdioint main() int a, b, c; scanf(%d%d%d, a, b, c); if (a + b c a + c b b + c a) printf(YES); else printf(NO); return 0; å•è°ƒé€’å¢åºåˆ— #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); bool flag = true; for (int i = 1; i n; i++) if (nums[i] nums[i - 1]) flag = false; break; printf(flag ? YES : NO); return 0; æ•°åˆ—å¥‡æ•°å’Œ #include cstdioint main() int n, x, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, x); if (x % 2 == 1) res += x; printf(%d, res); return 0; ä¸‰ä½æ•° #include cstdioint main() int n, bai = 0, shi = 0, ge = 0; scanf(%d, n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; printf(%d %d %d, bai, shi, ge); return 0; æ°´ä»™èŠ±æ•° #include cstdio#include cmathint main() int n, bai, shi, ge; scanf(%d, n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; if (pow(bai, 3) + pow(shi, 3) + pow(ge, 3) == n) printf(YES); else printf(NO); return 0; æ°´ä»™èŠ±æ•°II #include cstdiobool check(int x) int a = x / 100; int b = x % 100 / 10; int c = x % 10; return a * a * a + b * b * b + c * c * c == x;const int MAXN = 100;int nums[MAXN];int main() int a, b, idx = 0; scanf(%d%d, a, b); for (int i = a; i = b; i++) if (check(i)) nums[idx++] = i; for (int i = 0; i idx; i++) printf(%d, nums[i]); if (i idx - 1) printf( ); if (idx == 0) printf(NO); return 0; 2çš„å¹‚ #include cstdioint main() int n, res = 1; scanf(%d, n); for (int i = 0; i n; i++) res = (res * 2) % 1007; printf(%d, res); return 0; æŸ¥æ‰¾å…ƒç´ æŸ¥æ‰¾å…ƒç´  #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, x, res = -1; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, x); for (int i = 0; i n; i++) if (x == nums[i]) res = i + 1; break; if (res == -1) printf(NO); else printf(%d, res); return 0; ç»Ÿè®¡å…ƒç´ ä¸ªæ•° #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, x, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, x); for (int i = 0; i n; i++) if (x == nums[i]) res ++; printf(%d, res); return 0; å¯»æ‰¾å…ƒç´ å¯¹ #include cstdioconst int MAXN = 1001;int nums[MAXN];int main() int n, k, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, k); for (int i = 0; i n; i++) for (int j = i + 1; j n; j++) if (nums[i] + nums[j] == k) res ++; printf(%d, res); return 0; å›¾å½¢è¾“å‡ºç­‰è…°ç›´è§’ä¸‰è§’å½¢ #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j = i; j++) printf(*); printf( ); return 0; ç­‰è…°ç›´è§’ä¸‰è§’å½¢II #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j i + 1; j++) if (j == 0 || j == i || i == n - 1) printf(*); else printf( ); printf( ); return 0; ç”»X #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j n; j++) if (j == i || j == n - i - 1) printf(*); else if (j i j n - i - 1) continue; else printf( ); printf( ); return 0; æ—¥æœŸå¤„ç†åˆ¤æ–­é—°å¹´ #include cstdioint main() int n; scanf(%d, n); if (n % 400 == 0 || n % 100 != 0 and n % 4 == 0) printf(YES); else printf(NO); return 0; æ—¥æœŸåŠ æ³• #include cstdioint dayOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return year % 400 == 0 || (year % 4 == 0 year % 100 != 0);void addOneDay(int year, int month, int day) day++; if (day dayOfMonth[isLeapYear(year)][month]) month ++; day = 1; if (month 12) year++; month = 1; int main() int year, month, day, n; scanf(%d-%d-%d, year, month, day); scanf(%d, n); for (int i = 0; i n; i++) addOneDay(year, month, day); printf(%04d-%02d-%02d, year, month, day); return 0; æ—¥æœŸå‡æ³• #include cstdioint daOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return (year % 400 == 0 || year % 4 == 0 and year % 100 != 0);void subDay(int year, int month, int day) day--; if (day == 0) month--; if (month == 0) year --; month = 12; day = daOfMonth[isLeapYear(year)][month]; int main() int year, month, day, n; scanf(%d-%d-%d, year, month, day); scanf(%d, n); for (int i = 0; i n; i++) subDay(year, month, day); printf(%04d-%02d-%02d, year, month,day); return 0; ä¸€å¹´ä¸­çš„ç¬¬å‡ å¤© #include cstdioint dayOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return (year % 400 == 0 || year % 4 == 0 year % 100 != 0);int main() int year, month, day; scanf(%d-%d-%d, year, month, day); int res = day; for (int i = 1; i month; i++) res += dayOfMonth[isLeapYear(year)][i]; printf(%d, res); return 0; æ—¥æœŸå…ˆå #include cstdiobool isBefore(int year1, int month1, int day1, int year2, int month2, int day2) if (year1 != year2) return year1 year2; if (month1 != month2) return month1 month2; return day1 day2;int main() int year1, year2, month1, month2, day1, day2; scanf(%d-%d-%d, year1, month1, day1); scanf(%d-%d-%d, year2, month2, day2); printf(isBefore(year1, month1, day1, year2, month2, day2) ? YES : NO); return 0; è¿›åˆ¶è½¬æ¢åè¿›åˆ¶è½¬äºŒè¿›åˆ¶ #include cstdioconst int MAXN = 11;int nums[MAXN];int main() int n, idx = 0; scanf(%d, n); while (n != 0) nums[idx++] = n % 2; n /= 2; for (int i = idx - 1; i = 0; i--) printf(%d, nums[i]); return 0; äºŒè¿›åˆ¶è½¬åè¿›åˆ¶ #include cstdioint main() int s, res = 0, p = 1; scanf(%d, s); while (s != 0) res += p * (s % 10); p *= 2; s /= 10; printf(%d, res); return 0; åè¿›åˆ¶è½¬Kè¿›åˆ¶ #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, k, idx = 0; scanf(%d %d, n, k); while (n != 0) nums[idx++] = n % k; n /= k; for (int i = idx - 1; i = 0; i--) if (nums[i] 9) printf(%c, nums[i] - 10 + A); else printf(%d, nums[i]); return 0; Kè¿›åˆ¶è½¬åè¿›åˆ¶ #include cstdio#include cstringconst int MAXN = 10;char nums[MAXN];int main() int k, res = 0, p = 1; scanf(%s %d, nums, k); for (int i = strlen(nums) - 1; i = 0 ; i--) int t = (nums[i] = 0 nums[i] = 9) ? (nums[i] - 0) : (nums[i] - A + 10); res += p * t; p *= k; printf(%d, res); return 0; å­—ç¬¦ä¸²å¤„ç†å›æ–‡å­—ç¬¦ä¸² #include iostream#include cstringusing namespace std;int main() string str; cin str; bool flag = true; int n = str.length(); for (int i = 0; i n / 2; i++) if (str[i] != str[str.length() - i - 1]) flag = false; printf(flag ? YES : NO); return 0; å•è¯å€’åº #include cstdioconst int MAXN = 500;const int MAXL = 11;char str[MAXN][MAXL], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = num - 1; i = 0; i--) printf(%s, str[i]); if (i 0) printf( ); return 0; å•è¯å€’åºII #include cstdio#include cstringconst int MAXN = 1000;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = 0; i num; i++) for (int j = strlen(str[i]) - 1; j = 0; j--) printf(%c, str[i][j]); if (i num - 1) printf( ); return 0; å•è¯æ•° #include cstdioconst int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; printf(%d, num); return 0; é¦–å­—æ¯å¤§å†™ #include cstdio#include cstringconst int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM];int num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = 0; i num; i++) for (int j = 0; j strlen(str[i]); j++) if (j == 0) printf(%c, str[i][j] - 32); else printf(%c, str[i][j]); if (i num - 1) printf( ); return 0; å…¬å…±å‰ç¼€ #include cstdio#include cstring#include algorithmusing namespace std;const int MAXN = 20;const int MAXM = 51;char str[MAXN][MAXM];int main() int n, minl = 51; scanf(%d, n); for (int i = 0; i n; i++) scanf(%s, str[i]); minl = min(minl, (int)strlen(str[i])); for (int j = 0; j minl; j++) char a = str[0][j]; bool flag = true; for (int i = 1; i n; i++) if (a != str[i][j]) flag = false; break; if (flag) printf(%c, a); else break; return 0; è¿ç»­ç›¸åŒå­—ç¬¦ç»Ÿè®¡ #include cstdio#include cstringconst int MAXL = 101;char str[MAXL];int main() scanf(%s, str); int idx = 0, len = strlen(str); while (idx len) printf(%c , str[idx++]); int cnt = 1; while (idx len str[idx] == str[idx - 1]) cnt ++; idx ++; printf(%d , cnt); return 0; Cè¯­è¨€åˆæ³•å˜é‡å #include cstdio#include cstringconst int MAXL = 21;char str[MAXL];int main() scanf(%s, str); bool result = true; int len = strlen(str); if (!((str[0] = A str[0] = Z) || (str[0] = a str[0] = z) || str[0] == _)) result = false; for (int i = 1; i len; i++) if (!((str[i] = A str[i] = Z) || (str[i] = a str[i] = z) || (str[i] = 0 str[i] = 9) || str[i] == _)) result = false; break; printf(result ? YES : NO); return 0; ç®—æ³•åˆæ­¥æ’åºç®€å•é€‰æ‹©æ’åº #include cstdio#include algorithmusing namespace std;const int MAXN = 51;int a[MAXN], n;void selectSort() for (int i = 0; i n; i++) int k = i; for (int j = i; j n; j++) if (a[j] a[k]) k = j; swap(a[i], a[k]); int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, a[i]); selectSort(); for (int i = 0; i n; i++) printf(%d, a[i]); printf(i n - 1 ? : ); return 0; ç›´æ¥æ’å…¥æ’åº #include cstdio#include algorithmconst int MAXN = 51;int nums[MAXN], n;void insertSort() for (int i = 1; i n; i++) int t = nums[i]; int j = i; while (j - 1 = 0 nums[j - 1] t) nums[j] = nums[j - 1]; j --; nums[j] = t; int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); insertSort(); for (int i = 0; i n; i++) printf(%d, nums[i]); printf(i n - 1 ? : ); return 0; æ•´æ•°å‡åºæ’åº #include cstdio#include algorithmusing namespace std;const int MAXN = 50;int a[MAXN], n;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, a[i]); sort(a, a + n); for (int i = 0; i n; i++) printf(%d, a[i]); printf(i n - 1 ? : ); return 0; æ•´æ•°é™åºæ’åº #include cstdio#include algorithmusing namespace std;const int MAXN = 51;int nums[MAXN], n;bool cmp(int a, int b) return a b;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); sort(nums, nums + n, cmp); for (int i = 0; i n; i++) printf(%d, nums[i]); printf(i n - 1 ? : ); return 0; å­—ç¬¦ä¸²å‡åºæ’åº #include iostream#include string#include algorithmusing namespace std;const int MAXN = 51;int n;string str[MAXN];int main() cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n); for (int i = 0; i n; i++) cout str[i] endl; return 0; å­—ç¬¦ä¸²é™åºæ’åº #include iostream#include string#include algorithmusing namespace std;const int MAXN = 51;string str[MAXN];int n;bool cmp(string a, string b) return a b;int main() cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n, cmp); for (int i = 0; i n; i++) cout str[i] endl; return 0; è€ƒç”Ÿæ’åº æ•£åˆ—é€’å½’è´ªå¿ƒäºŒåˆ†åŒæŒ‡é’ˆå…¶ä»–é«˜æ•ˆæŠ€å·§ä¸ç®—æ³•æ•°å­¦é—®é¢˜ç®€å•æ•°å­¦æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•°åˆ†æ•°çš„å››åˆ™è¿ç®—ç´ æ•°è´¨å› å­åˆ†è§£å¤§æ•´æ•°è¿ç®—æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ç»„åˆæ•°æ•°æ®ç»“æ„Iæ ˆé˜Ÿåˆ—é“¾è¡¨æœç´¢æ·±åº¦ä¼˜å…ˆæœç´¢å¹¿åº¦ä¼˜å…ˆæœç´¢æ•°æ®ç»“æ„IIæ ‘ä¸äºŒå‰æ ‘äºŒå‰æ ‘çš„éå†æ ‘çš„éå†äºŒå‰æŸ¥æ‰¾æ ‘BSTå¹³è¡¡äºŒå‰æ ‘AVLå¹¶æŸ¥é›†å †å“ˆå¤«æ›¼æ ‘å›¾å›¾çš„å®šä¹‰å›¾çš„å­˜å‚¨å›¾çš„éå†æœ€çŸ­è·¯å¾„æœ€å°ç”Ÿæˆæ ‘æ‹“æ‰‘æ’åºå…³é”®è·¯å¾„åŠ¨æ€è§„åˆ’åŠ¨æ€è§„åˆ’çš„é€’å½’ä¸é€’æ¨æœ€å¤§è¿ç»­å­åºåˆ—å’Œæœ€é•¿ä¸ä¸‹é™å­åºåˆ—LISæœ€é•¿å…¬å…±å­åºåˆ—æœ€é•¿å›æ–‡å­ä¸²DAGæœ€é•¿è·¯èƒŒåŒ…é—®é¢˜æ€»ç»“å­—ç¬¦ä¸²å­—ç¬¦ä¸²hashè¿›é˜¶KMPç®—æ³•ä¸“é¢˜æ‰©å±•åˆ†å—æ€æƒ³æ ‘çŠ¶æ•°ç»„BIT","tags":["ç®—æ³•","C++"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯çœŸé¢˜","path":"/2024/05/29/è“æ¡¥æ¯çœŸé¢˜/","content":"è“æ¡¥æ¯çœŸé¢˜å•è¯åˆ†æfrom collections import Counters = list(input())s.sort()d = Counter(s)print(d.most_common(1)[0][0])print(d.most_common(1)[0][1]) æˆç»©ç»Ÿè®¡n = int(input())nums = [int(input()) for _ in range(n)]a = d = 0for num in nums: if num = 85: a += 1 d += 1 elif num = 60: d += 1print(fround(d*100/n)%)print(fround(a*100/n)%) é—¨ç‰Œåˆ¶ä½œn = 2020res = 0for i in range(1, n + 1): res += str(i).count(2)print(res) æ•°å­—ä¸‰è§’å½¢n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0 for _ in range(n + 2)] for _ in range(n)]dp[0][1] = nums[0][0]for i in range(1, n): for j in range(1, i+2): dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + nums[i][j-1]if n 1: print(dp[n-1][(n + 1) // 2])else: print(max(dp[n-1][n // 2], dp[n-1][n // 2 + 1])) å¡ç‰‡from sys import exitnums = [2021] * 10for i in range(1, 10000): for char in str(i): nums[int(char)] -= 1 if nums[int(char)] 0: print(i-1) exit(0) è·‘æ­¥é”»ç‚¼from datetime import datetime,timedeltastart = datetime(2000, 1, 1)end = datetime(2020, 10, 1)res = 0while start = end: if start.day == 1 or start.weekday() == 0: res += 2 else: res += 1 start += timedelta(days=1)print(res) è›‡å½¢å¡«æ•°nums = [[0] * 100 for _ in range(100)]nums[0][0] = 1i, j, t = 0, 0, 1for _ in range(30): j += 1 t += 1 nums[i][j] = t for _ in range(j): i += 1 j -= 1 t += 1 nums[i][j] = t i += 1 t += 1 nums[i][j] = t for _ in range(i): i -= 1 j += 1 t += 1 nums[i][j] = tprint(nums[19][19]) è´§ç‰©æ‘†æ”¾n = 2021041820210418nums = []for i in range(1, int(n ** 0.5) + 1): if n % i == 0: nums.append(i) nums.append(n/i)res = 0for i in nums: for j in nums: if n % (i*j) == 0: res += 1print(res) # 2430 ï¼æ¨è¾‰ä¸‰è§’å½¢æš´åŠ›ï¼ˆ40%ï¼‰ n = int(input())nums = []for i in range(1, 1600): nums.append([1] * i + [0]) for j in range(1, i): nums[i-1][j] = nums[i-2][j] + nums[i-2][j-1]for i, num in enumerate(nums): if n in num: d = num.index(n) res = i * (i+1) // 2 + d + 1 print(res) break ç»„åˆæ•°+äºŒåˆ† import mathdef C(n, m): a, b = 1, 1 for i in range(1, min(m, n-m) + 1): a *= n n -= 1 b *= i return a // b # return math.comb(n, m) # python3.8def search(x): l = x r = max(x, n) while l r: mid = l + r 1 if C(mid, x // 2) n: l = mid + 1 else: r = mid return ln = int(input())for i in range(34, -1, -2): t = search(i) if C(t, i//2) == n: print(t * (t+1) // 2 + i//2 + 1) break æ—¶é—´æ˜¾ç¤ºfrom datetime import datetime, timedeltastamp = int(input())d = datetime(1970, 1, 1) + timedelta(milliseconds=stamp)print(d.strftime(%H:%M:%S)) è£çº¸åˆ€n, m = 20, 22print(4 + m - 1 + (n - 1) * m) è·¯å¾„import mathdp = [0] * 2022nums = [[float(inf)] * 2022 for _ in range(2022)]for i in range(1, 2022): for j in range(i+1, min(i+22, 2022)): d = math.gcd(i, j) nums[i][j] = d * i//d * j//ddp[1] = 0for i in range(2, 2022): t = float(inf) for j in range(min(i, 22)): t = min(t, dp[i-j] + nums[i-j][i]) dp[i] = tprint(dp[2021]) æ’åˆ—å­—æ¯s = list(input())s.sort()print(.join(s)) ç­”ç–‘n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key = lambda x:(x[0] + x[1] + x[2], x[0] + x[1]))res = last = 0for num in nums: res += last + num[0] + num[1] last += num[0] + num[1] + num[2]print(res) ç›´çº¿n, m = 20, 21res = set()for x1 in range(n): for y1 in range(m): for x2 in range(n): for y2 in range(m): if x1 == x2: continue k = (y2 - y1) / (x2 - x1) b = (x2 * y1 - x1 * y2) / (x2 - x1) res.add((k, b))print(len(res) + n) ç‰¹æ®Šæ—¥æœŸimport datetimestart = datetime.datetime(1900, 1, 1)end = datetime.datetime(9999, 12, 31)res = 0while start end: t = start.strftime(%Y %m %d) y, m, d = t.split() if sum(map(int, y)) == sum(map(int, m)) + sum(map(int, d)): res += 1 start += datetime.timedelta(days=1)print(res) çº¸å¼ å°ºå¯¸a, b = 1189, 841res = [(a, b )]for i in range(9): if a b: a, b = b, a a //= 2 res.append((b, a))s = int(input()[-1])print(res[s][0])print(res[s][1]) é’è›™è¿‡æ²³n, x = map(int, input().split())nums = list(map(int, input().split()))sums = [0] * nfor i in range(n - 1): sums[i + 1] = sums[i] + nums[i]def check(y): for i in range(n - y): if sums[i + y] - sums[i] 2 * x: return False return Truel, r = 1, nwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) å·¥ä½œæ—¶é•¿from datetime import datetimetmp = []with open(records.txt) as f: for line in f: tmp.append(datetime.strptime(line.strip(), %Y-%m-%d %H:%M:%S))tmp.sort()res = 0for i in range(0, len(tmp), 2): res += (tmp[i + 1] - tmp[i]).total_seconds()print(int(res)) æ±‚å’Œres = 0for i in range(1, 20230409): res += iprint(res) ç‰¹æ®Šæ—¶é—´def check(s): return s.count(1) == 3 or s.count(2) == 3tmp = [] #0111, 0222, 1011, 1101, 1110, 1112, 1121, 1222, 1211, 1113, 1114, 1115, 1116, 1117, 1118, 1119for i in range(1, 13): for j in range(1, 31): s = fi:02dj:02d if check(s): tmp.append(s)res = 4 * (4*9 + 3*3 + 2*4)print(res) æ•°ä½æ’åºn, m = int(input()), int(input())tmp = list(range(1, n + 1))tmp.sort(key=lambda x:sum([int(i) for i in str(x)]))print(tmp[m - 1]) æ‹¬å·åºåˆ—ï¼ï¼ï¼ å¤©å¹²åœ°æ”¯tiangan = [jia, yi, bing, ding, wu, ji, geng, xin, ren, gui]dizhi = [zi, chou, yin, mao, chen, si, wu, wei, shen, you, xu, hai]n = int(input()) + 56a, b = n % 10, n % 12print(ftiangan[a]dizhi[b]) é˜¶ä¹˜çš„å’Œn = int(input())nums = list(map(int, input().split()))nums.sort()res = nums[0]count = 0nex = nums[0] + 1while True: for num in nums: if num == res: count += 1 if count % nex == 0: count /= nex res = nex nex += 1 else: breakprint(res) åˆ†ç³–æœn, x = map(int, input().split())s = list(input())s.sort()if s[x - 1] != s[0]: print(s[x - 1])elif s[x] == s[-1]: print(s[x - 1], end = ) for i in range(x, n, x): print(s[i], end = )else: for i in s[x - 1: ]: print(i, end = ) å¹³é¢åˆ‡åˆ†n = int(input())nums = list(set([tuple(map(int, input().split())) for _ in range(n)]))res = 1 + len(nums)lines = []for k1, b1 in nums: point = set() for k2, b2 in lines: if k1 != k2: x = (b2 - b1) / (k1 - k2) y = (b1 *k2 - b2*k1) / (k2 - k1) point.add((x, y)) res += len(point) lines.append([k1, b1])print(res) å›è·¯è®¡æ•°def gcd(a, b): return a if b == 0 else gcd(b, a % b)n, state = 21, 1 21g = [[0] * (n + 1) for _ in range(n + 1)]dp = [[0] * (n + 1) for _ in range(state)]dp[1][0] = 1for i in range(n + 1): for j in range(n + 1): if gcd(i, j) == 1: g[i][j] = 1for i in range(state): for j in range(n): if i j 1: for k in range(n): if g[j + 1][k + 1] == 1 and i k 1: dp[i][j] += dp[i - (1 j)][k]print(sum(dp[-1]))# print(881012367360) ä¸‰å›½æ¸¸æˆn = int(input())X, Y, Z = list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))A = sorted([X[i] - Y[i] - Z[i] for i in range(n)], reverse=True)B = sorted([Y[i] - X[i] - Z[i] for i in range(n)], reverse=True)C = sorted([Z[i] - X[i] - Y[i] for i in range(n)], reverse=True)a = b = c = res = 0for i in range(n): a += A[i] b += B[i] c += C[i] if a 0 or b 0 or c 0: res += 1 else: breakprint(res if res else -1) å·¦å­©å­å³å…„å¼Ÿimport syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]for i in range(2, n + 1): t = int(input()) g[t].append(i)def dfs(u): if not g[u]: return 0 res = 0 for i in g[u]: res = max(res, dfs(i)) return len(g[u]) + resprint(dfs(1)) 2023res = 0def check(s): for i in range(8): if s[i] == 2 and i 5: for j in range(i+1, 8): if s[j] == 0 and j 6: for k in range(j+1, 8): if s[k] == 2 and k 7: for t in range(k+1, 8): if s[t] == 3 and t 8: return True return Falsefor s in range(12345678, 98765433): s = str(s) if 2 not in s or 0 not in s or 3 not in s: continue if check(s): res += 1print(98765433 - 12345678 - res)# print(85959030) ç¿»è½¬n = int(input())for _ in range(n): res = 0 t, s = list(input()), list(input()) m = len(s) if s[0] != t[0] or s[-1] != t[-1]: res = -1 else: for i in range(1, m-1): if s[i] != t[i]: if s[i] != s[i-1] and s[i] != s[i+1]: res += 1 else: res = -1 break print(res) 123ï¼ï¼ï¼æš´åŠ› t = int(input())nums = [0]for i in range(1, 3300): for j in range(1, i): nums.append(j)for i in range(1, len(nums)): nums[i] += nums[i - 1]for _ in range(t): a, b = map(int, input().split()) print(nums[b] - nums[a-1]) ï¼ï¼ï¼äºŒåˆ† maxn = 1414215s, a = [0] * maxn, [0] * maxnfor i in range(1, maxn): a[i] = a[i - 1] + i s[i] = s[i - 1] + a[i]def presum(x): l, r = 0, maxn while l r: mid = (l + r + 1) 1 if a[mid] x: r = mid - 1 else: l = mid return s[l] + a[x - a[l]]T = int(input())for _ in range(T): l, r = map(int, input().split()) print(presum(r) - presum(l - 1)) å¹³å‡n = int(input())nums = [[] for _ in range(10)]for _ in range(n): a, b = map(int, input().split()) nums[a].append(b)res = 0n = n // 10for i in range(10): nums[i] = sorted(nums[i]) res += sum(nums[i][:-n])print(res) å¡«å……s = input()judge = [00, 11, 0?, ?0, 1?, ?1, 11]i = res = 0while i len(s) - 1: if s[i: i + 2] in judge: i += 2 res += 1 else: i += 1print(res) é˜¶ä¹˜çº¦æ•°dicts = def divisor(x): for i in range(2, int(x ** 0.5) + 1): while x % i == 0: dicts[i] = dicts.get(i, 0) + 1 x //= i if x 1: dicts[x] = dicts.get(x, 0) + 1for i in range(1, 101): divisor(i)res = 1for i in dicts.values(): res *= i + 1print(res) å­æ ‘çš„å¤§å°T = int(input())for _ in range(T): n, m, k = map(int, input().split()) l = r = k res = tmp = 1 while r * m + 1 n: tmp *= m l = l * m - m + 2 r = r * m + 1 res += tmp l = l * m - m + 2 res += max(0, n - l + 1) print(res) ç¡¬å¸å…‘æ¢nums = [i for i in range(2024)] + [0] * 2023for i in range(1, 2024): nums[2 * i] += i // 2 for j in range(i + 1, 2024): nums[i + j] += iprint(max(nums)) ç©å…·è›‡dicts = [(1, 0), (-1, 0), (0, 1), (0, -1)]res = 0g = [[False] * 4 for _ in range(4)]def dfs(x, y, c): if c == 16: global res res += 1 return for i, j in dicts: a, b = x + i, y + j if 0 = a 4 and 0 = b 4 and not g[a][b]: g[a][b] = True dfs(a, b, c + 1) g[a][b] = Falsefor i in range(4): for j in range(4): g[i][j] = True dfs(i, j, 1) g[i][j] = Falseprint(res) å¯»æ‰¾æ•´æ•°# 11 * 17 = 187for i in range(187, 10**12, 187): if i % 49 == 46 and i % 48 == 41 and i % 47 == 5 and i % 46 == 15 and i % 45 == 29: print(i) # 5458460249 12590206409for i in range(5458460249, 10 ** 17, 7131746160): if i % 44 == 33 and i % 43 == 11 and i % 42 == 11 and i % 41 == 1 and i % 40 == 9 \\ and i % 39 == 23 and i % 38 == 37 and i % 37 == 22 and i % 36 == 29 and i % 35 == 4: print(i) åˆæ•°ä¸ªæ•°n = 2020state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n + 1, i): state[j] = Falseres = 0for i in range(1, n + 1): if state[i]: res += 1print(n - res) å¯»æ‰¾2020n = 300g = [input() for _ in range(n)]res = 0for i in range(n): for j in range(n - 3): if g[i][j: j + 4] == 2020: res += 1for i in range(n - 3): for j in range(n): if g[i][j] == 2 and g[i + 1][j] == 0 and g[i + 2][j] == 2 and g[i + 3][j] == 0: res += 1for i in range(n - 3): for j in range(n - 3): if g[i][j] == 2 and g[i + 1][j + 1] == 0 and g[i + 2][j + 2] == 2 and g[i + 3][j + 3] == 0: res += 1print(res) å­çŸ©é˜µï¼ï¼æš´åŠ›ï¼ˆ5 MOD = 998244353n, m, a, b = map(int, input().split())A = [list(map(int, input().split())) for _ in range(n)]def fun(c, d): x, y = float(-inf), float(inf) for i in range(a): for j in range(b): x = max(x, A[c + i][d + j]) y = min(y, A[c + i][d + j]) return (x * y) % MODres = 0for i in range(n - a + 1): for j in range(m - b + 1): res = (res + fun(i, j)) % MODprint(res) ç®¡é“n, m = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]def check(time): tmp = [] for i in range(n): if time nums[i][1]: l = max(1, nums[i][0] - time + nums[i][1]) r = min(m, nums[i][0] + time - nums[i][1]) tmp.append((l, r)) tmp.sort() if not tmp or tmp[0][0] 1: return False a = tmp[0][1] for l, r in tmp[1:]: if a + 1 l: return False else: a = max(a, r) return a == ml, r = 1, 1000000000while l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) å¼‚æˆ–æ•°åˆ—def init(n): cnt = 1 while n: if n 1: nums[cnt] += 1 n = 1 cnt += 1T = int(input())for _ in range(T): a = list(map(int, input().split())) n = a[0] nums = [0] * 23 s = 0 for i in range(1, n + 1): init(a[i]) s ^= a[i] if not s: print(0) else: for i in range(20, 0, -1): if nums[i] == 1: print(1) break elif nums[i] % 2 == 1: if n % 2 == 1: print(1) else: print(-1) break çº¯è´¨æ•°n = 20210605state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n, i): state[j] = Falseres = 0for i in range(2, n + 1): if state[i]: for char in str(i): if char not in 2357: res -= 1 break res += 1print(res) äº’è´¨æ•°çš„ä¸ªæ•°a, b = map(int, input().split())MOD = 998244353def qpow(a, b): res = 1 while b: if b 1: res = res * a % MOD b = 1 a = a * a % MOD return resdef euler(x): res = x for i in range(2, int(x ** 0.5) + 1): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x 1: res *= (1 - 1 / x) return int(res)print(qpow(a, b - 1) * euler(a) % MOD) æœ€é•¿ä¸ä¸‹é™å­åºåˆ—from bisect import bisect_rightn, k = map(int, input().split())nums = list(map(int, input().split()))interval = [0] * nres = []for i in range(n): idx = bisect_right(res, nums[i]) if idx = len(res): res.append(nums[i]) else: res[idx] = nums[i] interval[i] = 1maxl = tmp = sum(interval[:k])for i in range(1, n - k + 1): tmp = tmp + interval[i + k - 1] - interval[i - 1] maxl = max(tmp, maxl)print(len(res) + maxl) æ¾æ•£å­åºåˆ—s = list(map(lambda x: ord(x) - 96, list(input())))n = len(s)if n = 2: print(max(s))else: dp = [[0] * 2 for _ in range(n)] for i in range( n): dp[i][1] = max(dp[i - 2]) + s[i] dp[i][0] = max(dp[i - 1]) print(max(dp[-1])) å¥‡æ€ªçš„æ•°ï¼ï¼æš´åŠ›ï¼ˆ10%ï¼‰ def check(num): for i in range(len(num) - 4): if sum(int(s) for s in num[i: i + 5]) m: return False return Truen, m = map(int, input().split())if n 10: exit(0)res = 0for i in range(10 ** n): num = str(i).zfill(n) if all(int(s) % 2 == j % 2 for j, s in enumerate(num)): if check(num): res += 1print(res) å…¬å› æ•°åŒ¹é…ï¼ï¼æš´åŠ›ï¼ˆ33.3%ï¼‰ import sysdef gcd(a, b): return gcd(b, a % b) if b else an = int(input())nums = list(map(int, input().split()))for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) 1: print(i + 1, j + 1) sys.exit(0) æ±‚å› æ•°+å † import heapqfrom collections import defaultdictn = int(input())nums = list(map(int, input().split()))facts = defaultdict(list)for i, num in enumerate(nums): for j in range(2, int(num ** 0.5) + 1): if num % j == 0: heapq.heappush(facts[j], i + 1) heapq.heappush(facts[num // j], i + 1) heapq.heappush(facts[num], i + 1)l = r = float(inf)for v in facts.values(): if len(v) 1: if l v[0]: l = v[0] r = v[1] elif l == v[0]: r = min(r, v[1])print(l, r) ä¿é™©ç®±n = int(input())s = [0] + list(map(int, input()[::-1]))t = [0] + list(map(int, input()[::-1]))dp = [[0] * 3 for _ in range(n + 1)]dp[1][0] = abs(s[1] - t[1])dp[1][1] = -s[1] + 10 + t[1]dp[1][2] = s[1] + 10 - t[1]for i in range(2, n + 1): dp[i][0] = min(dp[i-1][0] + abs(s[i] - t[i]), dp[i-1][1] + abs(s[i] + 1 - t[i]), dp[i-1][2] + abs(s[i] - 1 - t[i])) dp[i][1] = min(dp[i-1][0] + 10 - s[i] + t[i], dp[i-1][1] + 9 - s[i] + t[i], dp[i-1][2] + 11 - s[i] + t[i]) dp[i][2] = min(dp[i-1][0] + 10 + s[i] - t[i], dp[i-1][1] + 11 + s[i] - t[i], dp[i-1][2] + 9 + s[i] - t[i])print(min(dp[n])) èœ‚å·¢d1, p1, q1, d2, p2, q2 = map(int, input().split())def fun(d, p, q): if d == 0: x = -p + q/2 y = q if d == 1: x = -p/2 + q y = p if d == 2: x = p/2 + q/2 y = p - q if d == 3: x = p - q/2 y = -q if d == 4: x = p/2 - q y = -p if d == 5: x = -p/2 - q/2 y = q - p return x, yx1, y1 = fun(d1, p1, q1)x2, y2 = fun(d2, p2, q2)a, b = abs(x1 - x2), abs(y1 - y2)if a b / 2: print(int(b))else: print(int(a + b - b // 2)) å¼‚æˆ–å’Œn, m = map(int, input().split())nums = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]for _ in range(n - 1): u, v = map(int, input().split()) if u v: u, v = v, u adj_list[u].append(v)def dfs(u): res = nums[u] for v in adj_list[u]: res ^= dfs(v) return res for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: nums[li[1]] = li[2] elif li[0] == 2: res = dfs(li[1]) print(res) æ£‹ç›˜ï¼ï¼æš´åŠ› n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): g[i][j] = 1 if g[i][j] == 0 else 0for i in range(1, n + 1): print(.join(map(str, g[i][1:]))) å·®åˆ†+å‰ç¼€å’Œ n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]diff = [[0] * (n + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += 1 diff[x2 + 1][y1] -= 1 diff[x1][y2 + 1] -= 1 diff[x2 + 1][y2 + 1] += 1for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) insert(x1, y1, x2, y2, 1)for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1] + diff[i][j]for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = 1 if g[i][j] % 2 else 0for i in range(1, n + 1): print(.join(map(str, g[i][1:]))) ç¾ä¸½çš„ 2n = 2020res = 0for i in range(1, n + 1): if 2 in str(i): res += 1print(res) æ•°çš„æ‹†åˆ†ï¼ï¼æš´åŠ›ï¼ˆ10%ï¼‰ T = int(input())nums = []for i in range(2, 10000): for j in range(2, 1000): if i ** j 1e9: break nums.append(i ** j)nums.sort()def check(a): if a in nums: return yes else: for num in nums: if a num: return no if a % num == 0 and a // num in nums: return yes return nofor _ in range(T): a = int(input()) print(check(a)) æ•°å­¦ status = [True] * 4001primes = []def is_square(x): n = round(x ** 0.5) return n * n == xdef is_cubic(x): n = round(x ** (1/3)) return n * n * n == xfor i in range(2, 4001): if status[i]: primes.append(i) for j in range(2 * i, 4001, i): status[j] = Falsedef check(a): flag = True for prime in primes: if a % prime == 0: t = 0 while a % prime == 0: a //= prime t += 1 if t == 1: flag = False if flag and (is_square(a) or is_cubic(a)): print(yes) else: print(no)T = int(input())for _ in range(T): a = int(input()) if is_square(a) or is_cubic(a): print(yes) else: check(a) å¤§å†™s = input()print(s.upper()) é‡æ–°æ’åºn = int(input())nums = list(map(int, input().split()))diff = [0] * (n + 2)m = int(input())for _ in range(m): l, r = map(int, input().split()) diff[l] += 1 diff[r + 1] -= 1tmps = [0] * (n + 1)for i in range(1, n + 1): tmps[i] = tmps[i - 1] + diff[i]res1 = res2 = 0for i in range(n): res1 += nums[i] * tmps[i + 1]nums.sort(reverse = True)tmps.sort(reverse = True)for i in range(n): res2 += nums[i] * tmps[i]print(res2 - res1) æ¶ˆé™¤æ¸¸æˆï¼ï¼æš´åŠ›ï¼ˆ58.3%ï¼‰ s = list(input())for _ in range(10000): n = len(s) state = [True] * n for i in range(1, n - 1): if s[i] == s[i - 1] and s[i] != s[i + 1]: state[i] = state[i + 1] = 0 elif s[i] != s[i - 1] and s[i] == s[i + 1]: state[i] = state[i - 1] = 0 s = [s[i] for i in range(n) if state[i]] if len(s) == n: breakif s: print(.join(map(str, s)))else: print(EMPTY) æŠ€èƒ½å‡çº§ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ n, m = map(int, input().split())nums = []for _ in range(n): a, b = map(int, input().split()) while a 0: nums.append(a) a -= bnums.sort(reverse=True)print(sum(nums[:m])) äºŒåˆ† n, m = map(int, input().split())a, b = [], []for i in range(n): x, y = map(int, input().split()) a.append(x) b.append(y)def check(x): cnt = 0 for i in range(n): if a[i] x: continue cnt += (a[i] - x) // b[i] + 1 if cnt = m: return True return Falsel, r = 0, 1000000while l = r: mid = l + r 1 if check(mid): l = mid + 1 else: r = mid - 1res = 0surplus = mfor i in range(n): if a[i] r: continue t = (a[i] - l) // b[i] + 1 if a[i] - (t - 1) * b[i] == r: t -= 1 res += t * a[i] - t * (t - 1) * b[i] // 2 surplus -= tprint(res + surplus * r) è´¨å› æ•°ä¸ªæ•°ï¼ï¼æš´åŠ›ï¼ˆ80%ï¼‰ n = int(input())primes = []state = [True] * 5000001for i in range(2, 5000001): if state[i]: primes.append(i) for j in range(2 * i, 5000001, i): state[j] = Falseres = 0for prime in primes: if n % prime == 0: res += 1print(res) ï¼ï¼æ•°å­¦ä¼˜åŒ–ï¼ˆ90%ï¼‰ n = int(input())res = 0i = 2while i * i n: if n % i == 0: res += 1 while n % i == 0: n //= i i += 1 if n 1: res += 1print(res) å…¨æ’åˆ—çš„ä»·å€¼n = int(input())nums = [0] + [0] * nMOD = 998244353 fac, sum1 = [1] * (n + 1), [1] * (n + 1)for i in range(2, n + 1): fac[i] = fac[i - 1] * i % MOD sum1[i] = sum1[i - 1] + i % MODfor i in range(2, n + 1): nums[i] = (i * nums[i - 1] + fac[i - 1] * sum1[i - 1]) % MODprint(nums[n]) æ··ä¹±çš„æ•°ç»„n = int(input())if n == 10: print(5) print(5 4 3 2 1)elif n == 9: print(5) print(4 3 2 1 1)elif n == 8: print(5) print(3 2 2 1 1)elif n == 7: print(5) print(3 2 1 1 1)elif n == 6: print(4) print(4 3 2 1)elif n == 5: print(4) print(3 2 1 1)elif n == 4: print(4) print(2 2 1 1)elif n == 3: print(3) print(3 2 1)elif n == 2: print(3) print(2 1 1)elif n == 1: print(2) print(2 1)else: for i in range(100): if i * (i - 1) // 2 == n: print(i) print(*range(i, 0, -1)) å®Œå…¨æ—¥æœŸfrom datetime import datetime, timedeltastart = datetime(2001, 1, 1)end = datetime(2021, 12, 31)res = 0while start = end: t = start.strftime(%Y%m%d) a = sum([int(i) for i in t]) if a in [4, 9, 16, 25, 36]: res += 1 start += timedelta(days=1)print(res) å¸¦å®½print(200 // 8) å°è“çš„æ—…è¡Œè®¡åˆ’import heapq, sysn, m = map(int, input().split())left = [0]oils = [0] * (n + 1)oils[0] = mcost = []consume = 0for i in range(1, n + 1): a, b, c = map(int, input().split()) left.append(c) if a m: print(-1) sys.exit(0) if oils[i - 1] a: while cost and oils[i - 1] a: price, idx = cost[0] maxadd = min(left[idx], m - oils[i - 1]) if maxadd = a - oils[i - 1]: maxadd = a - oils[i - 1] consume += price * maxadd oils[i - 1] += maxadd left[idx] -= maxadd if left[idx] == 0: heapq.heappop(cost) if oils[i - 1] a: print(-1) sys.exit(0) heapq.heappush(cost, (b, i)) oils[i] = oils[i - 1] - aprint(consume) æ–æ³¢é‚£å¥‘ä¸7# 14, 16, 17, 23, 34, 37, 43, 56 ä»14å¼€å§‹ï¼Œ60ä¸ªå¾ªç¯ï¼Œ# (202202011200 - 14) % 60 = 46print((202202011200 - 14) // 60 * 8 + 8) GCDï¼ï¼æš´åŠ›ï¼ˆ20%ï¼‰ def gcd(a, b): return gcd(b, a % b) if b else aa, b = map(int, input().split())res = 1maxgcd = 0for i in range(1, 1000000): t = gcd(a + i, b + i) if t maxgcd: res = i maxgcd = tprint(res) ï¼ï¼æ•°å­¦ a, b = map(int, input().split())if a b: a, b = b, ac = b - aif c a: c = (a // c + 1) * ck = c - aprint(k) æœ€å°æƒå€¼dp = [float(inf)] * 2022dp[0] = 0for i in range(1, 2022): for j in range(i): l, r = j, i - j - 1 dp[i] = min(dp[i], 1 + 2 * dp[l] + 3 * dp[r] + l * l * r)print(dp[2021]) äºŒè¿›åˆ¶é—®é¢˜ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ n, k = map(int, input().split())def check(x): cnt = 0 while x: if x 1: cnt += 1 x = 1 return cnt == kres = 0for i in range(1, n + 1): if check(i): res += 1print(res) æœ€ä¼˜æ¸…é›¶æ–¹æ¡ˆï¼ï¼æš´åŠ›ï¼ˆ60%ï¼‰ n, k = map(int, input().split())nums = list(map(int, input().split()))res = 0for _ in range(1000): for i in range(n - k + 1): a = min(nums[i: i + k]) if a: for j in range(i, i + k): nums[j] -= a res += a else: res += nums[i] nums[i] = 0 if all(nums): break for i in range(n - k + 1, n): res += nums[i] nums[i] = 0print(res) ï¼ï¼ä¼˜åŒ– n, k = map(int, input().split())nums = list(map(int, input().split()))idx =res = 0while idx + k - 1 n: mint = min(nums[idx: idx + k]) imint = nums[idx: idx + k].index(mint) if mint 0: for j in range(idx, idx + k): nums[j] -= mint res += mint idx += imint + 1res += sum(nums)print(res) æœ¬è´¨ä¸Šå‡åºåˆ—ï¼ï¼æš´åŠ› s = tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwln = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) ï¼ï¼åŠ¨æ€è§„åˆ’ s = tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwln = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) çŸ©å½¢æ‹¼æ¥T = int(input())def check4(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j == k: return True if i == j and a1 + b1 + a2 + b2 - i - j == k: return True if i == k and a1 + b1 + a3 + b3 - i - k == j: return True if j == k and a2 + b2 + a3 + b3 - j - k == i: return True return Falsedef check6(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j or j == k or i == k: return True if i + j == k or i + k == j or j + k == i: return Truefor _ in range(T): a1, b1, a2, b2, a3, b3 = map(int, input().split()) if check4(a1, b1, a2, b2, a3, b3): print(4) elif check6(a1, b1, a2, b2, a3, b3): print(6) else: print(8) é‡å¤å­—ç¬¦ä¸²k = int(input())s = input()nums = []res = 0if len(s) % k: print(-1)else: n = len(s) // k for i in range(0, len(s), n): nums.append(s[i: i + n]) a = [[0] * 27 for _ in range(n)] for i in range(n): for j in range(k): a[i][ord(nums[j][i]) - 97] += 1 for i in a: res += sum(i) - max(i) print(res) å°è“åšå®éªŒn = 100000000state = [True] * (n + 1)def check(x): for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return Truefor i in range(2, n + 1): if state[i]: for i in range(i * 2, n + 1, i): state[i] = Falseres = 0with open(primes_2.txt) as f: for i in f.readlines(): i = int(i.strip( )) if i 1e8: if check(i): res += 1 else: if state[i]: res += 1print(res)print(342693) è¿‘ä¼¼gcddef gcd(a, b): return gcd(b, a % b) if b else an, g = map(int, input().split())nums = list(map(int, input().split()))l = r = res = 0t = -1for r in range(n): a = gcd(g, nums[r]) if a != g: l = t + 1 t = r if r - l + 1 = 2: res += r - lprint(res) ç¯å¢ƒæ²»ç†n, q = map(int, input().split())D = [list(map(int, input().split())) for _ in range(n)]L = [list(map(int, input().split())) for _ in range(n)]def check(mid): g = [[D[i][j] for j in range(n)] for i in range(n)] circle, remain = mid // n, mid % n for i in range(n): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - circle) for i in range(remain): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - 1) for k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[k][j]) p = sum([sum(i) for i in g]) return p = ql, r = 0, 10000000while l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l if l 10000000 else -1) å–æ¨¡ï¼ï¼æš´åŠ›ï¼ˆ35%ï¼‰ T = int(input())def check(n, m): for x in range(1, m): for y in range(x + 1, m + 1): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) ï¼ï¼æš´åŠ›æ¢ä¸ªé¡ºåºå°±å…¨é€šè¿‡äº† T = int(input())def check(n, m): for y in range(2, m + 1): for x in range(1, y): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) ï¼ï¼åè¯æ³• import sysT = int(input())def check(n, m): for i in range(1, m + 1): if n % i != i - 1: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) å’Œä¸ä¹˜ç§¯ï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ n = int(input())nums = list(map(int, input().split()))muls, sums = [1] * (n + 1), [0] * (n + 1)for i in range(1, n + 1): muls[i] = muls[i - 1] * nums[i - 1] sums[i] = sums[i - 1] + nums[i - 1]res = 0for r in range(1, n + 1): for l in range(1, i + 1): if sums[r] - sums[l - 1] == muls[r] // muls[l - 1]: res += 1print(res) ï¼ï¼ä¼˜åŒ–â€“å¤„ç†è¿ç»­çš„1 n = int(input())nums = list(map(int, input().split()))res = cnt = 0preone = [0] * (n) # å‰é¢æœ‰å¤šå°‘ä¸ª1for i in range(n): preone[i] = cnt if nums[i] == 1: cnt += 1 else: cnt = 0for r in range(n): he, ji = 0, 1 l = r while l = 0: he += nums[l] ji *= nums[l] if he == ji: res += 1 if ji - he l: break if preone[l] == 0: l -= 1 continue if ji = he: he += preone[l] else: he += preone[l] if ji = he: res += 1 l -= preone[l] l -= 1print(res) æ›¿æ¢å­—ç¬¦ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ s = list(input())n = len(s)m = int(input())for _ in range(m): l, r, x, y = input().split() for i in range(int(l), int(r) + 1): if s[i - 1] == x: s[i - 1] = yprint(.join(map(str, s))) ï¼ï¼ç”¨replaceæ–¹æ³• s = input()m = int(input())for _ in range(m): l, r, x, y = input().split() l, r = int(l), int(r) s1 = s[: l - 1] s2 = s[l - 1: r] s2 = s2.replace(x, y) s3 = s[r:] s = s1 + s2 + s3print(s) æ‰“æŠ˜ï¼ï¼æš´åŠ›ï¼ˆ40%ï¼‰ n, m = map(int, input().split())nums = [[float(inf)] * (n + 1) for _ in range(1001)]for _ in range(m): s, t, p, c = map(int, input().split()) tmps = [] for _ in range(c): a, b = map(int, input().split()) tmps.append((a, b * p // 100, b)) for i in range(1, 1001): for tmp in tmps: if s = i = t: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[1]) else: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[2])res = float(inf)for num in nums: res = min(res, sum(num[1:]))print(res) ç¿»è½¬æ‹¬å·åºåˆ—n, m = map(int, input().split())s = input()nums = [0] * nfor i in range(n): if s[i] == (: nums[i] = 1 else: nums[i] = -1for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: l, r = int(li[1]), int(li[2]) for i in range(l - 1, r): nums[i] *= -1 if li[0] == 2: l = int(li[1]) - 1 res = t = 0 for i in range(l, n): t += nums[i] if t 0: break elif t == 0: res = i + 1 print(res) æ–æ³¢é‚£å¥‘æ•°ç»„n = int(input())fib = [1, 1]res = 0nums = list(map(int, input().split()))dic = for i in range(2, 30): fib.append(fib[i - 1] + fib[i - 2])for i in range(n): if i = 30: res += 1 else: dic[nums[i] / fib[i]] = dic.get(nums[i] / fib[i], 0) + 1print(res + min(30, n) - max(dic.values())) æœ€å°‘çš„1ï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ def fun(x): cnt = 0 while x: if x 1: cnt += 1 x = 1 return cntn = int(input())res = float(inf)for i in range(2, 1000): cnt = fun(n) n *= i res = min(res, cnt)print(res) å†°å±±ï¼ï¼æš´åŠ›ï¼ˆ80%ï¼‰ n, m, k = map(int, input().split())nums = a = list(map(int, input().split()))for i in a: nums[i] = nums.get(i, 0) + 1MOD = 998244353for _ in range(m): x, y = map(int, input().split()) nums = k + x: v for k, v in nums.items() if k + x 0 for key, value in nums.copy().items(): if key k: del nums[key] nums[k] = (nums.get(k, 0) + value) % MOD nums[1] = (nums.get(1, 0) +(key - k) * value) % MOD if y: nums[y] = nums.get(y, 0) + 1 res = 0 for key, value in nums.items(): res = (res + key * value) % MOD print(res) å…­å…­å¤§é¡ºï¼ï¼æš´åŠ›ï¼ˆ30%ï¼‰ n = int(input())res = 0for i in range(n): t = i * 4 + 3 + i * 5 + 6 res += int(t)print(res) è¡¥ç»™n, d = map(int, input().split())g = [[0] * n for _ in range(n)]p = [list(map(int, input().split())) for _ in range(n)]for i in range(n): for j in range(i + 1, n): t = ((p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2) ** 0.5 if t d: g[i][j] = g[j][i] = float(inf) else: g[i][j] = g[j][i] = t# floydfor k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[j][k])f = [[float(inf)] * n for j in range(1 n)]f[1][0] = 0for j in range(1, 1 n): for i in range(n): if (j i) 1: for k in range(n): if k != i and (j k) 1: f[j][i] = min(f[j][i], f[j - (1 i)][k] + g[k][i])res = min(f[(1 n) - 1][i] + g[i][0] for i in range(n))print(fres:.2f) åˆ†çŸ³å¤´t=int(input())def is_prime(i): count=0 j=3 while 1: if(i%j==0): count+=1 i//=j j=2 j+=1 if(i==1):break if(j*j=i): if(j*j==i): count+=1 count+=1 break return count%2for _ in range(t): n=int(input()) a=list(map(int,input().split())) ou=0;ji=0 s=0 for i in a: while i%2==0: i//=2 if(is_prime(i)==0): ou+=1 else:ji+=1 # å¦‚æœçŸ³å­å †æ•°æ˜¯å¥‡æ•°ï¼Œæˆ–è€…è´¨æ•°çš„æ•°é‡æ˜¯å¥‡æ•°ï¼Œåˆ™å°è“æœ‰å¿…èƒœç­–ç•¥ if(len(a)%2==1 or ji%2==1): print(1) else: print(0) æ³¨æ„äºŒåˆ†æ‰¾å·¦è¾¹ç•Œl=mid+1,æ‰¾å³è¾¹ç•Œr=mid-1ï¼Œå¹¶ä¸”mid=l+r+11","tags":["ç®—æ³•","Python","è“æ¡¥æ¯"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯è¾…å¯¼è¯¾","path":"/2024/03/29/è“æ¡¥æ¯è¾…å¯¼è¯¾/","content":"é€’å½’ä¸é€’æ¨é€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾92. é€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾ n = int(input())st = []def dfs(u): if u == n + 1: print( .join(map(str, st))) return dfs(u + 1) st.append(u) dfs(u + 1) st.pop()dfs(1) é€’å½’å®ç°æ’åˆ—å‹æšä¸¾94. é€’å½’å®ç°æ’åˆ—å‹æšä¸¾ n = int(input())st = [0] * (n + 1)used = [False] * (n + 1)def dfs(u): if u == n + 1: print( .join(map(str, st[1:]))) return for i in range(1, n + 1): if not used[i]: st[u] = i used[i] = True dfs(u + 1) used[i] = Falsedfs(1) é€’å½’å®ç°ç»„åˆå‹æšä¸¾93. é€’å½’å®ç°ç»„åˆå‹æšä¸¾ n, m = map(int, input().split())st = [0] * (m + 1)def dfs(u, start): if n + u - start m: return if u == m + 1: print( .join(map(str, st[1:]))) return for i in range(start, n + 1): st[u] = i dfs(u + 1, i + 1)dfs(1, 1) å¸¦åˆ†æ•°1209. å¸¦åˆ†æ•° n = int(input())st = [0] * 10res = 0def check(a, c): b = n * c - a * c nums = set(123456789) return set(str(a) + str(b) + str(c)) == numsdef dfs_c(u, a, c): b = n * c - a * c if len(str(a) + str(b) + str(c)) 9: return global res res += check(a, c) for i in range(1, 10): if not st[i]: st[i] = True dfs_c(u + 1, a, c * 10 + i) st[i] = Falsedef dfs_a(u, a): if a = n: return dfs_c(u, a, 0) for i in range(1, 10): if not st[i]: st[i] = True dfs_a(u + 1, a * 10 + i) st[i] = Falsedfs_a(0, 0)print(res) ç®€å•æ–æ³¢é‚£å¥‘717. ç®€å•æ–æ³¢é‚£å¥‘ n = int(input())nums = [0, 1] + [0] * nfor i in range(2, n + 1): nums[i] = nums[i - 1] + nums[i - 2]print( .join(map(str, nums[:n]))) è´¹è§£çš„å¼€å…³95. è´¹è§£çš„å¼€å…³ t = int(input())dirs = [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]def turn(a, b): for i in range(5): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x 5 and 0 = y 5: g[x][y] = 1 if g[x][y] == 0 else 0for idx in range(t): g = [list(input()) for _ in range(5)] if idx t - 1: input() res = 10 tmp = [i[:] for i in g] for x in range(32): stp = 0 for i in range(5): if x i 1: turn(0, i) stp += 1 for i in range(4): for j in range(5): if g[i][j] == 0: turn(i + 1, j) stp +=1 if 0 not in g[4]: res = min(res, stp) g = [i[:] for i in tmp] print(-1 if res 6 else res) ç¿»ç¡¬å¸1208. ç¿»ç¡¬å¸ a, b = list(input()), list(input())res = 0for i in range(len(a) - 1): if a[i] != b[i]: a[i+1] = o if a[i+1] == * else * res += 1print(res) é£è¡Œå‘˜å…„å¼Ÿ116. é£è¡Œå‘˜å…„å¼Ÿ g = [list(input()) for _ in range(4)]res = []def turn(x, y): backup[x][y] = - if backup[x][y] == + else +def turn_all(x, y): for i in range(4): turn(x, i) turn(i, y) turn(x, y)for x in range(1 16): tmp = [] backup = [i[:] for i in g] for i in range(4): for j in range(4): if x (4 * i + j) 1: turn_all(i, j) tmp.append((i+1, j+1)) if not any(+ in i for i in backup): if len(res) len(tmp): res = [i[:] for i in tmp]print(len(res))for i in res: print(i[0], i[1]) äºŒåˆ†ä¸å‰ç¼€å’Œæ•°çš„èŒƒå›´789. æ•°çš„èŒƒå›´ n, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l, r = 0, n - 1 while l r: mid = l + r 1 if nums[mid] = k: r = mid else: l = mid + 1 if nums[l] == k: print(l, end= ) r = n - 1 while l r: mid = l + r + 1 1 if nums[mid] = k: l = mid else: r = mid - 1 if nums[l] == k: print(l) else: print(-1, -1) bisect import bisectn, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l = bisect.bisect_left(nums, k) r = bisect.bisect_right(nums, k) if l != r: print(l, r - 1) else: print(-1, -1) æ•°çš„ä¸‰æ¬¡æ–¹æ ¹790. æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ n = float(input())l, r = -10000, 10000while r - l 1e-8: mid = (l + r) / 2 if mid * mid * mid = n: l = mid else: r = midprint(fl:.6f) æœºå™¨äººè·³è·ƒé—®é¢˜730. æœºå™¨äººè·³è·ƒé—®é¢˜ n = int(input())nums = list(map(int, input().split()))h = max(nums)def check(e): for num in nums: e = 2 * e - num if e h: return True elif e 0: return False return Truel, r = 0, hwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) å››å¹³æ–¹å’Œ1221. å››å¹³æ–¹å’Œ æš´åŠ› import mathn = int(input())def fun(): for i in range(int((n/4) ** 0.5) + 1): for j in range(i, int(((n - i*i) / 3) ** 0.5) + 1): for k in range(j, int(((n - i*i - j*j) / 2) ** 0.5) + 1): l = int(math.sqrt(n - i*i - j*j - k*k)) if i*i + j*j + k*k + l*l == n: return i, j, k, lprint(*fun()) å“ˆå¸Œè¡¨ n = int(input())dic = for c in range(int(n ** 0.5) + 1): for d in range(int((n - c*c) ** 0.5) + 1): t = c*c + d*d if t not in dic: dic[t] = (c, d)for a in range(int(n ** 0.5) + 1): for b in range(int((n - a*a) ** 0.5) + 1): t = n - a*a - b*b if t in dic: print(a, b, dic[t][0], dic[t][1]) exit() åˆ†å·§å…‹åŠ›1227. åˆ†å·§å…‹åŠ› n, k = map(int, input().split())chocolates = [list(map(int, input().split())) for _ in range(n)]def check(x): t = 0 for chocolate in chocolates: t += (chocolate[0] // x) * (chocolate[1] // x) if t = k: return True return Falsel, r = 1, 100000while l r: mid = l + r + 1 1 if check(mid): l = mid else: r = mid - 1print(l) å‰ç¼€å’Œ795. å‰ç¼€å’Œ n, m = map(int, input().split())nums = list(map(int, input().split()))sums = [0] + nums[:]for i in range(1, n+1): sums[i] += sums[i-1]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l-1]) å­çŸ©é˜µçš„å’Œ796. å­çŸ©é˜µçš„å’Œ from sys import stdininput = lambda: stdin.readline().strip()n, m, q = map(int, input().split())nums = [[0] * (m+1)] + [[0] + list(map(int, input().split())) for _ in range(n)]sums = [num[:] for num in nums]for i in range(1, n+1): for j in range(1, m+1): sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1-1][y2] - sums[x2][y1-1] + sums[x1-1][y1-1]) æ¿€å…‰ç‚¸å¼¹99. æ¿€å…‰ç‚¸å¼¹ - AcWingé¢˜ cnt, r = map(int, input().split())values = [[0] * 5002 for _ in range(5002)]r = min(r, 5001)n = m = rfor _ in range(cnt): x, y, w = map(int, input().split()) x += 1 y += 1 n, m = max(n, x), max(m, y) values[x][y] += wfor i in range(1, n+1): for j in range(1, m+1): values[i][j] += values[i-1][j] + values[i][j-1] - values[i-1][j-1]res = 0for i in range(r, n+1): for j in range(r, m+1): t = values[i][j] - values[i-r][j] - values[i][j-r] + values[i-r][j-r] res = max(res, t)print(res) Kå€åŒºé—´1230. Kå€åŒºé—´ n, k = map(int, input().split())sums = [0] + [int(input()) for _ in range(n)]for i in range(1, n+1): sums[i] += sums[i-1]cnt = [0] * (n+1)res = 0for i in range(n+1): res += cnt[sums[i] % k] cnt[sums[i] % k] += 1print(res) æ•°å­¦ä¸ç®€å•DPä¹°ä¸åˆ°çš„æ•°ç›®AcWing 1205. ä¹°ä¸åˆ°çš„æ•°ç›® æš´åŠ› n, m = map(int, input().split())def check(i, n, m): if not i: return True if i = n and check(i-n, n, m): return True if i = m and check(i-m, n, m): return True return Falseres = 0for i in range(1, 1000): if not check(i, n, m): res = iprint(res) ä¼˜åŒ– n, m = map(int, input().split())dp = [False] * (1000001)dp[0] = Truefor i in range(1, 1000001): if i = m: dp[i] |= dp[i-m] if i = n: dp[i] |= dp[i-n]res = 0for i in range(1, 1000001): if not dp[i]: res = iprint(res) å…¬å¼ n, m = map(int, input().split())print((n-1) * (m-1) - 1) èš‚èšæ„Ÿå†’1211. èš‚èšæ„Ÿå†’ n = int(input())nums = list(map(int, input().split()))left = right = 0for i in range(1, n): if abs(nums[0]) abs(nums[i]) and nums[i] 0: left += 1 elif abs(nums[0]) abs(nums[i]) and nums[i] 0: right += 1if nums[0] 0 and not right or nums[0] 0 and not left: print(1)else: print(1 + left + right) é¥®æ–™æ¢è´­1216. é¥®æ–™æ¢è´­ n = int(input())res = nwhile n 2: res += n // 3 n = n // 3 + n % 3print(res) èƒŒåŒ…é—®é¢˜2. 01èƒŒåŒ…é—®é¢˜ n, v = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0] * (v+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(1, v+1): dp[i][j] = dp[i-1][j] if j = nums[i-1][0]: dp[i][j] = max(dp[i][j], dp[i-1][j-nums[i-1][0]] + nums[i-1][1])print(dp[n][v]) æ‘˜èŠ±ç”Ÿ1015. æ‘˜èŠ±ç”Ÿ t = int(input())for _ in range(t): r, c = map(int, input().split()) g = [list(map(int, input().split())) for _ in range(r)] dp = [[0] * (c+1) for _ in range(r+1)] for i in range(1, r+1): for j in range(1, c+1): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + g[i-1][j-1] print(dp[i][j]) æœ€é•¿ä¸Šå‡å­åºåˆ—895. æœ€é•¿ä¸Šå‡å­åºåˆ— n = int(input())nums = [0] + list(map(int, input().split()))dp = [1] * (n+1)for i in range(1, n+1): for j in range(1, i): if nums[i] nums[j]: dp[i] = max(dp[i], dp[j] + 1)print(max(dp)) åœ°å®«å–å®1212. åœ°å®«å–å® n, m, k = map(int, input().split())MOD = 1000000007g = [[0] * (m+1)] + [[0] + list(map(lambda x: int(x) + 1, input().split())) for _ in range(n)]dp = [[[[0] * 14 for _ in range(k+1)] for _ in range(m+1)] for _ in range(n+1)]dp[1][1][1][g[1][1]] = 1dp[1][1][0][0] = 1for i in range(1, n+1): for j in range(1, m+1): if i == 1 and j == 1: continue for u in range(k+1): for v in range(14): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u][v] + dp[i][j-1][u][v]) % MOD if u 0 and v == g[i][j]: for t in range(v): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u-1][t] + dp[i][j-1][u-1][t])print(sum(dp[i][j][k]) % MOD) æ³¢åŠ¨æ•°åˆ—1214. æ³¢åŠ¨æ•°åˆ— n, s, a, b = map(int, input().split())dp = [[0] * n for _ in range(n)]dp[0][0] = 1MOD = 100000007for i in range(1, n): for j in range(n): dp[i][j] = (dp[i-1][(j-i*a) % n] + dp[i-1][(j+i*b) % n]) % MODprint(dp[n-1][s%n]) æšä¸¾ã€æ¨¡æ‹Ÿä¸æ’åºè¿å·åŒºé—´æ•°1210. è¿å·åŒºé—´æ•° n = int(input())nums = list(map(int, input().split()))res = 0for i in range(n): minv, maxv = float(inf), float(-inf) for j in range(i, n): minv = min(minv, nums[j]) maxv = max(maxv, nums[j]) if maxv - minv == j - i: res += 1print(res) é€’å¢ä¸‰å…ƒç»„1236. é€’å¢ä¸‰å…ƒç»„ å‰ç¼€å’Œ n = int(input())a = list(map(lambda x: int(x) + 1, input().split()))b = list(map(lambda x: int(x) + 1, input().split()))c = list(map(lambda x: int(x) + 1, input().split()))cnta, cntc, suma, sumc = [0] * 100002, [0] * 100002, [0] * 100002, [0] * 100002for i in range(n): cnta[a[i]] += 1for i in range(1, 100002): suma[i] = suma[i-1] + cnta[i]for i in range(n): cntc[c[i]] += 1for i in range(1, 100002): sumc[i] = sumc[i-1] + cntc[i]res = 0for i in b: res += suma[i-1] * (n - sumc[i])print(res) äºŒåˆ† import bisectn = int(input())a = list(map(int, input().split()))b = list(map(int, input().split()))c = list(map(int, input().split()))a.sort()c.sort()res = 0for i in b: l = bisect.bisect_left(a, i) r = bisect.bisect_right(c, i) res += l * (n-r)print(res) ç‰¹åˆ«æ•°çš„å’Œ1245. ç‰¹åˆ«æ•°çš„å’Œ n = int(input())res = 0for i in range(1, n+1): if 0 in str(i) or 1 in str(i) or 2 in str(i) or 9 in str(i): res += iprint(res) é”™è¯¯ç¥¨æ®1204. é”™è¯¯ç¥¨æ® n = int(input())nums = []for _ in range(n): nums.extend(map(int, input().split()))nums.sort()a = b = 0for i in range(1, len(nums)): if nums[i] == nums[i-1] + 2: a = nums[i] - 1 elif nums[i] == nums[i-1]: b = nums[i]print(a, b) å›æ–‡æ—¥æœŸ466. å›æ–‡æ—¥æœŸ date1, date2 = input(), input()days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]rev = [92200229]for i in range(1, 13): for j in range(1, days[i] + 1): t = fi:02dj:02d rev.append(t[::-1] + t)res = 0for i in rev: if date1 = i = date2: res += 1print(res) ç§»åŠ¨è·ç¦»1219. ç§»åŠ¨è·ç¦» w, m, n = map(int, input().split())m, n = m - 1, n - 1x1, x2 = m // w, n // wy1, y2 = m % w, n % wif x1 % 2: y1 = w - 1 - y1if x2 % 2: y2 = w - 1 - y2print(abs(x1 - x2) + abs(y1 - y2)) æ—¥æœŸé—®é¢˜1229. æ—¥æœŸé—®é¢˜ from time import strptimel, r, s = 1960-01-01, 2059-12-31, input().split(/)res = []def check(date): if l = date = r: try: strptime(date, %Y-%m-%d) res.append(date) except: passfor i in [19, 20]: check(i + s[0] + - + s[1] + - + s[2]) check(i + s[2] + - + s[1] + - + s[0]) check(i + s[2] + - + s[0] + - + s[1])res.sort()for i in set(res): print(i) èˆªç­æ—¶é—´1231. èˆªç­æ—¶é—´ t = int(input())for _ in range(t): res = 0 for _ in range(2): a = input().split() for i in range(len(a)): if i == 2: res += int(a[2][2]) * 24 * 3600 else: b = list(map(int, a[i].split(:))) res += (-1) ** (i+1) * (b[0] * 3600 + b[1] * 60 + b[2]) res //= 2 print(fres // 3600:02d:res % 3600 // 60:02d:res % 60:02d) å¤–å–åº—ä¼˜å…ˆçº§1241. å¤–å–åº—ä¼˜å…ˆçº§ n, m, t = map(int, input().split())a, st, last = [0] * (n+1), [0] * (n+1), [0] * (n+1)b = [list(map(int, input().split())) for _ in range(m)]b.sort()for i, j in b: a[j] = max(0, a[j] - max(0, i - last[j] - 1)) if a[j] = 3: st[j] = 0 a[j], last[j] = a[j] + 2, i if a[j] 5: st[j] = 1for i in range(1, n+1): a[i] = max(0, a[i] - t + last[i]) if a[i] = 3: st[i] = 0print(sum(st)) å½’å¹¶æ’åº787. å½’å¹¶æ’åº n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return mid = l + r 1 merge_sort(l, mid) merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmpmerge_sort(0, n - 1)print(*nums) é€†åºå¯¹çš„æ•°é‡788. é€†åºå¯¹çš„æ•°é‡ n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return 0 mid = l + r 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) æ ‘çŠ¶æ•°ç»„ä¸çº¿æ®µæ ‘åŠ¨æ€æ±‚è¿ç»­åŒºé—´å’Œæ ‘çŠ¶æ•°ç»„ 1264. åŠ¨æ€æ±‚è¿ç»­åŒºé—´å’Œ n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [0] * (n+1)def lowbit(x): return x -xdef add(x, v): while x = n: tree[x] += v x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return resfor i in range(1, n+1): add(i, nums[i])for _ in range(m): k, a, b = map(int, input().split()) if k: add(a, b) else: print(query(b) - query(a-1)) çº¿æ®µæ ‘ n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): tree[u][2] = tree[u 1][2] + tree[u 1 | 1][2]def build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r 1 build(u 1, l, mid) build(u 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] = l and tree[u][1] = r: return tree[u][2] mid = tree[u][0] + tree[u][1] 1 res = 0 if l = mid: res += query(u 1, l, r) if r mid: res += query(u 1 | 1, l, r) return resdef modify(u, x, v): if tree[u][0] == tree[u][1]: tree[u][2] += v else: mid = tree[u][0] + tree[u][1] 1 if x = mid: modify(u 1, x, v) else: modify(u 1 | 1, x, v) pushup(u)build(1, 1, n)for _ in range(m): k, a, b = map(int, input().split()) if k: modify(1, a, b) else: print(query(1, a, b)) æ•°æ˜Ÿæ˜Ÿ1265. æ•°æ˜Ÿæ˜Ÿ n = int(input())tree = [0] * 32002res = [0] * ndef lowbit(x): return x -xdef add(x): while x = 32001: tree[x] += 1 x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return resfor _ in range(n): x, y = map(int, input().split()) res[query(x+1)] += 1 add(x+1)for i in res: print(i) æ•°åˆ—åŒºé—´æœ€å¤§å€¼1270. æ•°åˆ—åŒºé—´æœ€å¤§å€¼ dp(çˆ†ç©ºé—´) n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))dp = [[0] * (n+1) for _ in range(n+1)]for i in range(1, n + 1): for j in range(i, n + 1): dp[i][j] = max(dp[i][j - 1], nums[j])for _ in range(m): x, y = map(int, input().split()) print(dp[x][y]) çº¿æ®µæ ‘(TLE) n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): t = max(tree[u 1][2], tree[u 1 | 1][2]) tree[u][2] = tdef build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r 1 build(u 1, l, mid) build(u 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] = l and tree[u][1] = r: return tree[u][2] mid = tree[u][0] + tree[u][1] 1 left = right = 0 if l = mid: left = query(u 1, l, r, ) if r mid: right = query(u 1 | 1, l, r) return max(left, right)build(1, 1, n)for _ in range(m): x, y = map(int, input().split()) print(query(1, x, y)) å°æœ‹å‹æ’é˜Ÿ1215. å°æœ‹å‹æ’é˜Ÿ N = 1000001n = int(input())nums = [0] + list(map(lambda x: int(x) + 1, input().split()))ct = [0] * (n + 1)def lowbit(x): return x -xdef add(x, v): while x = N: tree[x] += v x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return restree = [0] * (N + 1)for i in range(1, n + 1): ct[i] = query(N) - query(nums[i]) add(nums[i], 1)tree = [0] * (N + 1)for i in range(n, 0, -1): ct[i] += query(nums[i] - 1) add(nums[i], 1)res = 0for i in ct[1:]: res += i * (i + 1) 1print(res) æ²¹æ¼†é¢ç§¯1228. æ²¹æ¼†é¢ç§¯ çº¿æ®µæ ‘å¤ªéš¾ï¼Œè·³è¿‡ï¼ ä¸‰ä½“æ”»å‡»1232. ä¸‰ä½“æ”»å‡» äºŒåˆ† + ä¸‰ç»´å·®åˆ† (éš¾) from sys import stdininput = lambda: stdin.readline().strip()def get(i, j, k): return (i * B + j) * C + kdef check(mid): b = [0]*N for i in range(1, mid + 1): x1, x2, y1, y2, z1, z2, c = op[i] b[get(x1, y1, z1)] -= c b[get(x1, y1, z2 + 1)] += c b[get(x1, y2 + 1, z1)] += c b[get(x1, y2 + 1, z2 + 1)] -= c b[get(x2 + 1, y1, z1)] += c b[get(x2 + 1, y1, z2 + 1)] -= c b[get(x2 + 1, y2 + 1, z1)] -= c b[get(x2 + 1, y2 + 1, z2 + 1)] += c # å¯¹bæ±‚ä¸€ä¸‹ä¸‰ç»´å‰ç¼€å’Œ arr = s[:] for i in range(1, A + 1): for j in range(1, B + 1): for k in range(1, C + 1): b[get(i, j, k)] += b[get(i - 1, j, k)] + b[get(i,j-1,k)] + b[get(i,j,k-1)] + b[get(i-1,j-1,k-1)] - \\ b[get(i - 1, j - 1, k)] - b[get(i - 1, j, k - 1)] - b[get(i, j - 1, k - 1)] arr[get(i, j, k)] += b[get(i,j,k)] if arr[get(i, j, k)] 0: return True return FalseA, B, C, m = map(int, input().split())N = (A+1)*(B+1)*(C+1)s, b, bp = [0]*N, [0]*N, [0]*Narr = list(map(int, input().split()))t = 0for i in range(1, A+1): for j in range(1, B+1): for k in range(1, C+1): s[get(i,j,k)] = arr[t] # æŠŠåœ°çƒå†›é˜Ÿçš„ç”Ÿå‘½å€¼ç»™èµ‹å€¼ t += 1op = [[]] + [list(map(int, input().split())) for _ in range(m)]l, r = 1, mwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) å·®åˆ†797. å·®åˆ† n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diff = [0] * (n + 2)def insert(l, r, c): diff[l] += c diff[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diff[i]print(*nums[1:]) å·®åˆ†çŸ©é˜µ798. å·®åˆ†çŸ©é˜µ n, m, q = map(int, input().split())nums = [[0] * (m + 1)] + [[0] + list(map(int, input().split())) for _ in range(n)]diff = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += c diff[x1][y2 + 1] -= c diff[x2 + 1][y1] -= c diff[x2 + 1][y2 + 1] += cfor _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, nums[i][j]) nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diff[i][j] print(nums[i][j], end= ) print() èºæ—‹æŠ˜çº¿1237. èºæ—‹æŠ˜çº¿ x, y = map(int, input().split())if abs(x) = y: print(2 * y * (2 * y - 1) + x + y)elif abs(y) = x: print(2 * x * 2 * x + x - y)elif abs(x) = -y + 1: print(2 * -y * (2 * -y + 1) - x - y)else: print((2 * -x - 1) * (2 * -x - 1) - x + y - 1) åŒæŒ‡é’ˆã€BFSä¸å›¾è®ºæ—¥å¿—ç»Ÿè®¡1238. æ—¥å¿—ç»Ÿè®¡ n, d, k = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort()cnt, st = [0] * 100001, [False] * 100001j = 0for i in range(n): idx = nums[i][1] cnt[idx] += 1 while nums[i][0] - nums[j][0] = d: cnt[nums[j][1]] -= 1 j += 1 if cnt[idx] = k: st[idx] = Truefor i in range(100001): if st[i]: print(i) çŒ®ç»™é˜¿å°”å‰ä¾¬çš„èŠ±æŸ1101. çŒ®ç»™é˜¿å°”å‰ä¾¬çš„èŠ±æŸ from collections import dequet = int(input())dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(start, end, g): q = deque() q.append(start) dist = [[-1] * c for _ in range(r)] dist[start[0]][start[1]] = 0 while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x r and 0 = y c and g[x][y] != # and dist[x][y] == -1: dist[x][y] = dist[a][b] + 1 if x == end[0] and y == end[1]: print(dist[x][y]) return q.append((x, y)) print(oop!)for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] for i in range(r): for j in range(c): if g[i][j] == S: start = (i, j) elif g[i][j] == E: end = (i, j) bfs(start, end, g) çº¢ä¸é»‘1113. çº¢ä¸é»‘ dfs dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dfs(a, b): cnt = 1 st[a][b] = True for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y m and g[x][y] == . and not st[x][y]: st[x][y] = True cnt += dfs(x, y) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == @: print(dfs(i, j)) break bfs from collections import dequedirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) cnt = 1 st[a][b] = True while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y m and g[x][y] == . and not st[x][y]: st[x][y] = True cnt += 1 q.append((x, y)) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == @: print(bfs(i, j)) break äº¤æ¢ç“¶å­1224. äº¤æ¢ç“¶å­ è´ªå¿ƒ n = int(input())nums = [0] + list(map(int, input().split()))st = [False] * (n + 1)cnt = 0for i in range(1, n + 1): t = nums[i] if not st[t]: st[t] = True cnt += 1 while not st[nums[t]]: st[nums[t]] = True t = nums[t]print(n - cnt) å¹¶æŸ¥é›† n = int(input())nums = [0] + list(map(int, input().split()))fa = [i for i in range(n + 1)]s = [0] * (n + 1)def find(x): if fa[x] == x: return x fa[x] = find(fa[x]) return fa[x]for i in range(1, n + 1): fx, fy = find(nums[i]), find(nums[nums[i]]) fa[fx] = fyfor i in range(1, n + 1): s[find(i)] += 1res = 0for i in range(1, n + 1): if s[i]: res += s[i] - 1print(res) å®Œå…¨äºŒå‰æ ‘çš„æƒå€¼1240. å®Œå…¨äºŒå‰æ ‘çš„æƒå€¼ å‰ç¼€å’Œ n = int(input())nums = [0] + list(map(int, input().split()))for i in range(1, n + 1): nums[i] += nums[i - 1]res, depth = float(-inf), 1i = j = 1while i = n: t = nums[min(n, i * 2 - 1)] - nums[i - 1] if t res: res = t depth = j i *= 2 j += 1print(depth) åœ°ç‰¢å¤§å¸ˆ1096. åœ°ç‰¢å¤§å¸ˆ from collections import dequedirs = [(1, 0 ,0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]def bfs(start, end): q = deque() q.append(start) dist = [[[-1] * c for _ in range(r)] for _ in range(l)] dist[start[0]][start[1]][start[2]] = 0 while q: a, b, d = q.popleft() for i in range(6): x, y, z = a + dirs[i][0], b + dirs[i][1], d + dirs[i][2] if 0 = x l and 0 = y r and 0 = z c and g[x][y][z] != # and dist[x][y][z] == -1: dist[x][y][z] = dist[a][b][d] + 1 if x == end[0] and y == end[1] and z == end[2]: print(fEscaped in dist[x][y][z] minute(s).) return q.append((x, y, z)) print(Trapped!)while True: l, r, c = map(int, input().split()) if not l: break g = [0] * l for i in range(l): g[i] = [input() for _ in range(r)] input() for i in range(l): for j in range(r): for k in range(c): if g[i][j][k] == S: start = (i, j, k) elif g[i][j][k] == E: end = (i, j, k) bfs(start, end) å…¨çƒå˜æš–1233. å…¨çƒå˜æš– from collections import dequen = int(input())g = [input() for _ in range(n)]st = [[False] * n for _ in range(n)]dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) total = bound = 0 st[a][b] = True while q: a, b = q.popleft() total += 1 is_bound = False for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y n: if g[x][y] == .: is_bound = True elif g[x][y] == # and not st[x][y]: st[x][y] = True q.append((x, y)) if is_bound: bound += 1 if total == bound: global res res += 1res = 0for i in range(n): for j in range(n): if g[i][j] == # and not st[i][j]: bfs(i, j)print(res) å¤§è‡£çš„æ—…è´¹1207. å¤§è‡£çš„æ—…è´¹ dfs(çˆ†æ ˆ) import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]dist = [0] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def dfs(u, father, distance): dist[u] = distance for i, j in g[u]: if i != father: dfs(i, u, distance + j)dfs(1, -1, 0)t = dist.index(max(dist))dfs(t, -1, 0)t = max(dist)print(10 * t + t * (t + 1) // 2) bfs from collections import dequen = int(input())g = [[] for _ in range(n + 1)]dist = [-1] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def bfs(u): q = deque([u]) dist[u] = 0 while q: u = q.popleft() for i, j in g[u]: if dist[i] == -1: dist[i] = dist[u] + j q.append(i)bfs(1)t = dist.index(max(dist))dist = [-1] * (n + 1)bfs(t)t = max(dist)print(t * 10 + t * (t + 1) // 2) è´ªå¿ƒè‚¡ç¥¨ä¹°å– II1055. è‚¡ç¥¨ä¹°å– II n = int(input())nums = list(map(int, input().split()))res = 0for i in range(1, n): res += max(0, nums[i] - nums[i - 1])print(res) è´§ä»“é€‰å€104. è´§ä»“é€‰å€ n = int(input())nums = list(map(int, input().split()))nums.sort()a = nums[n // 2]res = 0for num in nums: res += abs(a - num)print(res) ç³–æœä¼ é€’122. ç³–æœä¼ é€’ n = int(input())nums = [0] + [int(input()) for _ in range(n)]sums = [0] * (n + 2)avg = sum(nums) // nfor i in range(n, 1, -1): sums[i] = sums[i + 1] - nums[i] + avgsums = sums[1: n + 1]sums.sort()res = 0a = sums[n // 2]for i in sums: res += abs(i - a)print(res) n = int(input())nums = [int(input()) for _ in range(n)]avg = sum(nums) // na = [0] + [i - avg for i in nums]for i in range(1, n + 1): a[i] += a[i - 1]a = sorted(a[1:])t = a[n // 2]res = 0for i in a: res += abs(t - i)print(res) é›·è¾¾è®¾å¤‡112. é›·è¾¾è®¾å¤‡ n, d = map(int, input().split())g = []for _ in range(n): x, y = map(int, input().split()) if y d: print(-1) exit(0) else: x1 = x - (d * d - y * y) ** 0.5 x2 = x + (d * d - y * y) ** 0.5 g.append((x1, x2))g.sort(key=lambda x: x[1])res, last = 0, float(-inf)for i in range(n): if g[i][0] last: res += 1 last = g[i][1]print(res) ä»˜è´¦é—®é¢˜1235. ä»˜è´¦é—®é¢˜ n, s = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, avg = 0, s / nfor i, num in enumerate(nums): cur = s / (n - i) if num cur: res += (avg - num) ** 2 s -= num else: res += (cur - avg) ** 2 * (n - i) breakres = (res / n) ** 0.5print(fres:.4f) ä¹˜ç§¯æœ€å¤§1239. ä¹˜ç§¯æœ€å¤§ n, k = map(int, input().split())nums = [int(input()) for _ in range(n)]MOD = 1000000009nums.sort()res = sign = 1l, r = 0, n - 1if k % 2: res = nums[r] r, k = r - 1, k - 1 if res 0: sign = -1while k: x, y = nums[l] * nums[l + 1], nums[r] * nums[r - 1] if x * sign y * sign: res *= x l += 2 else: res *= y r -= 2 res = res % MOD if res 0 else -(-res % MOD) k -= 2print(res) åç¼€è¡¨è¾¾å¼1247. åç¼€è¡¨è¾¾å¼ n, m = map(int, input().split())nums = list(map(int, input().split()))if not m: print(sum(nums))else: nums.sort() res = nums[-1] - nums[0] for num in nums[1: -1]: res += abs(num) print(res) çµèƒ½ä¼ è¾“1248. çµèƒ½ä¼ è¾“ t = int(input())for _ in range(t): n = int(input()) nums = [0] + list(map(int, input().split())) for i in range(1, n + 1): nums[i] += nums[i - 1] s0, sn = nums[0], nums[-1] if s0 sn: s0, sn = sn, s0 nums.sort() s0, sn = nums.index(s0), nums.index(sn) l, r = 0, n res = [0] * (n + 1) st = [0] * (n + 1) for i in range(s0, -1, -2): res[l] = nums[i] st[i] = True l += 1 for i in range(sn, n + 1, 2): res[r] = nums[i] st[i] = True r -= 1 for i in range(n + 1): if not st[i]: res[l] = nums[i] l += 1 ans = 0 for i in range(1, n + 1): ans = max(ans, abs(res[i] - res[i - 1])) print(ans) æ•°è®ºç­‰å·®æ•°åˆ—1246. ç­‰å·®æ•°åˆ— n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else ad = 0for i in range(1, n): d = gcd(nums[i] - nums[0], d)if d: print((nums[-1] - nums[0]) // d + 1)else: print(n) Xçš„å› å­é“¾1295. Xçš„å› å­é“¾ N = (1 20) + 10primes, st, minp = [], [False] * N, [0] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) minp[i] = i j = 0 while i * primes[j] = n and j len(primes): st[primes[j] * i] = True minp[primes[j] * i] = primes[j] if i % primes[j] == 0: break j += 1get_prime(N - 1)fact, sums = [0] * 30, [0] * Nwhile True: try: x = int(input()) k = total = 0 while x 1: p = minp[x] fact[k], sums[k] = p, 0 while x % p == 0: x //= p sums[k] += 1 total += 1 k += 1 res = 1 for i in range(1, total + 1): res *= i for i in range(k): for j in range(1, sums[i] + 1): res //= j print(total, res) except: break èªæ˜çš„ç‡•å§¿1296. èªæ˜çš„ç‡•å§¿ N = 50000primes, st = [], [False] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) j = 0 while i * primes[j] = n: st[i * primes[j]] = True if i % primes[j] == 0: break j += 1def is_prime(x): if x N: return not st[x] i = 0 while primes[i] = x / primes[i]: if x % primes[i] == 0: return False i += 1 return Truedef dfs(last, prod, s): if s == 1: res.append(prod) return if s - 1 (0 if last 0 else primes[last]) and is_prime(s - 1): res.append(prod * (s - 1)) i = last + 1 while primes[i] = s / primes[i]: p = primes[i] j, t = 1 + p, p while t = s: if s % j == 0: dfs(i, prod * t, s // j) t *= p j += t i += 1get_prime(N - 1)while True: try: x = int(input()) res = [] dfs(-1, 1, x) print(len(res)) if res: res.sort() print(*res) except: break äº”æŒ‡å±±1299. äº”æŒ‡å±± t = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(t): n, d, x, y = map(int, input().split()) gcd, a, b = exgcd(n, d) if (y - x) % gcd: print(Impossible) else: b *= (y - x) // gcd print(b % (n // gcd)) æœ€å¤§æ¯”ä¾‹1223. æœ€å¤§æ¯”ä¾‹ n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else adef gcd_sub(a, b): if a b: a, b = b, a if b == 1: return a return gcd_sub(b, a // b)a, b = [], []for i in range(1, n): if nums[i] != nums[i - 1]: d = gcd(nums[i], nums[0]) a.append(nums[i] // d) b.append(nums[0] // d)up, down = a[0], b[0]for i in range(1, len(a)): up = gcd_sub(up, a[i]) down = gcd_sub(down, b[i])print(fup/down) C å¾ªç¯1301. C å¾ªç¯ def exgcd(a, b): if b == 0: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ywhile True: a, b, c, k = map(int, input().split()) if a == 0 and b == 0 and c == 0 and k == 0: break k = 1 k gcd, x, y = exgcd(c, k) if (b - a) % gcd: print(FOREVER) else: x *= (b - a) // gcd print(x % (k // gcd)) æ­£åˆ™é—®é¢˜1225. æ­£åˆ™é—®é¢˜ s = input().strip()i = 0def dfs(): global i res = 0 while i len(s): if s[i] == (: i += 1 res += dfs() i += 1 elif s[i] == |: i += 1 res = max(res, dfs()) elif s[i] == ): break else: i += 1 res += 1 return resprint(dfs()) ç³–æœ1243. ç³–æœ IDA* def lowbit(x): return x -xdef h(st): t = (1 m) - 1 - st res = 0 while t: res += 1 i = lowbit(t) t -= i for row in col[log2[i]]: t = ~row return resdef dfs(depth, st): if depth == 0 or h(st) depth: return st == (1 m) - 1 t = -1 i = (1 m) - 1 - st while i: j = lowbit(i) i -= j if t == -1 or len(col[log2[j]]) len(col[t]): t = log2[j] for row in col[t]: if dfs(depth - 1, row | st): return True return Falsen, m, k = map(int, input().split())log2 = [0] * (1 m + 1)for i in range(m): log2[1 i] = icol = [[] for _ in range(m + 1)]for _ in range(n): t = list(map(int, input().split())) tt = 0 for ti in t: tt |= 1 (ti - 1) for i in range(m): if (tt i) 1: col[i].append(tt)depth = 0while depth = m and not dfs(depth, 0): depth += 1print(-1 if depth m else depth) dp n, m, k = map(int, input().split())dp = [-1] * ((1 m) + 1)val = [0] * nfor i in range(n): t = list(map(int, input().split())) for j in t: val[i] |= 1 (j - 1) dp[val[i]] = 1for i in range(n): for j in range(1 m): if dp[j] == -1: continue if dp[j | val[i]] == -1: dp[j | val[i]] = dp[j] + dp[val[i]] else: dp[j | val[i]] = min(dp[j | val[i]], dp[j] + dp[val[i]])print(dp[(1 m) - 1]) å¤æ‚DPé¸£äººçš„å½±åˆ†èº«1050. é¸£äººçš„å½±åˆ†èº« t = int(input())for _ in range(t): m, n = map(int, input().split()) dp = [[0] * (n + 1) for _ in range(m + 1)] dp[0][0] = 1 for i in range(m + 1): for j in range(1, n + 1): dp[i][j] = dp[i][j - 1] if i = j: dp[i][j] += dp[i - j][j] print(dp[m][n]) ç³–æœ1047. ç³–æœ n, k = map(int, input().split())dp = [[float(-inf)] * (k + 1) for _ in range(n + 1)]dp[0][0] = 0for i in range(1, n + 1): x = int(input()) for j in range(k + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - x) % k] + x)print(dp[n][0]) å¯†ç è„±è½1222. å¯†ç è„±è½ s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]for i in range(n): for l in range(n - i): r = l + i if i == 0: dp[l][r] = 1 else: if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] + 2 dp[l][r] = max(dp[l][r], dp[l + 1][r], dp[l][r - 1])print(n - dp[0][n - 1]) ç”Ÿå‘½ä¹‹æ ‘1220. ç”Ÿå‘½ä¹‹æ ‘ import syssys.setrecursionlimit(100000)n = int(input())w = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]dp = [float(-inf)] * (n + 1)for _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, fa): dp[u] = w[u] for v in adj_list[u]: if v != fa: dfs(v, u) dp[u] += max(0, dp[v])dfs(1, -1) print(max(dp)) åŒ…å­å‡‘æ•°1226. åŒ…å­å‡‘æ•° n = int(input())dp = [[0] * 10000 for _ in range(n + 1)]w = [0] + [int(input()) for _ in range(n)]def gcd(a, b): return gcd(b, a % b) if b else ad = w[1]for i in range(2, n + 1): d = gcd(d, w[i])if d == 1: dp[0][0] = 1 for i in range(1, n + 1): for j in range(10000): dp[i][j] = dp[i - 1][j] if j = w[i]: dp[i][j] |= dp[i][j - w[i]] res = 0 for i in range(10000): if not dp[n][i]: res += 1 print(res)else: print(INF) æ‹¬å·é…å¯¹1070. æ‹¬å·é…å¯¹ s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]def check(l, r): if s[l - 1] == ( and s[r - 1] == ): return True if s[l - 1] == [ and s[r - 1] == ]: return True return Falsefor i in range(n, 0, -1): for j in range(i + 1, n + 1): if check(i, j): dp[i][j] = dp[i + 1][j - 1] + 2 for k in range(i, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])print(n - dp[1][n]) æ–æ³¢é‚£å¥‘å‰ n é¡¹å’Œ1303. æ–æ³¢é‚£å¥‘å‰ n é¡¹å’Œ n, m = map(int, input().split())f1 = [1, 1, 1]a = [[0, 1, 0], [1, 1, 1], [0, 0, 1]]def mul1(b, c): tmp = [0] * 3 for i in range(3): for j in range(3): tmp[i] = (tmp[i] + b[j] * c[j][i]) % m return tmpdef mul2(b, c): tmp = [[0] * 3 for _ in range(3)] for i in range(3): for j in range(3): for k in range(3): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % m return tmpn -= 1while n: if n 1: f1 = mul1(f1, a) a = mul2(a, a) n = 1print(f1[2]) å’éª°å­1217. å’éª°å­ n, m = map(int, input().split())MOD = int(1e9) + 7op = [3, 4, 5, 0, 1, 2]f1 = [4, 4, 4, 4, 4, 4]d = [[4] * 6 for _ in range(6)]st = [[False] * 6 for _ in range(6)]for _ in range(m): a, b = map(lambda x: int(x) - 1, input().split()) st[a][b] = st[b][a] = Truefor i in range(6): for j in range(6): if st[j][op[i]]: d[j][i] = 0def mul1(b, c): tmp = [0] * 6 for i in range(6): for j in range(6): tmp[i] = (tmp[i] + b[j] * c[j][i]) % MOD return tmpdef mul2(b, c): tmp = [[0] * 6 for _ in range(6)] for i in range(6): for j in range(6): for k in range(6): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % MOD return tmpn -= 1while n: if n 1: f1 = mul1(f1, d) d = mul2(d, d) n = 1print(sum(f1) % MOD) ç–‘éš¾æ‚é¢˜ä¿®æ”¹æ•°ç»„1242. ä¿®æ”¹æ•°ç»„ import syssys.setrecursionlimit(100000)n = int(input())nums = list(map(int, input().split()))p = [i for i in range(1100001)]res = []def find(x): if x != p[x]: p[x] = find(p[x]) return p[x]for num in nums: x = find(num) res.append(x) p[x] = x + 1print(*res) å€æ•°é—®é¢˜1234. å€æ•°é—®é¢˜ n, K = map(int, input().split())nums = list(map(int, input().split()))dp = [[float(-inf)] * K for _ in range(4)]dp[0][0] = 0a = [[] for _ in range(K)]for num in nums: a[num % K].append(num)for i in range(K): tmp = sorted(a[i], reverse = True) for i in range(min(3, len(tmp))): for j in range(3, 0, -1): for k in range(K): dp[j][k] = max(dp[j][k], dp[j - 1][(k - tmp[i]) % K] + tmp[i])print(dp[3][0]) ç»„åˆæ•°é—®é¢˜523. ç»„åˆæ•°é—®é¢˜ t, k = map(int, input().split())c = [[0] * 2001 for _ in range(2001)]s = [[0] * 2001 for _ in range(2001)]for i in range(2001): for j in range(i + 1): if j == 0: c[i][j] = 1 else: c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % k if c[i][j] == 0: s[i][j] = 1for i in range(2001): for j in range(2001): if i: s[i][j] += s[i - 1][j] if j: s[i][j] += s[i][j - 1] if i and j: s[i][j] -= s[i - 1][j - 1]for _ in range(t): n, m = map(int, input().split()) print(s[n][m]) æ¨¡æ‹Ÿæ•£åˆ—è¡¨840. æ¨¡æ‹Ÿæ•£åˆ—è¡¨ n = int(input())dicts = for _ in range(n): op, x = input().split() if op == I: dicts[x] = dicts.get(x, 0) + 1 elif op == Q: if dicts.get(x): print(Yes) else: print(No)","tags":["ç®—æ³•","Python","è“æ¡¥æ¯","AcWing"],"categories":["ç®—æ³•"]},{"title":"PAT ä¹™çº§","path":"/2024/01/29/patä¹™çº§/","content":"1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³n = int(input())num = 0while n != 1: if n % 2 == 0: n = n // 2 else: n = (3 * n + 1) // 2 num += 1print(num) 1002 å†™å‡ºè¿™ä¸ªæ•°n = input()res = 0for char in n: res += int(char)dicts = [ling, yi, er, san, si, wu, liu, qi, ba, jiu]ans = []for char in str(res): ans.append(dicts[int(char)])print( .join(map(str, ans))) 1003 æˆ‘è¦é€šè¿‡ï¼n = int(input())def check(arg): length = len(arg) idx = cnt1 = cnt2 = cnt3 = 0 while idx length and arg[idx] == A: cnt1 += 1 idx += 1 if idx length and arg[idx] == P: idx += 1 else: return False while idx length and arg[idx] == A: idx += 1 cnt2 += 1 if idx length and arg[idx] == T: idx += 1 else: return False while idx length and arg[idx] == A: idx += 1 cnt3 += 1 if idx == length and cnt1 * cnt2 == cnt3 and cnt2: return True else: return Falsefor _ in range(n): a = input() print(YES if check(a) else NO) 1004 æˆç»©æ’ån = int(input())students = []for i in range(n): name, number, grade = input().split() students.append([name, number, grade])students.sort(key=lambda x: int(x[2]))print(students[-1][0], students[-1][1])print(students[0][0], students[0][1]) 1005 ç»§ç»­(3n+1)çŒœæƒ³n = int(input())nums = list(map(int, input().split()))res = nums[:]def check(num): while num != 1: if num % 2 == 0: num = num // 2 else: num = (3 * num + 1) // 2 if num in res: res.remove(num) returnfor num in nums: check(num)res.sort(reverse=True)print( .join(map(str, res))) 1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•°n = 00 + input()res = B * int(n[-3]) + S * int(n[-2]) + .join([str(i) for i in range(1, int(n[-1]) + 1)])print(res) 1007 ç´ æ•°å¯¹çŒœæƒ³n = int(input())state = [True] * (n + 1)primes = []for i in range(2, n + 1): if state[i]: primes.append(i) for j in range(i * 2, n + 1, i): state[j] = Falseres = 0for i in range(len(primes) - 1): if primes[i + 1] - primes[i] == 2: res += 1print(res) 1008 æ•°ç»„å…ƒç´ å¾ªç¯å³ç§»é—®é¢˜n, m = map(int, input().split())nums = list(map(int, input().split()))nums = nums[n - m: ] + nums[: n - m]print( .join(map(str, nums))) 1009 è¯´åè¯s = list(input().split())print( .join(map(str, s[::-1]))) 1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼nums = list(map(int, input().split()))res = []for i in range(0, len(nums), 2): a = nums[i] * nums[i + 1] b = nums[i + 1] - 1 if a: res.extend((a, b))if not res: res.extend((0, 0))print( .join(map(str, res))) 1011 A+B å’Œ Ct = int(input())for i in range(1, t + 1): a, b, c = map(int, input().split()) if a + b c: print(fCase #i: true) else: print(fCase #i: false) 1012 æ•°å­—åˆ†ç±»nums = list(map(int, input().split()))res1 = res2 = len2 = res3 = res4 = len4 = res5 = 0for num in nums[1: ]: if num % 10 == 0: res1 += num elif num % 5 == 1: res2 += (-1) ** (len2 % 2) * num len2 += 1 elif num % 5 == 2: res3 += 1 elif num % 5 == 3: res4 += num len4 += 1 elif num % 5 == 4: res5 = num if num res5 else res5if not res1: res1 = Nif not len2: res2 = Nif not res3: res3 = Nif len4: res4 = round(res4 / len4, 1)else: res4 = Nif not res5: res5 = Nprint(res1, res2, res3, res4, res5) 1013 æ•°ç´ æ•°m, n = map(int, input().split())state = [True] * 600000for i in range(2, int(600000**0.5) + 1): if state[i]: for j in range(i * i, 600000, i): state[j] = Falseprimes = [num for num in range(2, 600000) if state[num]]tmps = primes[m - 1: n]ress = [tmps[i:i+10] for i in range(0, len(tmps), 10)]for res in ress: print( .join(map(str, res))) 1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼šs1, s2, s3, s4 = input(), input(), input(), input()len1, len2 = min(len(s1), len(s2)), min(len(s3), len(s4))res = []DAY = A: MON, B: TUE, C: WED, D: THU, E: FRI, F: SAT, G: SUNfor i in range(len1): if s1[i] == s2[i] and A = s1[i] = G: res.append(DAY[s1[i]]) breakfor j in range(i + 1, len1): if s1[j] == s2[j]: if 0 = s1[j] = 9: res.append(0 + s1[j]) break if A = s1[j] = N: res.append(str(ord(s1[j]) - 55)) breakfor i in range(len2): if s3[i] == s4[i] and (97 = ord(s3[i]) = 122 or 65 = ord(s3[i]) = 90): if i 10: res.append(0 + str(i)) else: res.append(str(i))print(fres[0] res[1]:res[2]) 1015 å¾·æ‰è®ºï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰from sys import stdininput = lambda: stdin.readline().strip()n, l, h = map(int, input().split())res1, res2, res3, res4 = [], [], [], []for _ in range(n): a, b, c = map(int, input().split()) if b = h and c = h: res1.append([a, b, c, b + c]) elif b = h and c = l: res2.append([a, b, c, b + c]) elif b = l and c = l and b = c: res3.append([a, b, c, b + c]) elif b = l and c = l: res4.append([a, b, c, b + c])print(len(res1) + len(res2) + len(res3) + len(res4))res1.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res2.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res3.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res4.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)for res in res1: print( .join(map(str, res[: -1])))for res in res2: print( .join(map(str, res[: -1])))for res in res3: print( .join(map(str, res[: -1])))for res in res4: print( .join(map(str, res[: -1]))) 1016 éƒ¨åˆ†A+BA, Da, B, Db = input().split()Pa = Da * A.count(Da) if A.count(Da) else 0Pb = Db * B.count(Db) if A.count(Da) else 0print(int(Pa) + int(Pb)) 1017 Aé™¤ä»¥Ba, b = map(int, input().split())print(a // b, a % b) 1018 é”¤å­å‰ªåˆ€å¸ƒn = int(input())a = b = c = 0jia, yi = [], []for _ in range(n): x, y = input().split() jia.append(x) yi.append(y) if x == y: c += 1 elif x == C and y == J or x == J and y == B or x == B and y == C: a += 1 jia.append(x) else: b += 1 yi.append(y)print(a, c, b)print(n - a - c, c, n - b - c)b1, c1, j1 = jia.count(B), jia.count(C), jia.count(J)b2, c2, j2 = yi.count(B), yi.count(C), yi.count(J)t1, t2 = max(b1, c1, j1), max(b2, c2, j2)if b1 == t1: print(B, end= )elif c1 == t1: print(C, end= )else: print(J, end= )if b2 == t2: print(B)elif c2 == t2: print(C)else: print(J) 1019 æ•°å­—é»‘æ´n = input()def fun(n): n = map(int, list(str(n).zfill(4))) b = list(map(str, sorted(n))) a = b[::-1] c = .join(a) d = .join(b) e = int(c) - int(d) e = str(e).zfill(4) print(fc - d = e) if e != 0000 and e != 6174: fun(e)fun(n) 020 æœˆé¥¼N, D = map(int, input().split())stocks = list(map(float, input().split()))prices = list(map(float, input().split()))profits = [price / stock for stock, price in zip(stocks, prices)]yuebings = sorted(zip(stocks, prices, profits), key=lambda x: x[2], reverse=True)res = 0for stock, price, profit in yuebings: a = min(stock, D) res += a * profit D -= a if not D: breakprint(fres:.2f) 1021 ä¸ªä½æ•°ç»Ÿè®¡n = input()nums = 0123456789for num in nums: if n.count(num): print(fnum:n.count(num)) 1022 Dè¿›åˆ¶çš„A+Ba, b, d = map(int, input().split())c = a + bres = []while c: res.append(c % d) c //= dif res: print(.join(map(str, res[::-1])))else: print(0) 1023 ç»„ä¸ªæœ€å°æ•°nums = list(map(int, input().split()))res = for i in range(1, 10): if nums[i]: nums[i] -= 1 res = str(i) breaknums = [str(num) * nums[num] for num in range(10) if nums[num]]print(res + .join(map(str, nums))) 1024 ç§‘å­¦è®¡æ•°æ³•a = input()res = []if a[0] == -: res.append(-)e = a.find(E)exp = int(a[e+2:])if a[e + 1] == +: res.append(a[1]) if exp = e - 3: res.append(a[3: e]) res.append(0 * (exp - e + 3)) else: res.append(a[3: 3 + exp]) res.append(.) res.append(a[3 + exp: e])elif a[e + 1] == -: res.append(0.) if exp 1: res.append(0 * (exp - 1)) res.append(a[1]) res.append(a[3: e])print(.join(res)) 1025 åè½¬é“¾è¡¨start, n, k = map(int, input().split())datas, nexts, lst = [0] * 100001, [0] * 100001, []for _ in range(n): a, b, c = map(int, input().split()) datas[a], nexts[a] = b, cwhile start != -1: lst.append(start) start = nexts[start]cnt = len(lst)for i in range(0, cnt - cnt % k, k): lst[i: i + k] = lst[i: i + k][::-1]for i in range(cnt - 1): print(flst[i]:05d datas[lst[i]] lst[i + 1]:05d)print(flst[-1]:05d datas[lst[-1]] -1) 1026 ç¨‹åºè¿è¡Œæ—¶é—´c1, c2 = map(int, input().split())t = (c2 - c1 + 50) // 100res = []while t: if t % 60 10: res.append(0 + str(t % 60)) else: res.append(str(t % 60)) t //= 60while len(res) 3: res.append(00)print(:.join( res[::-1])) 1027 æ‰“å°æ²™æ¼n, symbol = input().split()shalous = []shalou = -1for i in range(30): shalou += 2 * (2 * i + 1) shalous.append(shalou)for i in range(30): if int(n) shalous[i]: breaka = 2 * (i - 1) + 1for j in range(a, 1, -2): print( * ((a - j) // 2) + symbol * j)for j in range(1, a + 1, 2): print( * ((a - j) // 2) + symbol * j)print(int(n) - shalous[i - 1]) 1028 äººå£æ™®æŸ¥ï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰from sys import stdininput = lambda: stdin.readline().strip()n = int(input())nums = []for _ in range(n): name, birth = input().split() y, m, d = birth.split(/) if 18140906 = y + m + d = 20140906: nums.append([name, int(y), int(m), int(d)])nums.sort(key=lambda x: (x[1], x[2], x[3]))if nums: print(len(nums), nums[0][0], nums[-1][0])else: print(0) 1029 æ—§é”®ç›˜a, b = input(), input()dicts = for char in b: dicts[char] = 1res = []for char in a: if not dicts.get(char, 0): if char.isalpha(): char = char.upper() res.append(char)print(.join(.fromkeys(res).keys())) 1030 å®Œç¾æ•°åˆ—n, p = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, j = 1, 0for i in range(n): while j n and nums[j] = nums[i] * p: j += 1 res = max(res, j - i)print(res) 1031 æŸ¥éªŒèº«ä»½è¯n = int(input())dicts = [1, 0, X, 9, 8, 7, 6, 5, 4, 3, 2]weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]def check(id_card): check_num = 0 for i in range(17): if 48 = ord(id_card[i]) = 57: check_num += int(id_card[i]) * weights[i] else: return False check_num %= 11 return id_card[-1] == str(dicts[check_num])res = 0for _ in range(n): id_card = input() if not check(id_card): print(id_card) res += 1if not res: print(All passed) 1032 æŒ–æ˜æœºæŠ€æœ¯å“ªå®¶å¼ºn = int(input())nums = [-1] + [0] * 100000for _ in range(n): a, b = map(int, input().split()) nums[a] += bprint(nums.index(max(nums)), max(nums)) 1033 æ—§é”®ç›˜æ‰“å­—bad, string = list(input()), input()shift = Falsefor i in bad: if i == +: shift = True if 65 = ord(i) = 90: bad.append(i.lower())for i in string: if 65 = ord(i) = 90 and shift: continue if i not in bad: print(i, end=) 1034 æœ‰ç†æ•°å››åˆ™è¿ç®—import matha, b = input().split()def simplify(a): x, y = map(int, a.split(/)) return str(x // math.gcd(x, y)) + / + str(y // math.gcd(x, y))a, b = simplify(a), simplify(b)def calculate(a, b): x1, y1 = map(int, a.split(/)) x2, y2 = map(int, b.split(/)) t = str(x1 * y2 + x2 * y1) + / + str(y1 * y2) res.append(simplify(t)) t = str(x1 * y2 - x2 * y1) + / + str(y1 * y2) res.append(simplify(t)) t = str(x1 * x2) + / + str(y1 * y2) res.append(simplify(t)) if not x2: res.append(1/0) else: if x2 0: x2, y2 = -x2, -y2 t = str(x1 * y2) + / + str(y1 * x2) res.append(simplify(t))res = []calculate(a, b)def simplify2(a): x, y = map(int, a.split(/)) if not y: return Inf ans = t = abs(x) // y if not x % y: ans = str(t) elif t: ans = str(t) + + str(abs(x - t * y * x // abs(x))) + / + str(y) else: ans = str(abs(x)) + / + str(y) return (- + ans + ) if x 0 else ansa, b, res = simplify2(a), simplify2(b), [simplify2(i) for i in res]print(fa + b = res[0])print(fa - b = res[1])print(fa * b = res[2])print(fa / b = res[3]) 1035 æ’å…¥ä¸å½’å¹¶n = int(input())start = list(map(int, input().split()))mid = list(map(int, input().split()))for i in range(n - 1, -1, -1): if start[i] != mid[i]: breakif sorted(mid[:i + 1]) == mid[:i + 1]: print(Insertion Sort) a = start[i + 1] while a start[i]: i += 1 a = start[i + 1] for j in range(i + 1): if a mid[j]: print( .join(map(str, (mid[: j] + [a] + mid[j:i + 1] + mid[i+2:])))) breakelse: print(Merge Sort) i = 1 flag = True while i n and flag: i *= 2 for j in range(i, n, i): if sorted(mid[j-i: j]) != mid[j-i: j]: flag = False break if i j: mid.sort() else: for j in range(i, n, i): mid[j-i: j] = sorted(mid[j-i: j]) mid[j:] = sorted(mid[j:]) print( .join(map(str, mid))) 1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹n, c = input().split()n = int(n)row = int(n / 2 + 0.5) - 2print(c * n)for _ in range(row): print(c + * (n - 2) + c)print(c * n) 1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’±p, a = input().split()g1, s1, k1 = map(int, p.split(.))g2, s2, k2 = map(int, a.split(.))t1 = (g1 * 17 + s1) * 29 + k1t2 = (g2 * 17 + s2) * 29 + k2t3 = abs(t2 - t1)k3 = t3 % 29s3 = t3 // 29 % 17g3 = (t3 // 29 - s3) // 17if t2 = t1: print(fg3.s3.k3)else: print(f-g3.s3.k3) 1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿn = int(input())nums = list(map(int, input().split()))checks = list(map(int, input().split()))scores = [0] * 101for num in nums: scores[num] += 1res = []for check in checks[1:]: res.append(scores[check])print( .join(map(str, res))) 1039 åˆ°åº•ä¹°ä¸ä¹°s, t = input(), input()a, dict1 = 0, for char in s: dict1[char] = dict1.get(char, 0) + 1for char in t: if dict1.get(char, 0): a += 1 dict1[char] -= 1if a == len(t): print(fYes len(s) - len(t))else: print(fNo len(t) - a) 1040 æœ‰å‡ ä¸ªPATimport bisects = input()p, a, pa, t = [], [], [], []for idx, char in enumerate(s): if char == P: p.append(idx) elif char == A: a.append(idx) elif char == T: t.append(idx)tmp = 0for i in a: x = bisect.bisect(p, i) tmp += x pa.append(tmp)res = 0for i in t: x = bisect.bisect(a, i) if x: res += pa[x-1]print(res % 1000000007) 1041 è€ƒè¯•åº§ä½å·n = int(input())nums = [0] * 10001for _ in range(n): a, b, c = map(int, input().split()) nums[b] = (a, c)m = int(input())inqurie = map(int, input().split())for i in inqurie: print(nums[i][0], nums[i][1]) 1042 å­—ç¬¦ç»Ÿè®¡from collections import Counters = input()t = []for char in s: if 65 = ord(char) = 90: char = char.lower() if 97 = ord(char) = 122: t.append(char)t.sort()t = Counter(t)print(t.most_common(1)[0][0], t.most_common(1)[0][1]) 1043 è¾“å‡ºPATestfrom collections import Counters = input()t = [char for char in s if char in PATest]counter = Counter(t)res = for _ in range(counter.most_common(1)[0][1]): for char in PATest: if counter[char]: counter[char] -= 1 res += charprint(res) 1044 ç«æ˜Ÿæ•°å­—n = int(input())units = [tret, jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec]tens = [tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou]for _ in range(n): a = input() try: a = int(a) except ValueError: if len(a) 4: x, y = a.split() ten, unit = tens.index(x) + 1, units.index(y) print(ten * 13 + unit) else: if a in units: print(units.index(a)) else: print((tens.index(a) + 1) * 13) else: unit, ten = a % 13, a // 13 if ten 0 and unit 0: print(tens[ten - 1], units[unit]) elif ten 0: print(tens[ten - 1]) else: print(units[unit]) 1045 å¿«é€Ÿæ’åºn = int(input())nums = list(map(int, input().split()))lefts, rights, res = [], [], []left, right = 0, float(inf)for num in nums: if left num: left = num lefts.append(left)for num in nums[::-1]: if right num: right = num rights.append(right)for left, num, right in zip(lefts, nums, rights[::-1]): if left = num = right: res.append(num)print(len(res))print( .join(map(str, res))) 1046 åˆ’æ‹³n = int(input())a = b = 0for _ in range(n): x1, x2, y1, y2 = map(int, input().split()) if x2 == y2: continue if x1 + y1 == x2: b += 1 elif x1 + y1 == y2: a += 1print(a, b) 1047 ç¼–ç¨‹å›¢ä½“èµ›n = int(input())nums = [0] * 1001for _ in range(n): num, score = input().split() a, b = map(int, num.split(-)) nums[a] += int(score)res = max(nums)print(nums.index(res), res) 1048 æ•°å­—åŠ å¯†a, b = input().split()l = max(len(a), len(b))a = list(map(int, a[::-1])) + [0] * (l - len(a))b = list(map(int, b[::-1])) + [0] * (l - len(b))dicts = [J, Q, K]res = []for i in range(l): if i % 2 == 0: t = (a[i] + b[i]) % 13 res.append(dicts[t - 10] if t = 10 else t) else: res.append((b[i] - a[i] + 10) % 10)print(.join(map(str, res[::-1]))) 1049 æ•°åˆ—çš„ç‰‡æ®µå’Œï¼ˆéƒ¨åˆ†é€šè¿‡ï¼‰n = int(input())nums = list(map(float, input().split()))res, a = 0, 1for num in nums: res += num * a * n n -= 1 a += 1print(fres:.2f) 1050 èºæ—‹çŸ©é˜µimport mathN = int(input())nums = list(map(int, input().split()))nums.sort(reverse=True)m = n = 0for i in range(1, int(math.sqrt(N)) + 1): if N % i == 0: n, m = i, N // ires = [[0] * n for _ in range(m)]u, d, l, r = 0, m, 0, nidx = 0while True: res[u][l:r] = nums[idx: idx+r-l] u += 1 idx += r-l if u == d or l == r: break for i in range(u, d): res[i][r-1] = nums[idx] idx += 1 r -= 1 if u == d or l == r: break res[d-1][l:r] = nums[idx: idx+r-l][::-1] idx += r-l d -= 1 if u == d or l == r: break for i in range(d-1, u-1, -1): res[i][l] = nums[idx] idx += 1 l += 1 if u == d or l == r: breakfor row in res: print( .join(map(str, row))) 1051 å¤æ•°ä¹˜æ³•import mathr1, p1, r2, p2 = map(float, input().split())a1 = r1 * math.cos(p1)b1 = r1 * math.sin(p1)a2 = r2 * math.cos(p2)b2 = r2 * math.sin(p2)a3 = a1*a2-b1*b2 b3 = a1*b2+a2*b1if abs(a3) 0.005: a3 = 0if abs(b3) 0.005: print(fa3:.2f+0.00i)elif b3 0: print(fa3:.2f+b3:.2fi)else: print(fa3:.2fb3:.2fi) 1052 å–ä¸ªèŒçœ‹ä¸æ‡‚é¢˜ 1053 ä½æˆ¿ç©ºç½®ç‡n, e, d = map(float, input().split())maybe_vacant = vacant = 0for _ in range(int(n)): nums = list(map(float, input().split())) t = sum(1 for i in nums[1:] if i e) if t / nums[0] 0.5: if nums[0] d: vacant += 1 else: maybe_vacant += 1print(fmaybe_vacant / n * 100:.1f% vacant / n * 100:.1f%)","tags":["ç®—æ³•","Python","PAT"],"categories":["ç®—æ³•"]},{"title":"ç®—æ³•åŸºç¡€è¯¾","path":"/2024/01/29/ç®—æ³•åŸºç¡€è¯¾/","content":"AcWingç®—æ³•åŸºç¡€è¯¾åŸºç¡€ç®—æ³•å¿«é€Ÿæ’åº785. å¿«é€Ÿæ’åº n = int(input())nums = list(map(int, input().split()))def quick_sort(l, r): if l = r: return i, j = l - 1, r + 1 x = nums[l + r 1] while i j: while True: i += 1 if nums[i] = x: break while True: j -= 1 if nums[j] = x: break if i j: nums[i], nums[j] = nums[j], nums[i] quick_sort(l, j) quick_sort(j + 1, r)quick_sort(0, n - 1)print(*nums) 786. ç¬¬kä¸ªæ•° n, k = map(int, input().split())nums = list(map(int, input().split()))def quick_select(l, r, k): if l = r: return nums[l] x = nums[(l + r) // 2] i, j = l - 1, j + 1 while i j: while True: i += 1 if nums[i] = x: break while True: j -= 1 if nums[j] = x: break if i j: nums[i], nums[j] = nums[j], nums[i] sl = j - l + 1 if k = sl: return quick_select(l, j, k) else: return quick_select(j + 1, r, k - sl) print(quick_select(0, n - 1, k)) å½’å¹¶æ’åº787. å½’å¹¶æ’åº n = int(input())nums = [int(x) for x in input().split()]def merge_sort(nums, l, r): if l = r: return mid = (l + r) // 2 merge_sort(nums, l, mid) merge_sort(nums, mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp merge_sort(nums, 0, n - 1)print( .join(list(map(str, nums)))) 788. é€†åºå¯¹çš„æ•°é‡ n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return 0 mid = l + r 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) äºŒåˆ†789. æ•°çš„èŒƒå›´ n, q = map(int, input().split())nums = [int(x) for x in input().split()]while q 0: q -= 1 x = int(input()) l, r = 0, n - 1 while l r: mid = (l + r) // 2 if nums[mid] = x: r = mid else: l = mid + 1 if nums[l] != x: print(-1 -1) continue left = l l, r = 0, n - 1 while l r: mid = (l + r + 1) // 2 if nums[mid] = x: l = mid else: r = mid - 1 print(fleft l) 790. æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ n = float(input())l, r = -100, 100while abs(l - r) 1e-8: mid = (l + r) / 2 if mid ** 3 n: r = mid else: l = midprint(fl:.6f) å‰ç¼€å’Œ795. å‰ç¼€å’Œ n, m = map(int, input().split())nums = [int(x) for x in input().split()]sums = [0] * (n + 1)for i in range(n): sums[i + 1] = sums[i] + nums[i]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l - 1]) 796. å­çŸ©é˜µçš„å’Œ n, m, q = map(int, input().split())nums = [[0] * (m + 1) for _ in range(n + 1)]sums = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:]for i in range(1, n + 1): for j in range(1, m + 1): sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1 - 1][y2] - sums[x2][y1 - 1] + sums[x1 - 1][y1 - 1]) å·®åˆ†797. å·®åˆ† n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diffs = [0] * (n + 2)def insert(l, r, c): diffs[l] += c diffs[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diffs[i] print(nums[i], end= ) 798. å·®åˆ†çŸ©é˜µ n, m, q = map(int, input().split())nums = [[0] * (m + 2) for _ in range(n + 2)]diffs = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diffs[x1][y1] += c diffs[x1][y2 + 1] -= c diffs[x2 + 1][y1] -= c diffs[x2 + 1][y2 + 1] += cfor i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:] for j in range(1, m + 1): insert(i, j, i, j, tmps[j - 1])for _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diffs[i][j] print(nums[i][j], end= ) print() åŒæŒ‡é’ˆ799. æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ— n = int(input())nums = list(map(int, input().split()))dic = dict.fromkeys(nums, 0)j = res = 0for i in range(n): dic[nums[i]] += 1 while dic[nums[i]] 1: dic[nums[j]] -= 1 j += 1 res = max(res, i - j + 1)print(res) 800. æ•°ç»„å…ƒç´ çš„ç›®æ ‡å’Œ n, m, x = map(int, input().split())a = list(map(int, input().split()))b = list(map(int, input().split()))j = m - 1for i in range(n): while j and a[i] + b[j] x: j -= 1 if a[i] + b[j] == x: print(i, j) break äºŒè¿›åˆ¶801. äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° n = int(input())nums = list(map(int, input().split()))def lowbit(x): return x -xfor num in nums: res = 0 while num: num -= lowbit(num) res += 1 print(res, end= ) ç¦»æ•£åŒ–802. åŒºé—´å’Œ n, m = map(int, input().split())# adds = [list(map(int, input().split())) for _ in range(n)]# querys = [list(map(int, input().split())) for _ in range(m)]# indexs = [add[0] for add in adds]# for l, r in querys:# indexs += [l, r]adds, querys, indexs = [], [], []for i in range(n): x, c = map(int, input().split()) adds.append([x, c]) indexs.append(x)for i in range(m): l, r = map(int, input().split()) querys.append([l, r]) indexs.append(l) indexs.append(r)indexs.sort()indexs = list(set(indexs))n = len(indexs)def find(x): l, r = 0, n - 1 while l r: mid = l + r 1 if indexs[mid] = x: r = mid else: l = mid + 1 return l + 1nums = [0] * (n + 1)sums = [0] * (n + 1)for x, c in adds: nums[find(x)] += cfor i in range(1, n + 1): sums[i] = sums[i - 1] + nums[i]for l, r in querys: print(sums[find(r)] - sums[find(l) - 1]) åŒºé—´åˆå¹¶803. åŒºé—´åˆå¹¶ n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key=lambda x: x[0])st, ed = float(-inf), float(-inf)res = 0for l, r in nums: if ed l: res += 1 st = l ed = r else: ed = max(ed, r)print(res) æ•°æ®ç»“æ„å•é“¾è¡¨826. å•é“¾è¡¨ def insert_head(x): global head, idx e[idx] = x ne[idx] = head head = idx idx += 1 def insert(k, x): global idx e[idx] = x ne[idx] = ne[k] ne[k] = idx idx += 1 def remove(k): ne[k] = ne[ne[k]] N = 100010e, ne = [0] * N, [0] * Nhead, idx = -1, 0n = int(input())for _ in range(n): ops = input().split() if ops[0] == H: insert_head(int(ops[1])) elif ops[0] == I: insert(int(ops[1]) - 1, int(ops[2])) else: k = int(ops[1]) if not k: head = ne[head] remove(k - 1)i = headres = []while i != -1: res.append(e[i]) i = ne[i]print( .join(map(str, res))) åŒé“¾è¡¨827. åŒé“¾è¡¨ N = 100010e, l, r = [0] * N, [0] * N, [0] * Nr[0], l[1], idx = 1, 0, 2def insert(k, x): global idx e[idx] = x r[idx] = r[k] l[idx] = k l[r[k]] = idx r[k] = idx idx += 1def remove(k): r[l[k]] = r[k] l[r[k]] = l[k]n = int(input())for _ in range(n): ops = input().split() if ops[0] == L: insert(0, int(ops[1])) elif ops[0] == R: insert(l[1], int(ops[1])) elif ops[0] == IL: insert(l[int(ops[1]) + 1], int(ops[2])) elif ops[0] == IR: insert(int(ops[1]) + 1, int(ops[2])) else: remove(int(ops[1]) + 1)i = r[0]res = []while i != 1: res.append(e[i]) i = r[i]print( .join(map(str, res))) æ ˆ828. æ¨¡æ‹Ÿæ ˆ n = int(input())stack = []for _ in range(n): ops = input().split() if ops[0] == push: stack.append(ops[1]) elif ops[0] == pop: stack.pop() elif ops[0] == query: print(stack[-1]) elif ops[0] == empty: print(NO if stack else YES) 3302. è¡¨è¾¾å¼æ±‚å€¼ dic = (: 0, +: 1, -: 1, *: 2, /: 2ops, nums = [], []def new_eval(): b = nums.pop() a = nums.pop() o = ops.pop() if o == +: nums.append(a + b) elif o == -: nums.append(a - b) elif o == *: nums.append(a * b) elif o == /: nums.append(int(a / b))a = input()n = len(a)i = 0while i n: c = a[i] if c.isdigit(): j, x = i, 0 while j n and a[j].isdigit(): x = x * 10 + int(a[j]) j += 1 i = j - 1 nums.append(x) elif c == (: ops.append(c) elif c == ): while ops[-1] != (: new_eval() ops.pop() else: while ops and dic[ops[-1]] = dic[c]: new_eval() ops.append(c) i += 1while ops: new_eval()print(nums[-1]) é˜Ÿåˆ—829. æ¨¡æ‹Ÿé˜Ÿåˆ— import collectionsn = int(input())queue = collections.deque()for _ in range(n): ops = input().split() if ops[0] == push: queue.append(ops[1]) elif ops[0] == pop: queue.popleft() elif ops[0] == query: print(queue[0]) elif ops[0] == empty: print(NO if queue else YES) å•è°ƒæ ˆ830. å•è°ƒæ ˆ n = int(input())nums = list(map(int, input().split()))stack, res = [], []for num in nums: if not stack: stack.append(num) res.append(-1) continue while stack and num = stack[-1]: stack.pop() if not stack: res.append(-1) else: res.append(stack[-1]) stack.append(num)print( .join(map(str, res))) å•è°ƒé˜Ÿåˆ—154. æ»‘åŠ¨çª—å£ n, k = map(int, input().split())nums = list(map(int, input().split()))q = [0] * 1000010hh, tt = 0, -1res1, res2 = [], []for i in range(n): if hh = tt and i - k + 1 q[hh]: hh += 1 while hh = tt and nums[q[tt]] nums[i]: tt -= 1 tt += 1 q[tt] = i if i = k - 1: res1.append(nums[q[hh]])hh, tt = 0, -1for i in range(n): if hh = tt and i - k + 1 q[hh]: hh += 1 while hh = tt and nums[q[tt]] nums[i]: tt -= 1 tt += 1 q[tt] = i if i = k - 1: res2.append(nums[q[hh]])print( .join(map(str, res1)))print( .join(map(str, res2))) KMP831. KMPå­—ç¬¦ä¸² n = int(input())p = + input()m = int(input())s = + input()ne = [0] * 1000010j = 0for i in range(2, n + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = jj = 0res = []for i in range(1, m + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == n: res.append(i - j) j = ne[j]print( .join(map(str, res))) Trie835. Trieå­—ç¬¦ä¸²ç»Ÿè®¡ N = 10010tries = [[0] * 26 for _ in range(N)]cnt = [0] * Nidx = 1def insert(string): global idx p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: tries[p][t] = idx idx += 1 p = tries[p][t] cnt[p] += 1def query(string): p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: return 0 p = tries[p][t] return cnt[p]n = int(input())for _ in range(n): op, string = input().split() if op == I: insert(string) elif op == Q: print(query(string)) 143. æœ€å¤§å¼‚æˆ–å¯¹ N = 100010M = 31 * Ntries = [[0] * 2 for _ in range(M)]n = int(input())nums = list(map(int, input().split()))idx, res = 0, 0def insert(x): global idx p = 0 for i in range(32)[::-1]: u = x i 1 if not tries[p][u]: idx += 1 tries[p][u] = idx p = tries[p][u]def query(x): p, res = 0, 0 for i in range(32)[::-1]: u = x i 1 if tries[p][u^1]: res = res * 2 + u^1 p = tries[p][u^1] else: res = res * 2 + u p = tries[p][u] return resfor num in nums: insert(num) t = query(num) res = max(res, t^num)print(res) å¹¶æŸ¥é›†836. åˆå¹¶é›†åˆ n, m = map(int, input().split())p = [i for i in range(n + 1)]def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): op, a, b = input().split() a, b = int(a), int(b) if op == M: p[find(a)] = find(b) elif op == Q: if find(a) == find(b): print(Yes) else: print(No) 837. è¿é€šå—ä¸­ç‚¹çš„æ•°é‡ n, m = map(int, input().split())p = [i for i in range(n + 1)]size = [1] * (n + 1)def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): ops = input().split() if ops[0] == C: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): continue size[find(b)] += size[find(a)] p[find(a)] = find(b) elif ops[0] == Q1: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): print(Yes) else: print(No) elif ops[0] == Q2: print(size[find(int(ops[1]))]) 240. é£Ÿç‰©é“¾ n, m = map(int, input().split())p, d = [i for i in range(n + 1)], [0] * (n + 1)res = 0def find(x): if p[x] != x: t = find(p[x]) d[x] += d[p[x]] p[x] = t return p[x]for _ in range(m): op, x, y = map(int, input().split()) if x n or y n: res += 1 continue px, py = find(x), find(y) diff = (d[x] - d[y]) % 3 if op == 1: if px == py and diff: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] elif op == 2: if px == py and diff != 1: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] + 1print(res) å †838. å †æ’åº n, m = map(int, input().split())heap = [0] + list(map(int, input().split()))def down(k): t = k if 2 * k = n and heap[2 * k] heap[t]: t = 2 * k if 2 * k + 1 = n and heap[2 * k + 1] heap[t]: t = 2 * k + 1 if t != k: heap[t], heap[k] = heap[k], heap[t] down(t)for i in range(int(n / 2), -1, -1): down(i)for _ in range(m): print(heap[1], end= ) heap[1] = heap[n] n -= 1 down(1) 839. æ¨¡æ‹Ÿå † N = 100010heap, ph, hp = [0] * N, [0] * N, [0] * Nsize, idx = 0, 0n = int(input())def swap(a, b): ph[hp[a]], ph[hp[b]] = b, a hp[a], hp[b] = hp[b], hp[a] heap[a], heap[b] = heap[b], heap[a]def down(k): t = k if 2 * k = size and heap[2 * k] heap[t]: t = 2 * k if 2 * k + 1 = size and heap[2 * k + 1] heap[t]: t = 2 * k + 1 if t != k: swap(t, k) down(t)def up(k): while k // 2 and heap[k // 2] heap[k]: swap(k // 2, k) k //= 2for _ in range(n): ops = input().split() if ops[0] == I: size += 1 idx += 1 heap[size] = int(ops[1]) ph[idx] = size hp[size] = idx up(size) elif ops[0] == PM: print(heap[1]) elif ops[0] == DM: swap(1, size) size -= 1 down(1) elif ops[0] == D: k = ph[int(ops[1])] swap(k, size) size -= 1 down(k) up(k) elif ops[0] == C: k, x = ph[int(ops[1])], int(ops[2]) heap[k] = x down(k) up(k) å“ˆå¸Œè¡¨840. æ¨¡æ‹Ÿæ•£åˆ—è¡¨ æ‹‰é“¾æ³• N = 100003h, e, ne = [-1] * N, [0] * N, [0] * Nn = int(input())idx = 0def insert(x): global idx k = x % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1def find(x): k = x % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return Falsefor _ in range(n): op, x = input().split() if op == I: insert(int(x)) elif op == Q: if find(int(x)): print(Yes) else: print(No) å¼€æ”¾å¯»å€æ³• N = 200003null = 0x3f3f3f3fh = [null] * Nn = int(input())def find(x): k = x % N while h[k] != null and h[k] != x: k += 1 if k == N: k = 0 return kfor _ in range(n): op, x = input().split() k = find(int(x)) if op == I: h[k] = int(x) elif op == Q: if h[k] == int(x): print(Yes) else: print(No) python è‡ªå¸¦ from collections import defaultdictdic = defaultdict(int)n = int(input())for _ in range(n): op, x = input().split() if op == I: dic[x] += 1 elif op == Q: print(Yes if dic[x] else No) 841. å­—ç¬¦ä¸²å“ˆå¸Œ n, m = map(int, input().split())s = input()Q, P = 1 64, 131h, p = [0] * (n + 1), [1] * (n + 1)def get(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % Qfor i in range(1, n + 1): h[i] = (h[i - 1] * P + ord(s[i - 1])) % Q p[i] = (p[i - 1] * P) % Qfor _ in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(Yes) else: print(No) æœç´¢ä¸å›¾è®ºDFS842. æ’åˆ—æ•°å­— dfs åšæ³• n = int(input())path = [0] * nst = [False] * (n + 1)def dfs(x): if x == n: print( .join(map(str, path))) return for i in range(1, n + 1): if not st[i]: path[x] = i st[i] = True dfs(x + 1) st[i] = Falsedfs(0) python permutationæ–¹æ³• import itertoolsn = int(input())nums = [i for i in range(1, n + 1)]for res in itertools.permutations(nums, n): print( .join(map(str, res))) 843. n-çš‡åé—®é¢˜ å…¨æ’åˆ— n = int(input())g = [[. for _ in range(n)] for _ in range(n)]col, dg, udg = [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x): if x == n: for i in range(n): print(.join(map(str, g[i]))) print() return for y in range(n): if not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = Q col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x + 1) g[x][y] = . col[y] = dg[x + y] = udg[n - x + y] = 0dfs(0) åŸå§‹æš´åŠ›æšä¸¾ n = int(input())g = [[. for _ in range(n)] for _ in range(n)]row, col, dg, udg = [0] * n, [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x, y, s): if y == n: y = 0 x += 1 if x == n: if s == n: for i in range(n): print(.join(map(str, g[i]))) print() return if not row[x] and not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = Q row[x] = col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x, y + 1, s + 1) g[x][y] = . row[x] = col[y] = dg[x + y] = udg[n - x + y] = 0 dfs(x, y + 1, s)dfs(0, 0, 0) BFS844. èµ°è¿·å®« from collections import dequen, m = map(int, input().split())g = [list(map(int, input().split())) for _ in range(n)]path = [[-1] * m for _ in range(n)]prev = [[0] * m for _ in range(n)]q = deque()q.append((0, 0))path[0][0] = 0while q: a, b = q.popleft() for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): x = a + l y = b + r if 0 = x n and 0 = y m and not g[x][y] and path[x][y] == -1: q.append((x, y)) path[x][y] = path[a][b] + 1 prev[x][y] = (a, b)print(path[-1][-1])x, y = n - 1, m - 1while x 0 or y 0: x,y = prev[x][y] print(x,y) 845. å…«æ•°ç  from collections import dequestart = .join(input().split())queue = deque([start])d = start: 0target = 12345678xdef swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 idx2 else(idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:]def bfs(): while queue: t = queue.popleft() distance = d[t] if t == target: return distance idx = t.find(x) x, y = idx // 3, idx % 3 for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): a, b = x + l, y + r if 0 = a 3 and 0 = b 3: t = swap(t, a * 3 + b, idx) if t not in d: d[t] = distance + 1 queue.append(t) t = swap(t, a * 3 + b, idx) return -1print(bfs()) æ ‘ä¸å›¾çš„æ·±åº¦ä¼˜å…ˆéå†846. æ ‘çš„é‡å¿ƒ ç”¨é“¾è¡¨ä½œä¸ºé‚»æ¥è¡¨ n = int(input())h, e, ne = [-1] * (n + 1), [0] * (2 * n), [0] * (2 * n)state = [False] * (n + 1)idx, ans = 0, ndef add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxdef dfs(u): global ans state[u] = True size, res = 1, 0 cur = h[u] while cur != -1: j = e[cur] if not state[j]: s = dfs(j) res = max(res, s) size += s cur = ne[cur] res = max(res, n - size) ans = min(ans, res) return sizefor _ in range(n - 1): a, b = map(int, input().split()) add(a, b) add(b, a)dfs(1)print(ans) ä½¿ç”¨pythonçš„list[list] n = int(input())adj_list = [[] for _ in range(n + 1)]state = [False] * (n + 1)ans = nfor _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u): global ans state[u] = True size, res = 1, 0 for j in adj_list[u]: if not state[j]: s = dfs(j) res = max(res, s) size += s res = max(res, n - size) ans = min(ans, res) return sizedfs(1)print(ans) æ ‘ä¸å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†847. å›¾ä¸­ç‚¹çš„å±‚æ¬¡ from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)dist = [-1] * (n + 1)queue = deque([1])dist[1] = 0idx = 0def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b)def bfs(): while queue: node = queue.popleft() d = dist[node] if node == n: return d cur = h[node] while cur != -1: j = e[cur] if dist[j] == -1: queue.append(j) dist[j] = d + 1 cur = ne[cur] return -1print(bfs()) ä½¿ç”¨pythonçš„list[list] from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]d = [0] * (n + 1)queue = deque([1])for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def bfs(): while queue: cur = queue.popleft() distance = d[cur] if cur == n: return distance for j in adj_list[cur]: if not d[j]: d[j] = distance + 1 queue.append(j) return -1print(bfs()) æ‹“æ‰‘æ’åº848. æœ‰å‘å›¾çš„æ‹“æ‰‘åºåˆ— from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)d = [0] * (n + 1)idx = 0queue = deque()def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b) d[b] += 1def topsort(): for i in range(1, n + 1): if not d[i]: queue.append(i) res = [] while queue: node = queue.popleft() res.append(node) t = h[node] while t != -1: j = e[t] d[j] -= 1 if d[j] == 0: queue.append(j) t = ne[t] if len(res) == n: print( .join(map(str, res))) else: print(-1)topsort() ä½¿ç”¨pythonçš„list[list] from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]in_degree = [0] * (n + 1)queue = deque()for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) in_degree[b] += 1for i in range(1, n + 1): if not in_degree[i]: queue.append(i)res = []while queue: node = queue.popleft() res.append(node) for j in adj_list[node]: in_degree[j] -= 1 if not in_degree[j]: queue.append(j)if len(res) == n: print( .join(map(str, res)))else: print(-1) Dijkstra849. Dijkstraæ±‚æœ€çŸ­è·¯ I n, m = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]dist = [float(inf)] * (n + 1)state = [False] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)def dijkstra(): for _ in range(1, n + 1): t = min((j for j in range(1, n + 1) if not state[j]), key=lambda j: dist[j]) state[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], dist[t] + g[t][j]) print(dist[n] if dist[n] != float(inf) else -1)dijkstra() 850. Dijkstraæ±‚æœ€çŸ­è·¯ II import heapqn, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(inf)] * (n + 1)dist[1] = 0heap = []heapq.heappush(heap, (0, 1))s = set()for _ in range(m): x, y, z = map(int, input().split()) adj_list[x].append((y, z))while heap: d, node = heapq.heappop(heap) if node in s: continue s.add(node) for neighbor, weight in adj_list[node]: if dist[neighbor] dist[node] + weight: dist[neighbor] = dist[node] + weight heapq.heappush(heap, (dist[neighbor], neightbor))print(dist[n] if dist[n] != float(inf) else -1) bellman-ford853. æœ‰è¾¹æ•°é™åˆ¶çš„æœ€çŸ­è·¯ n, m, k = map(int, input().split())e = []dist = [float(inf)] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) e.append((a, b, c))for _ in range(k): backup = dist.copy() for a, b, w in e: dist[b] = min(dist[b], backup[a] + w)print(dist[n] if dist[n] != float(inf) else impossible) spfa851. spfaæ±‚æœ€çŸ­è·¯ from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(inf)] * (n + 1)state = [False] * (n + 1)queue = deque([1])dist[1] = 0state[1] = Truefor _ in range(m): a, b, w = map(int, input().split()) adj_list[a].append((b, w))while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] dist[cur] + weight: dist[neighbor] = dist[cur] + weight if not state[neighbor]: queue.append(neighbor) state[neighbor] = Trueprint(dist[n] if dist[n] != float(inf) else impossible) 852. spfaåˆ¤æ–­è´Ÿç¯ from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist, cnt = [0] * (n + 1), [0] * (n + 1)state = [True] * (n + 1)queue = deque([i for i in range(1, n + 1)])for _ in range(m): a, b, c = map(int, input().split()) adj_list[a].append((b, c))def spfa(): while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] dist[cur] + weight: dist[neighbor] = dist[cur] + weight cnt[neighbor] = cnt[cur] + 1 if cnt[neighbor] = n: return True if not state[neighbor]: queue.append(neighbor) state[neighbor] = True return Falseprint(Yes if spfa() else No) Floyd854. Floydæ±‚æœ€çŸ­è·¯ n, m, q = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): g[i][i] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = min(g[i][j], g[i][k] + g[k][j])for _ in range(q): a, b = map(int, input().split()) print(g[a][b] if g[a][b] != float(inf) else impossible) Prim858. Primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ n, m = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]state = [False] * (n + 1)dist = [float(inf)] * (n + 1)for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c) g[b][a] = g[a][b]def prim(): res = 0 for i in range(n): t = min((j for j in range(1, n + 1) if not state[j]), key = lambda x: dist[x]) if i and dist[t] == float(inf): return impossible if i: res += dist[t] for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) state[t] = True return resprint(prim()) Krustal859. Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ n, m = map(int, input().split())e = []p = [i for i in range(n + 1)]res, cnt = 0, 0def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m):\ta, b, c = map(int, input().split())\te.append((a, b, c))e.sort(key=lambda x: x[2])for a, b, c in e: a, b = find(a), find(b) if a != b: p[a] = b res += c cnt += 1print(res if cnt == n - 1 else impossible) æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾860. æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾ dfsä¼šçˆ†æ ˆ n, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, c): color[u] = c for neighbor in adj_list[u]: if not color[neighbor]: if not dfs(neighbor, c * -1): return False elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not colort[i]: if not dfs(i, 1): print(No) breakelse: print(Yes) bfs from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def bfs(u): queue = deque() queue.append((u, 1)) while queue: node, c = queue.popleft() color[node] = c for neighbor in adj_list[node]: if not color[neighbor]: queue.append((neighbor, c * -1)) elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not color[i]: if not bfs(i): print(No) breakelse: print(Yes) åŒˆç‰™åˆ©ç®—æ³•861. äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é… n1, n2, m = map(int, input().split())n = max(n1, n2)adj_list = [[] for _ in range(n + 1)]match = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def find(u): for neighbor in adj_list[u]: if not state[neighbor]: state[neighbor] = True if not match[neighbor] or find(match[neighbor]): match[neighbor] = u return True return Falseres = 0for i in range(1, n1 + 1): state = [0] * (n + 1) if find(i): res += 1print(res) æ•°å­¦çŸ¥è¯†è´¨æ•°866. è¯•é™¤æ³•åˆ¤å®šè´¨æ•° import mathn = int(input())def prime(x): if x 2: return False for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: return False return Truefor _ in range(n): x = int(input()) print(Yes if prime(x) else No) 867. åˆ†è§£è´¨å› æ•° import mathn = int(input())def divid(x): for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: s = 0 while x % i == 0: x //= i s += 1 print(i, s) if x 1: print(x, 1)for _ in range(n): x = int(input()) divid(x) print() 868. ç­›è´¨æ•° çº¿æ€§ç­›æ³•â€“æ¯ä¸ªåˆæ•°åªèƒ½è¢«è‡ªå·±çš„æœ€å°è´¨å› æ•°åˆ é™¤O(n) n = int(input())state = [True] * (n + 1)res = []for i in range(2, n + 1): if state[i]: res.append(i) j = 0 while res[j] * i = n: state[res[j] * i] = False if i % res[j] == 0: break j += 1print(len(res)) åŸƒæ°ç­›æ³•O(n lognlogn) n = int(input())state = [True] * (n + 1)res = 0for i in range(2, n + 1): if state[i]: res += 1 for j in range(2 * i, n + 1, i): state[j] = Falseprint(res) çº¦æ•°869. è¯•é™¤æ³•æ±‚çº¦æ•° import mathn = int(input())def divisor(x): res = [] for i in range(1, int(math.sqrt(x) + 1)): if x % i == 0: res.append(i) if i * i != x: res.append(x // i) res.sort() print( .join(map(str, res)))for _ in range(n): a = int(input()) divisor(a) 870. çº¦æ•°ä¸ªæ•° $N p^{\\alpha1}{1} * p^{\\alpha2}{2} * \\cdots * p^{\\alpha k}_{k}$ çº¦æ•°ä¸ªæ•°$res (a_{1} + 1) (a_{2} + 1) \\cdots (a_{k} + 1)$ import mathn = int(input())dict = def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for v in dict.values(): res = res * (v + 1) % (1e9 + 7)print(int(res)) 871. çº¦æ•°ä¹‹å’Œ çº¦æ•°ä¹‹å’Œ$res (p^{0}{1} + p^{1}{1} + \\cdots p^{a_{1}}{1}) * (p^{0}{2} + p^{1}{2} + \\cdots p^{a{2}}{2}) * \\cdots *(p^{0}{k} + p^{1}{k} + \\cdots p^{a{k}}_{k})$ import mathn = int(input())dict = MOD = int(1e9 + 7)def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for p, a in dict.items(): t = 1 while a: t = (t * p + 1) % MOD a -= 1 res = res * t % MODprint(res) 872. æœ€å¤§å…¬çº¦æ•° è¾—è½¬ç›¸é™¤æ³• n = int(input())def gcd(a, b): return gcd(b, a % b) if b else afor _ in range(n): a, b = map(int, input().split()) print(gcd(a, b)) pythonè‡ªå¸¦ import mathn = int(input())for _ in range(n): a, b = map(int, input().split()) print(math.gcd(a, b)) æ¬§æ‹‰å‡½æ•°873. æ¬§æ‹‰å‡½æ•° $\\varphi(1) 1$ å½“nä¸æ˜¯è´¨æ•°ï¼š$\\varphi(n) n * \\sum^{x}{i1}(1 - \\frac{1}{p{k}})$ å½“næ˜¯è´¨æ•°ï¼š$\\varphi(n) n - 1$ import mathn = int(input())def euler(x): res = x for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x 1: res *= (1 - 1 / x) print(int(res))for _ in range(n): x = int(input()) euler(x) 874. ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•° n = int(input())state = [False] * (n + 1)phi = [0] * (n + 1)phi[1] = 1primes = []def euler(x): for i in range(2, n + 1): if not state[i]: primes.append(i) phi[i] = i - 1 j = 0 while primes[j] * i = n: state[primes[j] * i] = True if i % primes[j] == 0: phi[primes[j] * i] = phi[i] * primes[j] break phi[primes[j] * i] = phi[i] * (primes[j] - 1) j += 1 print(sum(phi))euler(n) å¿«é€Ÿå¹‚875. å¿«é€Ÿå¹‚ è´¹é©¬å°å®šç†$a^{p - 1} \\equiv 1 \\ (mod \\enspace p)$ n = int(input())for _ in range(n): a, k, p = map(int, input().split()) res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p print(res) 876. å¿«é€Ÿå¹‚æ±‚é€†å…ƒ å½“nä¸ºè´¨æ•°æ—¶ï¼Œbçš„ä¹˜æ³•é€†å…ƒ$x b^{(n - 2)}$ å½“nä¸æ˜¯è´¨æ•°æ—¶ï¼Œä½¿ç”¨æ‹“å±•æ¬§å‡ é‡Œå¾—æ±‚é€†å…ƒ $a * x \\equiv 1 \\ (mod \\ p)$ n = int(input())def quick_mi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resfor _ in range(n): a, p = map(int, input().split()) print(quick_mi(a, p - 2, p) if a % p else impossible) æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•877. æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³• æ±‚è§£$ax + by gcd(a, b)$ å½“b0æ—¶ $ax+bya$ æ•…è€Œ $x1, y0$ å½“$b eq 0$æ—¶$x y \\prime, \\quad y x \\prime - \\lfloor\\frac{a}{b}\\rfloor * y \\prime$ n = int(input())def exgcd(a, b): if not b: return 1, 0 y, x = exgcd(b, a % b) y -= a // b * x return x, yfor _ in range(n): a, b = map(int, input().split()) print(*exgcd(a, b)) 878. çº¿æ€§åŒä½™æ–¹ç¨‹ å½“$gcd(a,m) \\mid b$æœ‰è§£ï¼Œæ±‚å‡ºä»¥ä¸€ç»„è§£ä½¿å¾—$a * x_{0} + m * y_{0} gcd(a,m)$ï¼Œ æ‰€ä»¥$x x_{0} * \\frac{b}{gcd(a,m)} % m$ n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(n): a, b, m = map(int, input().split()) d, x, _ = exgcd(a, m) print(impossible if b % d else x * b // d % m) ä¸­å›½å‰©ä½™å®šç†$Mm_{1} \\cdot m_{2} \\cdot \\cdots \\cdot m_{R}, \\quad M_{i} \\frac{M}{m_{i}}$, $M^{-1}{i}$è¡¨ç¤º$M_i$æ¨¡$m{i}$çš„é€†ï¼Œå³$M_i \\cdot m^{-1}{i} \\equiv 1 \\ (mod \\ m{i})$ $x a_1 \\cdot M_1 \\cdot M^{-1}{1} + a_2 \\cdot M_2 \\cdot M^{-1}{2} + \\cdots + a_k \\cdot M_k \\cdot M^{-1}_{k}$ 204. è¡¨è¾¾æ•´æ•°çš„å¥‡æ€ªæ–¹å¼ æ³¨ $m_1,m_2 \\cdots m_k$ ä¸ä¸¤ä¸¤äº’è´¨ n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ya1, m1 = map(int, input().split())for _ in range(n - 1): a2, m2 = map(int, input().split()) d, k1, _ = exgcd(a1, a2) if (m2 - m1) % d: print(-1) break k1 *= (m2 - m1) // d k1 %= a2 // d m1 += a1 * k1 a1 = a1 * a2 // delse: print(m1 % a1) é«˜æ–¯æ¶ˆå…ƒ883. é«˜æ–¯æ¶ˆå…ƒè§£çº¿æ€§æ–¹ç¨‹ç»„ n = int(input())g = [list(map(float, input().split())) for _ in range(n)]def gauss(): idx, zero = 0, 1e-6 for c in range(n): t = max(range(c, n), key=lambda x: abs(g[x][c])) if abs(g[t][c]) zero: continue g[idx][c:], g[t][c:] = g[t][c:], g[idx][c:] for i in range(n, c, -1): g[idx][i] /= g[idx][c] for i in range(idx + 1, n): if abs(g[i][c]) zero: for j in range(n, c - 1, -1): g[i][j] -= g[idx][j] * g[i][c] idx += 1 if idx n: for i in range(idx, n): if abs(g[i][n]) zero: print(No solution) return print(Infinite group solutions) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] -= g[i][j] * g[j][n] for i in range(n): print(fg[i][n]:.2f)gauss() 884. é«˜æ–¯æ¶ˆå…ƒè§£å¼‚æˆ–çº¿æ€§æ–¹ç¨‹ç»„ n = int(input())g = [list(map(int, input().split())) for _ in range(n)]def gauss(): idx = 0 for c in range(n): t = idx for i in range(idx, n): if g[i][c]: t = i break if not g[t][c]: continue g[t][c:], g[idx][c:] = g[idx][c:], g[t][c:] for i in range(idx + 1, n): if g[i][c]: for j in range(c, n + 1): g[i][j] ^= g[idx][j] idx += 1 if idx n: for i in range(idx, n): if g[i][n]: print(No solution) return print(Multiple sets of solutions) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] ^= g[i][j] g[j][n] for i in range(n): print(g[i][n])gauss() æ±‚ç»„åˆæ•°885. æ±‚ç»„åˆæ•° I $C^{b}{a} C^{b - 1}{a - 1} + C^{b}_{a - 1}$ n = int(input())N, MOD = 2010, int(1e9+7)g = [[1] + [0] * N for _ in range(N)]for i in range(N): for j in range(i + 1): g[i][j] = (g[i - 1][j] + g[i - 1][j - 1]) % MODfor _ in range(n): a, b = map(int, input().split()) print(g[a][b]) 886. æ±‚ç»„åˆæ•° II æ³¨ $\\frac{a}{b} \\enspace mod \\enspace p eq \\frac{a \\enspace mod \\enspace p}{b \\enspace mod \\enspace p}$ å¯ä»¥ç”¨é€†å…ƒè®¡ç®— $\\frac{a}{b} \\enspace mod \\enspace p a \\times b^{-1} \\enspace mod \\enspace p$ $C^{b}_{a} \\frac{a!}{b! * (a - b)!} a! * infact(b!) * infact((a - b)!)$ n = int(input())N, MOD = 100010, int(1e9 + 7)fact, infact = [1] * N, [1] * Ndef qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resfor i in range(1, N): fact[i] = fact[i - 1] * i % MOD infact[i] = infact[i - 1] * qmi(i, MOD - 2, MOD) % MODfor _ in range(n): a, b = map(int, input().split()) print(fact[a] * infact[b] * infact[a - b] % MOD) 887. æ±‚ç»„åˆæ•° III å¢å¡æ–¯å®šç† Lucas $O(logpNplogp)$ $C^{b}{a} \\equiv C^{\\frac{b}{p}}{\\frac{a}{p}} C^{b \\ mod \\ p}_{a \\ mod \\ p} \\ (mod \\ p)$ n = int(input())def qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resdef C(a, b): res = 1 i, j = 1, a while i = b: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1 return resdef lucas(a, b, p): if a p and b p: return C(a, b) else: return C(a % p, b % p) * lucas(a // p, b // p, p) % pfor _ in range(n): a, b, p = map(int, input().split()) print(lucas(a, b, p)) 888. æ±‚ç»„åˆæ•° IV import matha, b = map(int, input().split())print(math.factorial(a) // math.factorial(b) // math.factorial(a - b)) 889. æ»¡è¶³æ¡ä»¶çš„01åºåˆ— å¡ç‰¹å…°æ•° $ans C^{n}{2n} - C^{n - 1}{2n} \\frac{C^{n}_{2n}}{n + 1}$ n = int(input())p = int(1e9 + 7)def qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resres = 1i, j = 1, 2 * nwhile i = n: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1print(res * qmi(n + 1, p - 2, p) % p) ä½¿ç”¨å…¬å¼+pythonç¡¬è§£(å¾ˆæ…¢ï¼‰ import mathn = int(input())print(math.factorial(2 * n) // (math.factorial(n) ** 2 * (n + 1)) % int(1e9 + 7)) å®¹æ–¥åŸç†$$\\bigcup_{i1}^{m} S_{i}S_{1}+S_{2}+\\cdots+S_{m}-(S_{1} \\bigcap S_{2}+S_{1} \\bigcap S_{3}+\\ldots+S_{m-1} \\bigcap S_{m})+(S_{1} \\bigcap S_{2} \\bigcap S_{3}+\\ldots+S_{m-2} \\bigcap S_{m-1} \\bigcap S_{m})+\\ldots+(-1)^{m-1}(\\bigcap_{i1}^{m} S)$$ 890. èƒ½è¢«æ•´é™¤çš„æ•° n, m = map(int, input().split())p = list(map(int, input().split()))res = 0for i in range(1, 1 m): t, s = 1, 0 for j in range(m): if i j 1: if t * p[j] n: break t *= p[j] s += 1 else: if s 1: res += n // t else: res -= n // tprint(res) åšå¼ˆè®º891. Nimæ¸¸æˆ mex(S)ä¸ºæ±‚å‡ºä¸å±äºé›†åˆSçš„æœ€å°éè´Ÿæ•´æ•° n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(1, n): res ^= nums[i]print(Yes if res else No) 892. å°é˜¶-Nimæ¸¸æˆ n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(2, n, 2): res ^= nums[i]print(Yes if res else No) 893. é›†åˆ-Nimæ¸¸æˆ $SG(x)mex({SG(y_{1}),SG(y_{2})Â·Â·Â·Â·SG(y_{k})})$ $SG(G)SG(G_{1})\\oplus SG(G_{2}) \\oplus \\cdots \\oplus SG(G_{m})$ k = int(input())s = list(map(int, input().split()))n = int(input())nums = list(map(int, input().split()))f = [-1] * 10010def sg(x): if f[x] != -1: return f[x] S = sg(x - i) for i in s if x = i i = 0 while i in S: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(Yes if nim(n, nums) else No) 894. æ‹†åˆ†-Nimæ¸¸æˆ n = int(input())nums = list(map(int, input().split()))f = [-1] * 101def sg(x): if f[x] != -1: return f[x] s = set() for i in range(x): for j in range(i + 1): s.add(sg(i) ^ sg(j)) i = 0 while i in s: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(Yes if nim(n, nums) else No) åŠ¨æ€è§„åˆ’èƒŒåŒ…é—®é¢˜2. 01èƒŒåŒ…é—®é¢˜ äºŒç»´dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j = v[i]: f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])print(f[n][m]) ä¸€ç»´dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 3. å®Œå…¨èƒŒåŒ…é—®é¢˜ äºŒç»´dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j = v[i]: f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])print(f[n][m]) ä¸€ç»´dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): if j = v[i]: f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 4. å¤šé‡èƒŒåŒ…é—®é¢˜ I n, m = map(int, input().split())v, w, s = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b, c = map(int, input().split()) v[i] = a w[i] = b s[i] = cfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] k = 0 while k = s[i] and j = k * v[i]: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) k += 1print(f[n][m]) 5. å¤šé‡èƒŒåŒ…é—®é¢˜ II n, m = map(int, input().split())N = 20010v, w, f = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)idx = 1for _ in range(n): a, b, c = map(int, input().split()) k = 1 while k c: v[idx] = a * k w[idx] = b * k c -= k k *= 2 idx += 1 if c: v[idx] = a * c w[idx] = b * c idx += 1for i in range(1, idx): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 9. åˆ†ç»„èƒŒåŒ…é—®é¢˜ n, m = map(int, input().split())N = 101v = [[0] * N for _ in range(N)]w = [[0] * N for _ in range(N)]s, f = [0] * N, [0] * Nfor i in range(1, n + 1): s[i] = int(input()) for j in range(1, s[i] + 1): v[i][j], w[i][j] = map(int, input().split())for i in range(1, n + 1): for j in range(m, 0, -1): for k in range(1, s[i] + 1): if j = v[i][k]: f[j] = max(f[j], f[j - v[i][k]] + w[i][k])print(f[m]) çº¿æ€§DP898. æ•°å­—ä¸‰è§’å½¢ n = int(input())INF = -1e9a = [[INF] * (n + 1) for _ in range(n + 1)]f = [[INF] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): a[i] = [INF] + list(map(int, input().split()))f[1][1] = a[1][1]for i in range(2, n + 1): for j in range(1, i + 1): f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]print(max(f[n])) 895. æœ€é•¿ä¸Šå‡å­åºåˆ— n = int(input())a = [0] + list(map(int, input().split()))f = [1] * (n + 1)for i in range(1, n + 1): for j in range(1, i): if a[i] a[j]: f[i] = max(f[i], f[j] + 1)print(max(f)) 897. æœ€é•¿å…¬å…±å­åºåˆ— n, m = map(int, input().split())a, b = + input(), + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = max(f[i - 1][j], f[i][j - 1]) if a[i] == b[j]: f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)print(f[n][m]) 902. æœ€çŸ­ç¼–è¾‘è·ç¦» n = int(input())a = + input()m = int(input())b = + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): f[i][0] = ifor i in range(1, m + 1): f[0][i] = ifor i in range(1, n + 1): for j in range(1, m + 1): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1print(f[n][m]) 899. ç¼–è¾‘è·ç¦» n, m = map(int, input().split())N = 11a = [[0] * N for _ in range(n + 1)]f = [[0] * N for _ in range(N)]for i in range(n): a[i] = + input()def distance(a, b): la, lb = len(a), len(b) for i in range(1, la): f[i][0] = i for i in range(1, lb): f[0][i] = i for i in range(1, la): for j in range(1, lb): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1 return f[la - 1][lb - 1]for _ in range(m): b, limit = input().split() b, limit = + b, int(limit) res = 0 for i in range(n): if distance(a[i], b) = limit: res += 1 print(res) 896. æœ€é•¿ä¸Šå‡å­åºåˆ— II n = int(input())a = list(map(int, input().split()))q = [0] * (n + 1)res = 0for i in range(n): l, r = 0, res while l r: mid = l + r + 1 1 if q[mid] a[i]: l = mid else: r = mid - 1 q[r + 1] = a[i] res = max(res, r + 1)print(res) åŒºé—´DP282. çŸ³å­åˆå¹¶ n = int(input())s = [0] + list(map(int, input().split()))f = [[0] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): s[i] += s[i - 1]for length in range(2, n + 1): for i in range(1, n - length + 2): l, r = i, i + length - 1 f[l][r] = float(inf) for k in range(l, r): f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1])print(f[1][n]) è®¡æ•°ç±»DP900. æ•´æ•°åˆ’åˆ† n = int(input())MOD = int(1e9 + 7)f = [0] * (n + 1)f[0] = 1for i in range(1, n + 1): for j in range(i, n + 1): f[j] = (f[j] + f[j - i]) % MODprint(f[n]) æ•°ä½ç»Ÿè®¡DP338. è®¡æ•°é—®é¢˜ def power10(x): res = 1 while x: res *= 10 x -= 1 return resdef count(n, x): res = cnt = 0 m = n while m: cnt += 1 m //= 10 for i in range(1, cnt + 1): r = power10(i - 1) l = n // (r * 10) if x: res += l * r else: res += (l - 1) * r d = n // r % 10 if d == x: res += n % r + 1 elif d x: res += r return reswhile True: a, b = map(int, input().split()) if not a and not b: break if a b: a, b = b, a for i in range(10): print(count(b, i) - count(a - 1, i), end= ) print() çŠ¶æ€å‹ç¼©DP291. è’™å¾·é‡Œå®‰çš„æ¢¦æƒ³ def fun(n, m): f = [[0] * (1 12) for _ in range(12)] st = [False] * (1 12) for i in range(1 n): cnt = 0 st[i] = True for j in range(n): if i j 1: if cnt 1: st[i] = False cnt = 0 else: cnt += 1 if cnt 1: st[i] = False f[0][0] = 1 for i in range(1, m + 1): for j in range(1 n): for k in range(1 n): if not (j k) and st[j | k]: f[i][j] += f[i - 1][k] return f[m][0]while True: a, b = map(int, input().split()) if not a and not b: break print(fun(a, b)) 91. æœ€çŸ­Hamiltonè·¯å¾„ n = int(input())g = [list(map(int, input().split())) for _ in range(n)]f = [[float(inf)] * n for _ in range(1 n)]f[1][0] = 0for i in range(1 n): for j in range(n): if i j 1: for k in range(n): if i k 1: f[i][j] = min(f[i][j], f[i - (1 j)][k] + g[k][j])print(f[i - (1 n)][n - 1]) æ ‘å½¢DP285. æ²¡æœ‰ä¸Šå¸çš„èˆä¼š import syssys.setrecursionlimit(3000)n = int(input())f = [[0] * 2 for _ in range(n + 1)]parent = [False] * (n + 1)happy = [0] * (n + 1)adj_list = [[] for _ in range(n + 1)]for i in range(1, n + 1): happy[i] = int(input())for _ in range(n - 1): a, b = map(int, input().split()) parent[a] = True adj_list[b].append(a)root = 1while parent[root]: root += 1def dfs(u): f[u][1] = happy[u] for j in adj_list[u]: dfs(j) f[u][0] += max(f[j][1], f[j][0]) f[u][1] += f[j][0]dfs(root)print(max(f[root][0], f[root][1])) è®°å¿†åŒ–æœç´¢901. æ»‘é›ª n, m = map(int, input().split())f = [[0] * m for _ in range(n)]g = [list(map(int, input().split())) for _ in range(n)]dircts = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dp(x, y): if f[x][y]: return f[x][y] f[x][y] = 1 for l, r in dircts: a, b = x + l, b + r if 0 = a n and 0 = b m and g[a][b] g[x][y]: f[x][y] = max(f[x][y], dp(a, b) + 1) return f[x][y]res = 0for i in range(n): for j in range(m): res = max(res, dp(i, j))print(res) è´ªå¿ƒåŒºé—´é—®é¢˜905. åŒºé—´é€‰ç‚¹ n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x:x[1])res, end = 0, float(-inf)for a, b in g: if a end: res += 1 end = bprint(res) 908. æœ€å¤§ä¸ç›¸äº¤åŒºé—´æ•°é‡ n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[1])res, end = 0, float(-inf)for a, b in g: if a end: res += 1 end = bprint(res) 906. åŒºé—´åˆ†ç»„ import heapqn = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()res = []for a, b in g: if res and a res[0]: heapq.heappop(res) heapq.heappush(res, b)print(len(res)) 907. åŒºé—´è¦†ç›– s, t = map(int, input().split())n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()idx = res = 0flag = Falsewhile idx n: r = float(-inf) while idx n and g[idx][0] = s: r = max(r, g[idx][1]) idx += 1 if r s: break s = r res += 1 if r = t: flag = True breakprint(res if flag else -1) Huffmanæ ‘148. åˆå¹¶æœå­ import heapqn = int(input())nums = list(map(int, input().split()))heapq.heapify(nums)res = 0while len(nums) 1: a, b = heapq.heappop(nums), heapq.heappop(nums) res += a + b heapq.heappush(nums, a + b)print(res) æ’åºä¸ç­‰å¼913. æ’é˜Ÿæ‰“æ°´ n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for i, num in enumerate(nums): res += num * (n - i - 1)print(res) ç»å¯¹å€¼ä¸ç­‰å¼104. è´§ä»“é€‰å€ n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for num in nums: res += abs(num - nums[n // 2])print(res) æ¨å…¬å¼125. è€æ‚æŠ€çš„ç‰› n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[0] + x[1])res, pre_sum = float(-inf), 0for w, s in g: res = max(res, pre_sum - s) pre_sum += wprint(res) Pythonæ³¨æ„å®¹æ˜“çˆ†æ ˆimport sys sys.setrecursionlimit(100000) â€‹ pythonè¯­è¨€å¹¶ä¸é€‚åˆé€’å½’ç®—æ³•ï¼Œå› ä¸ºå…¶é€’å½’æ·±åº¦ï¼Œè¯­è¨€è‡ªèº«å°±æœ‰é™åˆ¶ï¼Œå°±ç®—å»é™¤é™åˆ¶ï¼Œå…¶ä¹Ÿä¼šå¼€è¾Ÿå¤§é‡ç©ºé—´ äº¤æ¢strä¸¤ä¸ªå­—ç¬¦çš„ä½ç½®def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 idx2 else (idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:] å¢å¼ºå‡½æ•°è®°å¿†åŠ›import functools#lru_cacheï¼Œå¯ä»¥ä¸ºå‡½æ•°è‡ªåŠ¨å¢åŠ è®°å¿†åŒ–çš„èƒ½åŠ›ï¼Œåœ¨é€’å½’ç®—æ³•ä¸­éå¸¸å®ç”¨@functools.lru_cache() ç§‘å­¦è®¡æ•°æ³•è¦ç”¨int# é»˜è®¤çš„ç§‘å­¦è®¡æ•°æ³•æ˜¯å°æ•°è¡¨ç¤ºMOD = int(1e9 + 7) å–æ¨¡%è¿ç®—c++ä¸­ cout 7 % 4 endl; // 3cout -7 % 4 endl; // -3cout 7 % -4 endl; // 3cout -7 % -4 endl; // -3 pythonä¸­ print(7 % 4) // 3print(-7 % 4) // 1print(7 % -4) // -1print(-7 % -4) // -3 C è¯­è¨€å’Œ Python åœ¨æ¶‰åŠæœ‰è´Ÿæ•°å–ä½™è¿ç®—æ—¶ï¼Œç»“æœå¯èƒ½ä¸åŒçš„æœ¬è´¨åŸå› æ˜¯ï¼šC è¯­è¨€ä¸­æ˜¯å‘0å–æ•´ï¼Œè€Œ Python æ˜¯å‘è´Ÿæ— ç©·å–æ•´ã€‚ è¾“å…¥from sys import stdininput = lambda: stdin.readline().strip()n, m = map(int, input().split()) å¸¸ç”¨å‡½æ•°import mathmath.factorial(x)math.gcd(a, b) äºŒåˆ†äºŒåˆ†æ‰¾å·¦è¾¹ç•Œl=mid+1,æ‰¾å³è¾¹ç•Œr=mid-1ï¼Œå¹¶ä¸”mid=l+r+11","tags":["ç®—æ³•","Python","AcWing"],"categories":["ç®—æ³•"]},{"title":"Pythonå…¥é—¨","path":"/2024/01/01/pythonå…¥é—¨/","content":"å‡ºå¤„ ç±»å‹å’Œè¿ç®—#-- å¯»æ±‚å¸®åŠ©: dir(obj) # ç®€å•çš„åˆ—å‡ºå¯¹è±¡objæ‰€åŒ…å«çš„æ–¹æ³•åç§°ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ help(obj.func) # æŸ¥è¯¢obj.funcçš„å…·ä½“ä»‹ç»å’Œç”¨æ³• #-- æµ‹è¯•ç±»å‹çš„ä¸‰ç§æ–¹æ³•ï¼Œæ¨èç¬¬ä¸‰ç§ if type(L) == type([]): print(L is list) if type(L) == list: print(L is list) if isinstance(L, list): print(L is list) #-- Pythonæ•°æ®ç±»å‹ï¼šå“ˆå¸Œç±»å‹ã€ä¸å¯å“ˆå¸Œç±»å‹ # å“ˆå¸Œç±»å‹ï¼Œå³åœ¨åŸåœ°ä¸èƒ½æ”¹å˜çš„å˜é‡ç±»å‹ï¼Œä¸å¯å˜ç±»å‹ã€‚å¯åˆ©ç”¨hashå‡½æ•°æŸ¥çœ‹å…¶hashå€¼ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºå­—å…¸çš„key æ•°å­—ç±»å‹ï¼šint, float, decimal.Decimal, fractions.Fraction, complex å­—ç¬¦ä¸²ç±»å‹ï¼šstr, bytes å…ƒç»„ï¼štuple å†»ç»“é›†åˆï¼šfrozenset å¸ƒå°”ç±»å‹ï¼šTrue, False None # ä¸å¯hashç±»å‹ï¼šåŸåœ°å¯å˜ç±»å‹ï¼šlistã€dictå’Œsetã€‚å®ƒä»¬ä¸å¯ä»¥ä½œä¸ºå­—å…¸çš„keyã€‚#-- æ•°å­—å¸¸é‡ 1234, -1234, 0, 999999999 # æ•´æ•° 1.23, 1., 3.14e-10, 4E210, 4.0e+210 # æµ®ç‚¹æ•° 0o177, 0x9ff, 0X9FF, 0b101010 # å…«è¿›åˆ¶ã€åå…­è¿›åˆ¶ã€äºŒè¿›åˆ¶æ•°å­— 3+4j, 3.0+4.0j, 3J # å¤æ•°å¸¸é‡ï¼Œä¹Ÿå¯ä»¥ç”¨complex(real, image)æ¥åˆ›å»º hex(I), oct(I), bin(I) # å°†åè¿›åˆ¶æ•°è½¬åŒ–ä¸ºåå…­è¿›åˆ¶ã€å…«è¿›åˆ¶ã€äºŒè¿›åˆ¶è¡¨ç¤ºçš„â€œå­—ç¬¦ä¸²â€ int(string, base) # å°†å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•´æ•°ï¼Œbaseä¸ºè¿›åˆ¶æ•° # 2.xä¸­ï¼Œæœ‰ä¸¤ç§æ•´æ•°ç±»å‹ï¼šä¸€èˆ¬æ•´æ•°ï¼ˆ32ä½ï¼‰å’Œé•¿æ•´æ•°ï¼ˆæ— ç©·ç²¾åº¦ï¼‰ã€‚å¯ä»¥ç”¨læˆ–Lç»“å°¾ï¼Œè¿«ä½¿ä¸€èˆ¬æ•´æ•°æˆä¸ºé•¿æ•´æ•° float(inf), float(-inf), float(nan) # æ— ç©·å¤§, æ— ç©·å°, éæ•° #-- æ•°å­—çš„è¡¨è¾¾å¼æ“ä½œç¬¦ yield x # ç”Ÿæˆå™¨å‡½æ•°å‘é€åè®® lambda args: expression # ç”ŸæˆåŒ¿åå‡½æ•° x if y else z # ä¸‰å…ƒé€‰æ‹©è¡¨è¾¾å¼ x and y, x or y, not x # é€»è¾‘ä¸ã€é€»è¾‘æˆ–ã€é€»è¾‘é x in y, x not in y # æˆå‘˜å¯¹è±¡æµ‹è¯• x is y, x is not y # å¯¹è±¡å®ä½“æµ‹è¯• xy, x=y, xy, x=y, x==y, x!=y # å¤§å°æ¯”è¾ƒï¼Œé›†åˆå­é›†æˆ–è¶…é›†å€¼ç›¸ç­‰æ€§æ“ä½œç¬¦ 1 a 3 # Pythonä¸­å…è®¸è¿ç»­æ¯”è¾ƒ x|y, xy, x^y # ä½æˆ–ã€ä½ä¸ã€ä½å¼‚æˆ– xy, xy # ä½æ“ä½œï¼šxå·¦ç§»ã€å³ç§»yä½ +, -, *, /, //, %, ** # çœŸé™¤æ³•ã€flooré™¤æ³•ï¼šè¿”å›ä¸å¤§äºçœŸé™¤æ³•ç»“æœçš„æ•´æ•°å€¼ã€å–ä½™ã€å¹‚è¿ç®— -x, +x, ~x # ä¸€å…ƒå‡æ³•ã€è¯†åˆ«ã€æŒ‰ä½æ±‚è¡¥ï¼ˆå–åï¼‰ x[i], x[i:j:k] # ç´¢å¼•ã€åˆ†ç‰‡ int(3.14), float(3) # å¼ºåˆ¶ç±»å‹è½¬æ¢ #-- æ•´æ•°å¯ä»¥åˆ©ç”¨bit_lengthå‡½æ•°æµ‹è¯•æ‰€å çš„ä½æ•° a = 1; a.bit_length() # 1 a = 1024; a.bit_length() # 11 #-- reprå’Œstræ˜¾ç¤ºæ ¼å¼çš„åŒºåˆ« repræ ¼å¼ï¼šé»˜è®¤çš„äº¤äº’æ¨¡å¼å›æ˜¾ï¼Œäº§ç”Ÿçš„ç»“æœçœ‹èµ·æ¥å®ƒä»¬å°±åƒæ˜¯ä»£ç ã€‚ stræ ¼å¼ï¼šæ‰“å°è¯­å¥ï¼Œè½¬åŒ–æˆä¸€ç§å¯¹ç”¨æˆ·æ›´åŠ å‹å¥½çš„æ ¼å¼ã€‚ #-- æ•°å­—ç›¸å…³çš„æ¨¡å— # mathæ¨¡å— # Decimalæ¨¡å—ï¼šå°æ•°æ¨¡å— import decimal from decimal import Decimal Decimal(0.01) + Decimal(0.02) # è¿”å›Decimal(0.03) decimal.getcontext().prec = 4 # è®¾ç½®å…¨å±€ç²¾åº¦ä¸º4 å³å°æ•°ç‚¹åè¾¹4ä½ # Fractionæ¨¡å—ï¼šåˆ†æ•°æ¨¡å— from fractions import Fraction x = Fraction(4, 6) # åˆ†æ•°ç±»å‹ 4/6 x = Fraction(0.25) # åˆ†æ•°ç±»å‹ 1/4 æ¥æ”¶å­—ç¬¦ä¸²ç±»å‹çš„å‚æ•°#-- é›†åˆset setæ˜¯ä¸€ä¸ªæ— åºä¸é‡å¤å…ƒç´ é›†, åŸºæœ¬åŠŸèƒ½åŒ…æ‹¬å…³ç³»æµ‹è¯•å’Œæ¶ˆé™¤é‡å¤å…ƒç´ ã€‚ setæ”¯æŒunion(è”åˆ), intersection(äº¤), difference(å·®)å’Œsymmetric difference(å¯¹ç§°å·®é›†)ç­‰æ•°å­¦è¿ç®—ã€‚ setæ”¯æŒx in set, len(set), for x in setã€‚ setä¸è®°å½•å…ƒç´ ä½ç½®æˆ–è€…æ’å…¥ç‚¹, å› æ­¤ä¸æ”¯æŒindexing, slicing, æˆ–å…¶å®ƒç±»åºåˆ—çš„æ“ä½œ s = set([3,5,9,10]) # åˆ›å»ºä¸€ä¸ªæ•°å€¼é›†åˆï¼Œè¿”å›3, 5, 9, 10 t = set(Hello) # åˆ›å»ºä¸€ä¸ªå­—ç¬¦çš„é›†åˆï¼Œè¿”å›l, H, e, o a = t | s; t.union(s) # t å’Œ sçš„å¹¶é›† b = t s; t.intersection(s) # t å’Œ sçš„äº¤é›† c = t â€“ s; t.difference(s) # æ±‚å·®é›†ï¼ˆé¡¹åœ¨tä¸­, ä½†ä¸åœ¨sä¸­ï¼‰ d = t ^ s; t.symmetric_difference(s) # å¯¹ç§°å·®é›†ï¼ˆé¡¹åœ¨tæˆ–sä¸­, ä½†ä¸ä¼šåŒæ—¶å‡ºç°åœ¨äºŒè€…ä¸­ï¼‰ t.add(x); t.remove(H) # å¢åŠ /åˆ é™¤ä¸€ä¸ªitem s.update([10,37,42]) # åˆ©ç”¨[......]æ›´æ–°sé›†åˆ x in s, x not in s # é›†åˆä¸­æ˜¯å¦å­˜åœ¨æŸä¸ªå€¼ s.issubset(t); s = t # æµ‹è¯•æ˜¯å¦ s ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½åœ¨ t ä¸­ s.issuperset(t); s = t # æµ‹è¯•æ˜¯å¦ t ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½åœ¨ s ä¸­ s.copy(); s.discard(x); # åˆ é™¤sä¸­x s.clear() # æ¸…ç©ºs x**2 for x in [1, 2, 3, 4] # é›†åˆè§£æï¼Œç»“æœï¼š16, 1, 4, 9 x for x in spam # é›†åˆè§£æï¼Œç»“æœï¼ša, p, s, m #-- é›†åˆfrozensetï¼Œä¸å¯å˜å¯¹è±¡ setæ˜¯å¯å˜å¯¹è±¡ï¼Œå³ä¸å­˜åœ¨hashå€¼ï¼Œä¸èƒ½ä½œä¸ºå­—å…¸çš„é”®å€¼ã€‚åŒæ ·çš„è¿˜æœ‰listç­‰(tupleæ˜¯å¯ä»¥ä½œä¸ºå­—å…¸keyçš„) frozensetæ˜¯ä¸å¯å˜å¯¹è±¡ï¼Œå³å­˜åœ¨hashå€¼ï¼Œå¯ä½œä¸ºå­—å…¸çš„é”®å€¼ frozensetå¯¹è±¡æ²¡æœ‰addã€removeç­‰æ–¹æ³•ï¼Œä½†æœ‰union/intersection/differenceç­‰æ–¹æ³• a = set([1, 2, 3]) b = set() b.add(a) # error: setæ˜¯ä¸å¯å“ˆå¸Œç±»å‹ b.add(frozenset(a)) # okï¼Œå°†setå˜ä¸ºfrozensetï¼Œå¯å“ˆå¸Œ#-- å¸ƒå°”ç±»å‹bool type(True) # è¿”å›class bool isinstance(False, int) # boolç±»å‹å±äºæ•´å‹ï¼Œæ‰€ä»¥è¿”å›True True == 1; True is 1 # è¾“å‡º(True, False) #-- åŠ¨æ€ç±»å‹ç®€ä»‹ å˜é‡åé€šè¿‡å¼•ç”¨ï¼ŒæŒ‡å‘å¯¹è±¡ã€‚ Pythonä¸­çš„â€œç±»å‹â€å±äºå¯¹è±¡ï¼Œè€Œä¸æ˜¯å˜é‡ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½åŒ…å«æœ‰å¤´éƒ¨ä¿¡æ¯ï¼Œæ¯”å¦‚ç±»å‹æ ‡ç¤ºç¬¦ å¼•ç”¨è®¡æ•°å™¨ç­‰ #å…±äº«å¼•ç”¨åŠåœ¨åŸå¤„ä¿®æ”¹ï¼šå¯¹äºå¯å˜å¯¹è±¡ï¼Œè¦æ³¨æ„å°½é‡ä¸è¦å…±äº«å¼•ç”¨ï¼ #å…±äº«å¼•ç”¨å’Œç›¸ç­‰æµ‹è¯•ï¼š L = [1], M = [1], L is M # è¿”å›False L = M = [1, 2, 3], L is M # è¿”å›Trueï¼Œå…±äº«å¼•ç”¨ #å¢å¼ºèµ‹å€¼å’Œå…±äº«å¼•ç”¨ï¼šæ™®é€š+å·ä¼šç”Ÿæˆæ–°çš„å¯¹è±¡ï¼Œè€Œå¢å¼ºèµ‹å€¼+=ä¼šåœ¨åŸå¤„ä¿®æ”¹ L = M = [1, 2] L = L + [3, 4] # L = [1, 2, 3, 4], M = [1, 2] L += [3, 4] # L = [1, 2, 3, 4], M = [1, 2, 3, 4]#-- å¸¸è§å­—ç¬¦ä¸²å¸¸é‡å’Œè¡¨è¾¾å¼ S = # ç©ºå­—ç¬¦ä¸² S = spamâ€™s # åŒå¼•å·å’Œå•å¼•å·ç›¸åŒ S = s p\\ta\\x00m # è½¬ä¹‰å­—ç¬¦ S = spam # ä¸‰é‡å¼•å·å­—ç¬¦ä¸²ï¼Œä¸€èˆ¬ç”¨äºå‡½æ•°è¯´æ˜ S = r\\temp # Rawå­—ç¬¦ä¸²ï¼Œä¸ä¼šè¿›è¡Œè½¬ä¹‰ï¼ŒæŠ‘åˆ¶è½¬ä¹‰ S = bSpam # Python3ä¸­çš„å­—èŠ‚å­—ç¬¦ä¸² S = uspam # Python2.6ä¸­çš„Unicodeå­—ç¬¦ä¸² s1+s2, s1*3, s[i], s[i:j], len(s) # å­—ç¬¦ä¸²æ“ä½œ a %s parrot % kind # å­—ç¬¦ä¸²æ ¼å¼åŒ–è¡¨è¾¾å¼ a 1 0 parrot.format(kind, red)# å­—ç¬¦ä¸²æ ¼å¼åŒ–æ–¹æ³• for x in s: print(x) # å­—ç¬¦ä¸²è¿­ä»£ï¼Œæˆå‘˜å…³ç³» [x*2 for x in s] # å­—ç¬¦ä¸²åˆ—è¡¨è§£æ ,.join([a, b, c]) # å­—ç¬¦ä¸²è¾“å‡ºï¼Œç»“æœï¼ša,b,c #-- å†…ç½®strå¤„ç†å‡½æ•°ï¼š str1 = stringobject str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title() # å…¨éƒ¨å¤§å†™ï¼Œå…¨éƒ¨å°å†™ã€å¤§å°å†™è½¬æ¢ï¼Œé¦–å­—æ¯å¤§å†™ï¼Œæ¯ä¸ªå•è¯çš„é¦–å­—æ¯éƒ½å¤§å†™ str1.ljust(width) # è·å–å›ºå®šé•¿åº¦ï¼Œå·¦å¯¹é½ï¼Œå³è¾¹ä¸å¤Ÿç”¨ç©ºæ ¼è¡¥é½ str1.rjust(width) # è·å–å›ºå®šé•¿åº¦ï¼Œå³å¯¹é½ï¼Œå·¦è¾¹ä¸å¤Ÿç”¨ç©ºæ ¼è¡¥é½ str1.center(width) # è·å–å›ºå®šé•¿åº¦ï¼Œä¸­é—´å¯¹é½ï¼Œä¸¤è¾¹ä¸å¤Ÿç”¨ç©ºæ ¼è¡¥é½ str1.zfill(width) # è·å–å›ºå®šé•¿åº¦ï¼Œå³å¯¹é½ï¼Œå·¦è¾¹ä¸è¶³ç”¨0è¡¥é½ str1.find(t,start,end) # æŸ¥æ‰¾å­—ç¬¦ä¸²ï¼Œå¯ä»¥æŒ‡å®šèµ·å§‹åŠç»“æŸä½ç½®æœç´¢ str1.rfind(t) # ä»å³è¾¹å¼€å§‹æŸ¥æ‰¾å­—ç¬¦ä¸² str1.count(t) # æŸ¥æ‰¾å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•° #ä¸Šé¢æ‰€æœ‰æ–¹æ³•éƒ½å¯ç”¨indexä»£æ›¿ï¼Œä¸åŒçš„æ˜¯ä½¿ç”¨indexæŸ¥æ‰¾ä¸åˆ°ä¼šæŠ›å¼‚å¸¸ï¼Œè€Œfindè¿”å›-1 str1.replace(old,new) # æ›¿æ¢å‡½æ•°ï¼Œæ›¿æ¢oldä¸ºnewï¼Œå‚æ•°ä¸­å¯ä»¥æŒ‡å®šmaxReplaceTimesï¼Œå³æ›¿æ¢æŒ‡å®šæ¬¡æ•°çš„oldä¸ºnew str1.strip(); # é»˜è®¤åˆ é™¤ç©ºç™½ç¬¦ str1.strip(d); # åˆ é™¤str1å­—ç¬¦ä¸²ä¸­å¼€å¤´ã€ç»“å°¾å¤„ï¼Œä½äº d åˆ é™¤åºåˆ—çš„å­—ç¬¦ str1.lstrip(); str1.lstrip(d); # åˆ é™¤str1å­—ç¬¦ä¸²ä¸­å¼€å¤´å¤„ï¼Œä½äº d åˆ é™¤åºåˆ—çš„å­—ç¬¦ str1.rstrip(); str1.rstrip(d) # åˆ é™¤str1å­—ç¬¦ä¸²ä¸­ç»“å°¾å¤„ï¼Œä½äº d åˆ é™¤åºåˆ—çš„å­—ç¬¦ str1.startswith(start) # æ˜¯å¦ä»¥startå¼€å¤´ str1.endswith(end) # æ˜¯å¦ä»¥endç»“å°¾ str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper() # åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å…¨ä¸ºå­—ç¬¦ã€æ•°å­—ã€å°å†™ã€å¤§å†™#-- ä¸‰é‡å¼•å·ç¼–å†™å¤šè¡Œå­—ç¬¦ä¸²å—ï¼Œå¹¶ä¸”åœ¨ä»£ç æŠ˜è¡Œå¤„åµŒå…¥æ¢è¡Œå­—ç¬¦ mantra = hello world hello python hello my friend # mantraä¸ºhello world hello python hello my friend #-- ç´¢å¼•å’Œåˆ†ç‰‡ï¼š S[0], S[len(S)â€“1], S[-1] # ç´¢å¼• S[1:3], S[1:], S[:-1], S[1:10:2] # åˆ†ç‰‡ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æŒ‡å®šæ­¥é•¿ï¼Œå¦‚`S[1:10:2]`æ˜¯ä»1ä½åˆ°10ä½æ²¡éš”2ä½è·å–ä¸€ä¸ªå­—ç¬¦ã€‚#-- å­—ç¬¦ä¸²è½¬æ¢å·¥å…·ï¼š int(42), str(42) # è¿”å›(42, 42) float(4.13), str(4.13) # è¿”å›(4.13, 4.13) ord(s), chr(115) # è¿”å›(115, s) int(1001, 2) # å°†å­—ç¬¦ä¸²ä½œä¸ºäºŒè¿›åˆ¶æ•°å­—ï¼Œè½¬åŒ–ä¸ºæ•°å­—ï¼Œè¿”å›9 bin(13), oct(13), hex(13) # å°†æ•´æ•°è½¬åŒ–ä¸ºäºŒè¿›åˆ¶/å…«è¿›åˆ¶/åå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œè¿”å›(0b1101, 015, 0xd) #-- å¦ç±»å­—ç¬¦ä¸²è¿æ¥ name = wang hong # å•è¡Œï¼Œname = wanghong name = wang \\ hong # å¤šè¡Œï¼Œname = wanghong#-- Pythonä¸­çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–å®ç°1--å­—ç¬¦ä¸²æ ¼å¼åŒ–è¡¨è¾¾å¼ åŸºäºCè¯­è¨€çš„printæ¨¡å‹ï¼Œå¹¶ä¸”åœ¨å¤§å¤šæ•°çš„ç°æœ‰çš„è¯­è¨€ä¸­ä½¿ç”¨ã€‚ é€šç”¨ç»“æ„ï¼š%[(name)][flag][width].[precision]typecode this is %d %s bird % (1, dead) # ä¸€èˆ¬çš„æ ¼å¼åŒ–è¡¨è¾¾å¼ %s---%s---%s % (42, 3.14, [1, 2, 3]) # å­—ç¬¦ä¸²è¾“å‡ºï¼š42---3.14---[1, 2, 3] %d...%6d...%-6d...%06d % (1234, 1234, 1234, 1234) # å¯¹é½æ–¹å¼åŠå¡«å……ï¼š1234... 1234...1234 ...001234 x = 1.23456789 %e | %f | %g % (x, x, x) # å¯¹é½æ–¹å¼ï¼š1.234568e+00 | 1.234568 | 1.23457 %6.2f*%-6.2f*%06.2f*%+6.2f % (x, x, x, x) # å¯¹é½æ–¹å¼ï¼š 1.23*1.23 *001.23* +1.23 %(name1)d---%(name2)s % name1:23, name2:value2 # åŸºäºå­—å…¸çš„æ ¼å¼åŒ–è¡¨è¾¾å¼ %(name)s is %(age)d % vars() # vars()å‡½æ•°è°ƒç”¨è¿”å›ä¸€ä¸ªå­—å…¸ï¼ŒåŒ…å«äº†æ‰€æœ‰æœ¬å‡½æ•°è°ƒç”¨æ—¶å­˜åœ¨çš„å˜é‡ #-- Pythonä¸­çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–å®ç°2--å­—ç¬¦ä¸²æ ¼å¼åŒ–è°ƒç”¨æ–¹æ³• # æ™®é€šè°ƒç”¨ 0, 1 and 2.format(spam, ham, eggs) # åŸºäºä½ç½®çš„è°ƒç”¨ motto and pork.format(motto = spam, pork = ham) # åŸºäºKeyçš„è°ƒç”¨ motto and 0.format(ham, motto = spam) # æ··åˆè°ƒç”¨ # æ·»åŠ é”® å±æ€§ åç§»é‡ (import sys) my 1[spam] runs 0.platform.format(sys, spam:laptop) # åŸºäºä½ç½®çš„é”®å’Œå±æ€§ config[spam] sys.platform.format(sys = sys, config = spam:laptop) # åŸºäºKeyçš„é”®å’Œå±æ€§ first = 0[0], second = 0[1].format([A, B, C]) # åŸºäºä½ç½®çš„åç§»é‡ # å…·ä½“æ ¼å¼åŒ– 0:e, 1:.3e, 2:g.format(3.14159, 3.14159, 3.14159) # è¾“å‡º3.141590e+00, 3.142e+00, 3.14159 fieldname:format_spec.format(......) # è¯´æ˜: fieldnameæ˜¯æŒ‡å®šå‚æ•°çš„ä¸€ä¸ªæ•°å­—æˆ–å…³é”®å­—, åè¾¹å¯è·Ÿå¯é€‰çš„.nameæˆ–[index]æˆåˆ†å¼•ç”¨ format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type] fill ::= any character #å¡«å……å­—ç¬¦ align ::= | | = | ^ #å¯¹é½æ–¹å¼ sign ::= + | - | #ç¬¦å·è¯´æ˜ width ::= integer #å­—ç¬¦ä¸²å®½åº¦ precision ::= integer #æµ®ç‚¹æ•°ç²¾åº¦ type ::= b | c | d | e | E | f | F | g | G | n | o | s | x | X | % # ä¾‹å­: =0:10 = 1:10.format(spam, 123.456) # è¾“å‡º=spam = 123.456 =0:10=.format(test) # è¾“å‡º= test= =0:10=.format(test) # è¾“å‡º=test = =0:^10=.format(test) # è¾“å‡º= test = 0:X, 1:o, 2:b.format(255, 255, 255) # è¾“å‡ºFF, 377, 11111111 My name is 0:1..format(Fred, 8) # è¾“å‡ºMy name is Fred . åŠ¨æ€æŒ‡å®šå‚æ•°#-- å¸¸ç”¨åˆ—è¡¨å¸¸é‡å’Œæ“ä½œ L = [[1, 2], string, ] # åµŒå¥—åˆ—è¡¨ L = list(spam) # åˆ—è¡¨åˆå§‹åŒ– L = list(range(0, 4)) # åˆ—è¡¨åˆå§‹åŒ– list(map(ord, spam)) # åˆ—è¡¨è§£æ len(L) # æ±‚åˆ—è¡¨é•¿åº¦ L.count(value) # æ±‚åˆ—è¡¨ä¸­æŸä¸ªå€¼çš„ä¸ªæ•° L.append(obj) # å‘åˆ—è¡¨çš„å°¾éƒ¨æ·»åŠ æ•°æ®ï¼Œæ¯”å¦‚append(2)ï¼Œæ·»åŠ å…ƒç´ 2 L.insert(index, obj) # å‘åˆ—è¡¨çš„æŒ‡å®šindexä½ç½®æ·»åŠ æ•°æ®ï¼ŒindexåŠå…¶ä¹‹åçš„æ•°æ®åç§» L.extend(interable) # é€šè¿‡æ·»åŠ iterableä¸­çš„å…ƒç´ æ¥æ‰©å±•åˆ—è¡¨ï¼Œæ¯”å¦‚extend([2])ï¼Œæ·»åŠ å…ƒç´ 2ï¼Œæ³¨æ„å’Œappendçš„åŒºåˆ« L.index(value, [start, [stop]]) # è¿”å›åˆ—è¡¨ä¸­å€¼valueçš„ç¬¬ä¸€ä¸ªç´¢å¼• L.pop([index]) # åˆ é™¤å¹¶è¿”å›indexå¤„çš„å…ƒç´ ï¼Œé»˜è®¤ä¸ºåˆ é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´  L.remove(value) # åˆ é™¤åˆ—è¡¨ä¸­çš„valueå€¼ï¼Œåªåˆ é™¤ç¬¬ä¸€æ¬¡å‡ºç°çš„valueçš„å€¼ L.reverse() # åè½¬åˆ—è¡¨ L.sort(cmp=None, key=None, reverse=False) # æ’åºåˆ—è¡¨ a = [1, 2, 3], b = a[10:] # æ³¨æ„ï¼Œè¿™é‡Œä¸ä¼šå¼•å‘IndexErrorå¼‚å¸¸ï¼Œåªä¼šè¿”å›ä¸€ä¸ªç©ºçš„åˆ—è¡¨[] a = [], a += [1] # è¿™é‡Œå®åœ¨åŸæœ‰åˆ—è¡¨çš„åŸºç¡€ä¸Šè¿›è¡Œæ“ä½œï¼Œå³åˆ—è¡¨çš„idæ²¡æœ‰æ”¹å˜ a = [], a = a + [1] # è¿™é‡Œæœ€åçš„aè¦æ„å»ºä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼Œå³açš„idå‘ç”Ÿäº†å˜åŒ– #-- ç”¨åˆ‡ç‰‡æ¥åˆ é™¤åºåˆ—çš„æŸä¸€æ®µ a = [1, 2, 3, 4, 5, 6, 7] a[1:4] = [] # a = [1, 5, 6, 7] a = [0, 1, 2, 3, 4, 5, 6, 7] del a[::2] # å»é™¤å¶æ•°é¡¹(å¶æ•°ç´¢å¼•çš„)ï¼Œa = [1, 3, 5, 7] #-- å¸¸ç”¨å­—å…¸å¸¸é‡å’Œæ“ä½œ D = D = spam:2, tol:ham:1 # åµŒå¥—å­—å…¸ D = dict.fromkeys([s, d], 8) # s: 8, d: 8 D = dict(name = tom, age = 12) # age: 12, name: tom D = dict([(name, tom), (age, 12)]) # age: 12, name: tom D = dict(zip([name, age], [tom, 12])) # age: 12, name: tom D.keys(); D.values(); D.items() # å­—å…¸é”®ã€å€¼ä»¥åŠé”®å€¼å¯¹ D.get(key, default) # getå‡½æ•° D.update(D_other) # åˆå¹¶å­—å…¸ï¼Œå¦‚æœå­˜åœ¨ç›¸åŒçš„é”®å€¼ï¼ŒD_otherçš„æ•°æ®ä¼šè¦†ç›–æ‰Dçš„æ•°æ® D.pop(key, [D]) # åˆ é™¤å­—å…¸ä¸­é”®å€¼ä¸ºkeyçš„é¡¹ï¼Œè¿”å›é”®å€¼ä¸ºkeyçš„å€¼ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤å€¼Dï¼Œå¦åˆ™å¼‚å¸¸ D.popitem() # popå­—å…¸ä¸­éšæœºçš„ä¸€é¡¹ï¼ˆä¸€ä¸ªé”®å€¼å¯¹ï¼‰ D.setdefault(k[, d]) # è®¾ç½®Dä¸­æŸä¸€é¡¹çš„é»˜è®¤å€¼ã€‚å¦‚æœkå­˜åœ¨ï¼Œåˆ™è¿”å›D[k]ï¼Œå¦åˆ™è®¾ç½®D[k]=dï¼ŒåŒæ—¶è¿”å›D[k]ã€‚ del D # åˆ é™¤å­—å…¸ del D[key] # åˆ é™¤å­—å…¸çš„æŸä¸€é¡¹ if key in D: if key not in D: # æµ‹è¯•å­—å…¸é”®æ˜¯å¦å­˜åœ¨ # å­—å…¸æ³¨æ„äº‹é¡¹ï¼šï¼ˆ1ï¼‰å¯¹æ–°ç´¢å¼•èµ‹å€¼ä¼šæ·»åŠ ä¸€é¡¹ï¼ˆ2ï¼‰å­—å…¸é”®ä¸ä¸€å®šéå¾—æ˜¯å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥ä¸ºä»»ä½•çš„ä¸å¯å˜å¯¹è±¡ # ä¸å¯å˜å¯¹è±¡ï¼šè°ƒç”¨å¯¹è±¡è‡ªèº«çš„ä»»æ„æ–¹æ³•ï¼Œä¹Ÿä¸ä¼šæ”¹å˜è¯¥å¯¹è±¡è‡ªèº«çš„å†…å®¹ï¼Œè¿™äº›æ–¹æ³•ä¼šåˆ›å»ºæ–°çš„å¯¹è±¡å¹¶è¿”å›ã€‚ # å­—ç¬¦ä¸²ã€æ•´æ•°ã€tupleéƒ½æ˜¯ä¸å¯å˜å¯¹è±¡ï¼Œdictã€setã€listéƒ½æ˜¯å¯å˜å¯¹è±¡ D[(1,2,3)] = 2 # tupleä½œä¸ºå­—å…¸çš„key#-- å­—å…¸è§£æ D = k:8 for k in [s, d] # s: 8, d: 8 D = k:v for (k, v) in zip([name, age], [tom, 12]) # age: 12, name: tom #-- å­—å…¸çš„ç‰¹æ®Šæ–¹æ³•__missing__ï¼šå½“æŸ¥æ‰¾æ‰¾ä¸åˆ°keyæ—¶ï¼Œä¼šæ‰§è¡Œè¯¥æ–¹æ³• class Dict(dict): def __missing__(self, key): self[key] = [] return self[key] dct = dict() dct[foo].append(1) # è¿™æœ‰ç‚¹ç±»ä¼¼äºcollections.defalutdict dct[foo] # [1] #-- å…ƒç»„å’Œåˆ—è¡¨çš„å”¯ä¸€åŒºåˆ«åœ¨äºå…ƒç»„æ˜¯ä¸å¯å˜å¯¹è±¡ï¼Œåˆ—è¡¨æ˜¯å¯å˜å¯¹è±¡ a = [1, 2, 3] # a[1] = 0, OK a = (1, 2, 3) # a[1] = 0, Error a = ([1, 2],) # a[0][1] = 0, OK a = [(1, 2)] # a[0][1] = 0, Error #-- å…ƒç»„çš„ç‰¹æ®Šè¯­æ³•: é€—å·å’Œåœ†æ‹¬å· D = (12) # æ­¤æ—¶Dä¸ºä¸€ä¸ªæ•´æ•° å³D = 12 D = (12, ) # æ­¤æ—¶Dä¸ºä¸€ä¸ªå…ƒç»„ å³D = (12, ) #-- æ–‡ä»¶åŸºæœ¬æ“ä½œ output = open(rC:\\spam, w) # æ‰“å¼€è¾“å‡ºæ–‡ä»¶ï¼Œç”¨äºå†™ input = open(data, r) # æ‰“å¼€è¾“å…¥æ–‡ä»¶ï¼Œç”¨äºè¯»ã€‚æ‰“å¼€çš„æ–¹å¼å¯ä»¥ä¸ºw, r, a, wb, rb, abç­‰ fp.read([size]) # sizeä¸ºè¯»å–çš„é•¿åº¦ï¼Œä»¥byteä¸ºå•ä½ fp.readline([size]) # è¯»ä¸€è¡Œï¼Œå¦‚æœå®šä¹‰äº†sizeï¼Œæœ‰å¯èƒ½è¿”å›çš„åªæ˜¯ä¸€è¡Œçš„ä¸€éƒ¨åˆ† fp.readlines([size]) # æŠŠæ–‡ä»¶æ¯ä¸€è¡Œä½œä¸ºä¸€ä¸ªlistçš„ä¸€ä¸ªæˆå‘˜ï¼Œå¹¶è¿”å›è¿™ä¸ªlistã€‚å…¶å®å®ƒçš„å†…éƒ¨æ˜¯é€šè¿‡å¾ªç¯è°ƒç”¨readline()æ¥å®ç°çš„ã€‚å¦‚æœæä¾›sizeå‚æ•°ï¼Œsizeæ˜¯è¡¨ç¤ºè¯»å–å†…å®¹çš„æ€»é•¿ã€‚ fp.readable() # æ˜¯å¦å¯è¯» fp.write(str) # æŠŠstrå†™åˆ°æ–‡ä»¶ä¸­ï¼Œwrite()å¹¶ä¸ä¼šåœ¨strååŠ ä¸Šä¸€ä¸ªæ¢è¡Œç¬¦ fp.writelines(seq) # æŠŠseqçš„å†…å®¹å…¨éƒ¨å†™åˆ°æ–‡ä»¶ä¸­(å¤šè¡Œä¸€æ¬¡æ€§å†™å…¥) fp.writeable() # æ˜¯å¦å¯å†™ fp.close() # å…³é—­æ–‡ä»¶ã€‚ fp.flush() # æŠŠç¼“å†²åŒºçš„å†…å®¹å†™å…¥ç¡¬ç›˜ fp.fileno() # è¿”å›ä¸€ä¸ªé•¿æ•´å‹çš„â€æ–‡ä»¶æ ‡ç­¾â€œ fp.isatty() # æ–‡ä»¶æ˜¯å¦æ˜¯ä¸€ä¸ªç»ˆç«¯è®¾å¤‡æ–‡ä»¶ï¼ˆunixç³»ç»Ÿä¸­çš„ï¼‰ fp.tell() # è¿”å›æ–‡ä»¶æ“ä½œæ ‡è®°çš„å½“å‰ä½ç½®ï¼Œä»¥æ–‡ä»¶çš„å¼€å¤´ä¸ºåŸç‚¹ fp.next() # è¿”å›ä¸‹ä¸€è¡Œï¼Œå¹¶å°†æ–‡ä»¶æ“ä½œæ ‡è®°ä½ç§»åˆ°ä¸‹ä¸€è¡Œã€‚æŠŠä¸€ä¸ªfileç”¨äºfor â€¦ in fileè¿™æ ·çš„è¯­å¥æ—¶ï¼Œå°±æ˜¯è°ƒç”¨next()å‡½æ•°æ¥å®ç°éå†çš„ã€‚ fp.seek(offset[,whence]) # å°†æ–‡ä»¶æ‰“å¼€æ“ä½œæ ‡è®°ç§»åˆ°offsetçš„ä½ç½®ã€‚whenceä¸º0è¡¨ç¤ºä»å¤´å¼€å§‹è®¡ç®—ï¼Œ1è¡¨ç¤ºä»¥å½“å‰ä½ç½®ä¸ºåŸç‚¹è®¡ç®—ã€‚2è¡¨ç¤ºä»¥æ–‡ä»¶æœ«å°¾ä¸ºåŸç‚¹è¿›è¡Œè®¡ç®—ã€‚ fp.seekable() # æ˜¯å¦å¯ä»¥seek fp.truncate([size]) # æŠŠæ–‡ä»¶è£æˆè§„å®šçš„å¤§å°ï¼Œé»˜è®¤çš„æ˜¯è£åˆ°å½“å‰æ–‡ä»¶æ“ä½œæ ‡è®°çš„ä½ç½®ã€‚ for line in open(data): print(line) # ä½¿ç”¨forè¯­å¥ï¼Œæ¯”è¾ƒé€‚ç”¨äºæ‰“å¼€æ¯”è¾ƒå¤§çš„æ–‡ä»¶ with open(data) as file: print(file.readline()) # ä½¿ç”¨withè¯­å¥ï¼Œå¯ä»¥ä¿è¯æ–‡ä»¶å…³é—­ with open(data) as file: lines = file.readlines() # ä¸€æ¬¡è¯»å…¥æ–‡ä»¶æ‰€æœ‰è¡Œï¼Œå¹¶å…³é—­æ–‡ä»¶ open(f.txt, encoding = latin-1) # Python3.x Unicodeæ–‡æœ¬æ–‡ä»¶ open(f.bin, rb) # Python3.x äºŒè¿›åˆ¶bytesæ–‡ä»¶ # æ–‡ä»¶å¯¹è±¡è¿˜æœ‰ç›¸åº”çš„å±æ€§ï¼šbuffer closed encoding errors line_buffering name newlinesç­‰ #-- å…¶ä»– # Pythonä¸­çš„çœŸå‡å€¼å«ä¹‰ï¼š1. æ•°å­—å¦‚æœéé›¶ï¼Œåˆ™ä¸ºçœŸï¼Œ0ä¸ºå‡ã€‚ 2. å…¶ä»–å¯¹è±¡å¦‚æœéç©ºï¼Œåˆ™ä¸ºçœŸ # é€šå¸¸æ„ä¹‰ä¸‹çš„ç±»å‹åˆ†ç±»ï¼š1. æ•°å­—ã€åºåˆ—ã€æ˜ å°„ã€‚ 2. å¯å˜ç±»å‹å’Œä¸å¯å˜ç±»å‹è¯­æ³•å’Œè¯­å¥#-- èµ‹å€¼è¯­å¥çš„å½¢å¼ spam = spam # åŸºæœ¬å½¢å¼ spam, ham = spam, ham # å…ƒç»„èµ‹å€¼å½¢å¼ [spam, ham] = [s, h] # åˆ—è¡¨èµ‹å€¼å½¢å¼ a, b, c, d = abcd # åºåˆ—èµ‹å€¼å½¢å¼ a, *b, c = spam # åºåˆ—è§£åŒ…å½¢å¼ï¼ˆPython3.xä¸­æ‰æœ‰ï¼‰ spam = ham = no # å¤šç›®æ ‡èµ‹å€¼è¿ç®—ï¼Œæ¶‰åŠåˆ°å…±äº«å¼•ç”¨ spam += 42 # å¢å¼ºèµ‹å€¼ï¼Œæ¶‰åŠåˆ°å…±äº«å¼•ç”¨#-- åºåˆ—èµ‹å€¼ åºåˆ—è§£åŒ… [a, b, c] = (1, 2, 3) # a = 1, b = 2, c = 3 a, b, c, d = spam # a = s, b = p, c = a, d = m a, b, c = range(3) # a = 0, b = 1, c = 2 a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4] *a, b = [1, 2, 3, 4] # a = [1, 2, 3], b = 4 a, *b, c = [1, 2, 3, 4] # a = 1, b = [2, 3], c = 4 # å¸¦æœ‰*æ—¶ ä¼šä¼˜å…ˆåŒ¹é…*ä¹‹å¤–çš„å˜é‡ å¦‚ a, *b, c = [1, 2] # a = 1, c = 2, b = []#-- printå‡½æ•°åŸå‹ print(value, ..., sep= , end= , file=sys.stdout, flush=False) # æµçš„é‡å®šå‘ print(hello world) # ç­‰äºsys.stdout.write(hello world) temp = sys.stdout # åŸæœ‰æµçš„ä¿å­˜ sys.stdout = open(log.log, a) # æµçš„é‡å®šå‘ print(hello world) # å†™å…¥åˆ°æ–‡ä»¶log.log sys.stdout.close() sys.stdout = temp # åŸæœ‰æµçš„å¤åŸ #-- Pythonä¸­andæˆ–oræ€»æ˜¯è¿”å›å¯¹è±¡(å·¦è¾¹çš„å¯¹è±¡æˆ–å³è¾¹çš„å¯¹è±¡) ä¸”å…·æœ‰çŸ­è·¯æ±‚å€¼çš„ç‰¹æ€§ 1 or 2 or 3 # è¿”å› 1 1 and 2 and 3 # è¿”å› 3#-- if/elseä¸‰å…ƒè¡¨è¾¾ç¬¦ï¼ˆifè¯­å¥åœ¨è¡Œå†…ï¼‰ A = 1 if X else 2 A = 1 if X else (2 if Y else 3) # ä¹Ÿå¯ä»¥ä½¿ç”¨and-orè¯­å¥ï¼ˆä¸€æ¡è¯­å¥å®ç°å¤šä¸ªif-elseï¼‰ a = 6 result = (a 20 and big than 20 or a 10 and big than 10 or a 5 and big than 5) # è¿”å›big than 5#-- Pythonçš„whileè¯­å¥æˆ–è€…forè¯­å¥å¯ä»¥å¸¦elseè¯­å¥ å½“ç„¶ä¹Ÿå¯ä»¥å¸¦continue/break/passè¯­å¥ while a 1: anything else: anything # elseè¯­å¥ä¼šåœ¨å¾ªç¯ç»“æŸåæ‰§è¡Œï¼Œé™¤éåœ¨å¾ªç¯ä¸­æ‰§è¡Œäº†breakï¼ŒåŒæ ·çš„è¿˜æœ‰forè¯­å¥ for i in range(5): anything else: anything#-- forå¾ªç¯çš„å…ƒç»„èµ‹å€¼ for (a, b) in [(1, 2), (3, 4)]: # æœ€ç®€å•çš„èµ‹å€¼ for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: # è‡ªåŠ¨è§£åŒ…èµ‹å€¼ for ((a, b), c) in [((1, 2), 3), (XY, 6)]: # è‡ªåŠ¨è§£åŒ… a = X, b = Y, c = 6 for (a, *b) in [(1, 2, 3), (4, 5, 6)]: # è‡ªåŠ¨è§£åŒ…èµ‹å€¼#-- åˆ—è¡¨è§£æè¯­æ³• M = [[1,2,3], [4,5,6], [7,8,9]] res = [sum(row) for row in M] # G = [6, 15, 24] ä¸€èˆ¬çš„åˆ—è¡¨è§£æ ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ res = [c * 2 for c in spam] # [ss, pp, aa, mm] res = [a * b for a in [1, 2] for b in [4, 5]] # å¤šè§£æè¿‡ç¨‹ è¿”å›[4, 5, 8, 10] res = [a for a in [1, 2, 3] if a 2] # å¸¦åˆ¤æ–­æ¡ä»¶çš„è§£æè¿‡ç¨‹ res = [a if a 0 else 0 for a in [-1, 0, 1]] # å¸¦åˆ¤æ–­æ¡ä»¶çš„é«˜çº§è§£æè¿‡ç¨‹ # ä¸¤ä¸ªåˆ—è¡¨åŒæ—¶è§£æï¼šä½¿ç”¨zipå‡½æ•° for teama, teamb in zip([Packers, 49ers], [Ravens, Patriots]): print(teama + vs. + teamb) # å¸¦ç´¢å¼•çš„åˆ—è¡¨è§£æï¼šä½¿ç”¨enumerateå‡½æ•° for index, team in enumerate([Packers, 49ers, Ravens, Patriots]): print(index, team) # è¾“å‡º0, Packers 1, 49ers ...... #-- ç”Ÿæˆå™¨è¡¨è¾¾å¼ G = (sum(row) for row in M) # ä½¿ç”¨å°æ‹¬å·å¯ä»¥åˆ›å»ºæ‰€éœ€ç»“æœçš„ç”Ÿæˆå™¨generator object next(G), next(G), next(G) # è¾“å‡º(6, 15, 24) G = sum(row) for row in M # G = 6, 15, 24 è§£æè¯­æ³•è¿˜å¯ä»¥ç”Ÿæˆé›†åˆå’Œå­—å…¸ G = i:sum(M[i]) for i in range(3) # G = 0: 6, 1: 15, 2: 24#-- æ–‡æ¡£å­—ç¬¦ä¸²:å‡ºç°åœ¨Moduleçš„å¼€ç«¯ä»¥åŠå…¶ä¸­å‡½æ•°æˆ–ç±»çš„å¼€ç«¯ ä½¿ç”¨ä¸‰é‡å¼•å·å­—ç¬¦ä¸² module document def func(): function document print() class Employee(object): class document print() print(func.__doc__) # è¾“å‡ºå‡½æ•°æ–‡æ¡£å­—ç¬¦ä¸² print(Employee.__doc__) # è¾“å‡ºç±»çš„æ–‡æ¡£å­—ç¬¦ä¸² #-- å‘½åæƒ¯ä¾‹: ä»¥å•ä¸€ä¸‹åˆ’çº¿å¼€å¤´çš„å˜é‡å(_X)ä¸ä¼šè¢«from module import*ç­‰è¯­å¥å¯¼å…¥ å‰åæœ‰ä¸¤ä¸ªä¸‹åˆ’çº¿çš„å˜é‡å(__X__)æ˜¯ç³»ç»Ÿå®šä¹‰çš„å˜é‡åï¼Œå¯¹è§£é‡Šå™¨æœ‰ç‰¹æ®Šæ„ä¹‰ ä»¥ä¸¤ä¸ªä¸‹åˆ’çº¿å¼€å¤´ä½†ä¸ä»¥ä¸‹åˆ’çº¿ç»“å°¾çš„å˜é‡å(__X)æ˜¯ç±»çš„æœ¬åœ°(ç§æœ‰)å˜é‡ #-- åˆ—è¡¨è§£æ inæˆå‘˜å…³ç³»æµ‹è¯• map sorted zip enumerateå†…ç½®å‡½æ•°ç­‰éƒ½ä½¿ç”¨äº†è¿­ä»£åè®® first line in open(test.txt) # inæµ‹è¯• è¿”å›Trueæˆ–False list(map(str.upper, open(t))) # mapå†…ç½®å‡½æ•° sorted(iter([2, 5, 8, 3, 1])) # sortedå†…ç½®å‡½æ•° list(zip([1, 2], [3, 4])) # zipå†…ç½®å‡½æ•° [(1, 3), (2, 4)]#-- delè¯­å¥: æ‰‹åŠ¨åˆ é™¤æŸä¸ªå˜é‡ del X#-- è·å–åˆ—è¡¨çš„å­è¡¨çš„æ–¹æ³•: x = [1,2,3,4,5,6] x[:3] # å‰3ä¸ª[1,2,3] x[1:5] # ä¸­é—´4ä¸ª[2,3,4,5] x[-3:] # æœ€å3ä¸ª[4,5,6] x[::2] # å¥‡æ•°é¡¹[1,3,5] x[1::2] # å¶æ•°é¡¹[2,4,6] #-- æ‰‹åŠ¨è¿­ä»£ï¼šiterå’Œnext L = [1, 2] I = iter(L) # Iä¸ºLçš„è¿­ä»£å™¨ I.next() # è¿”å›1 I.next() # è¿”å›2 I.next() # Error:StopIteration #-- Pythonä¸­çš„å¯è¿­ä»£å¯¹è±¡ 1.rangeè¿­ä»£å™¨ 2.mapã€zipå’Œfilterè¿­ä»£å™¨ 3.å­—å…¸è§†å›¾è¿­ä»£å™¨ï¼šD.keys()), D.items()ç­‰ 4.æ–‡ä»¶ç±»å‹ å‡½æ•°è¯­æ³•è§„åˆ™#-- å‡½æ•°ç›¸å…³çš„è¯­å¥å’Œè¡¨è¾¾å¼ myfunc(spam) # å‡½æ•°è°ƒç”¨ def myfunc(): # å‡½æ•°å®šä¹‰ return None # å‡½æ•°è¿”å›å€¼ global a # å…¨å±€å˜é‡ nonlocal x # åœ¨å‡½æ•°æˆ–å…¶ä»–ä½œç”¨åŸŸä¸­ä½¿ç”¨å¤–å±‚ï¼ˆéå…¨å±€ï¼‰å˜é‡ yield x # ç”Ÿæˆå™¨å‡½æ•°è¿”å› lambda # åŒ¿åå‡½æ•° #-- Pythonå‡½æ•°å˜é‡åè§£æ:LEGBåŸåˆ™ï¼Œå³: local(functin) -- encloseing function locals -- global(module) -- build-in(python) è¯´æ˜:ä»¥ä¸‹è¾¹çš„å‡½æ•°makerä¸ºä¾‹ åˆ™ç›¸å¯¹äºactionè€Œè¨€ Xä¸ºLocal Nä¸ºEncloseing #-- åµŒå¥—å‡½æ•°ä¸¾ä¾‹:å·¥å‚å‡½æ•° def maker(N): def action(X): return X ** N return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X#-- åµŒå¥—å‡½æ•°ä¸¾ä¾‹:lambdaå®ä¾‹ def maker(N): action = (lambda X: X**N) return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X#-- nonlocalå’Œglobalè¯­å¥çš„åŒºåˆ« # nonlocalåº”ç”¨äºä¸€ä¸ªåµŒå¥—çš„å‡½æ•°çš„ä½œç”¨åŸŸä¸­çš„ä¸€ä¸ªåç§° ä¾‹å¦‚: start = 100 def tester(start): def nested(label): nonlocal start # æŒ‡å®šstartä¸ºtesterå‡½æ•°å†…çš„localå˜é‡ è€Œä¸æ˜¯globalå˜é‡start print(label, start) start += 3 return nested # globalä¸ºå…¨å±€çš„å˜é‡ å³defä¹‹å¤–çš„å˜é‡ def tester(start): def nested(label): global start # æŒ‡å®šstartä¸ºglobalå˜é‡start print(label, start) start += 3 return nested #-- å‡½æ•°å‚æ•°ï¼Œä¸å¯å˜å‚æ•°é€šè¿‡â€œå€¼â€ä¼ é€’ï¼Œå¯å˜å‚æ•°é€šè¿‡â€œå¼•ç”¨â€ä¼ é€’ def f(a, b, c): print(a, b, c) f(1, 2, 3) # å‚æ•°ä½ç½®åŒ¹é… f(1, c = 3, b = 2) # å‚æ•°å…³é”®å­—åŒ¹é… def f(a, b=1, c=2): print(a, b, c) f(1) # é»˜è®¤å‚æ•°åŒ¹é… f(1, 2) # é»˜è®¤å‚æ•°åŒ¹é… f(a = 1, c = 3) # å…³é”®å­—å‚æ•°å’Œé»˜è®¤å‚æ•°çš„æ··åˆ # Keyword-Onlyå‚æ•°:å‡ºç°åœ¨*argsä¹‹å å¿…é¡»ç”¨å…³é”®å­—è¿›è¡ŒåŒ¹é… def keyOnly(a, *b, c): print() # cå°±ä¸ºkeyword-onlyåŒ¹é… å¿…é¡»ä½¿ç”¨å…³é”®å­—c = valueåŒ¹é… def keyOnly(a, *, b, c): ...... # b cä¸ºkeyword-onlyåŒ¹é… å¿…é¡»ä½¿ç”¨å…³é”®å­—åŒ¹é… def keyOnly(a, *, b = 1): ...... # bæœ‰é»˜è®¤å€¼ æˆ–è€…çœç•¥ æˆ–è€…ä½¿ç”¨å…³é”®å­—å‚æ•°b = value#-- å¯å˜å‚æ•°åŒ¹é…: * å’Œ ** def f(*args): print(args) # åœ¨å…ƒç»„ä¸­æ”¶é›†ä¸åŒ¹é…çš„ä½ç½®å‚æ•° f(1, 2, 3) # è¾“å‡º(1, 2, 3) def f(**args): print(args) # åœ¨å­—å…¸ä¸­æ”¶é›†ä¸åŒ¹é…çš„å…³é”®å­—å‚æ•° f(a = 1, b = 2) # è¾“å‡ºa:1, b:2 def f(a, *b, **c): print(a, b, c) # ä¸¤è€…æ··åˆä½¿ç”¨ f(1, 2, 3, x=4, y=5) # è¾“å‡º1, (2, 3), x:4, y:5 #-- å‡½æ•°è°ƒç”¨æ—¶çš„å‚æ•°è§£åŒ…: * å’Œ ** åˆ†åˆ«è§£åŒ…å…ƒç»„å’Œå­—å…¸ func(1, *(2, 3)) == func(1, 2, 3) func(1, **c:3, b:2) == func(1, b = 2, c = 3) func(1, *(2, 3), **c:3, b:2) == func(1, 2, 3, b = 2, c = 3) #-- å‡½æ•°å±æ€§:(è‡ªå·±å®šä¹‰çš„)å‡½æ•°å¯ä»¥æ·»åŠ å±æ€§ def func():..... func.count = 1 # è‡ªå®šä¹‰å‡½æ•°æ·»åŠ å±æ€§ print.count = 1 # Error å†…ç½®å‡½æ•°ä¸å¯ä»¥æ·»åŠ å±æ€§ #-- å‡½æ•°æ³¨è§£: ç¼–å†™åœ¨defå¤´éƒ¨è¡Œ ä¸»è¦ç”¨äºè¯´æ˜å‚æ•°èŒƒå›´ã€å‚æ•°ç±»å‹ã€è¿”å›å€¼ç±»å‹ç­‰ def func(a:spam, b:(1, 10), c:float) - int : print(a, b, c) func.__annotations__ # c:class float, b:(1, 10), a:spam, return:class int # ç¼–å†™æ³¨è§£çš„åŒæ—¶ è¿˜æ˜¯å¯ä»¥ä½¿ç”¨å‡½æ•°é»˜è®¤å€¼ å¹¶ä¸”æ³¨è§£çš„ä½ç½®ä½äº=å·çš„å‰è¾¹ def func(a:spam=a, b:(1, 10)=2, c:float=3) - int : print(a, b, c)#-- åŒ¿åå‡½æ•°:lambda f = lambda x, y, z : x + y + z # æ™®é€šåŒ¿åå‡½æ•°ï¼Œä½¿ç”¨æ–¹æ³•f(1, 2, 3) f = lambda x = 1, y = 1: x + y # å¸¦é»˜è®¤å‚æ•°çš„lambdaå‡½æ•° def action(x): # åµŒå¥—lambdaå‡½æ•° return (lambda y : x + y) f = lambda: a if xxx() else b # æ— å‚æ•°çš„lambdaå‡½æ•°ï¼Œä½¿ç”¨æ–¹æ³•f()#-- lambdaå‡½æ•°ä¸map filter reduceå‡½æ•°çš„ç»“åˆ list(map((lambda x: x + 1), [1, 2, 3])) # [2, 3, 4] list(filter((lambda x: x 0), range(-4, 5))) # [1, 2, 3, 4] functools.reduce((lambda x, y: x + y), [1, 2, 3]) # 6 functools.reduce((lambda x, y: x * y), [2, 3, 4]) # 24 #-- ç”Ÿæˆå™¨å‡½æ•°:yield VS return def gensquare(N): for i in range(N): yield i** 2 # çŠ¶æ€æŒ‚èµ· å¯ä»¥æ¢å¤åˆ°æ­¤æ—¶çš„çŠ¶æ€ for i in gensquare(5): # ä½¿ç”¨æ–¹æ³• print(i, end = ) # [0, 1, 4, 9, 16] x = gensquare(2) # xæ˜¯ä¸€ä¸ªç”Ÿæˆå¯¹è±¡ next(x) # ç­‰åŒäºx.__next__() è¿”å›0 next(x) # ç­‰åŒäºx.__next__() è¿”å›1 next(x) # ç­‰åŒäºx.__next__() æŠ›å‡ºå¼‚å¸¸StopIteration #-- ç”Ÿæˆå™¨è¡¨è¾¾å¼:å°æ‹¬å·è¿›è¡Œåˆ—è¡¨è§£æ G = (x ** 2 for x in range(3)) # ä½¿ç”¨å°æ‹¬å·å¯ä»¥åˆ›å»ºæ‰€éœ€ç»“æœçš„ç”Ÿæˆå™¨generator object next(G), next(G), next(G) # å’Œä¸Šè¿°ä¸­çš„ç”Ÿæˆå™¨å‡½æ•°çš„è¿”å›å€¼ä¸€è‡´ #ï¼ˆ1ï¼‰ç”Ÿæˆå™¨(ç”Ÿæˆå™¨å‡½æ•°/ç”Ÿæˆå™¨è¡¨è¾¾å¼)æ˜¯å•ä¸ªè¿­ä»£å¯¹è±¡ G = (x ** 2 for x in range(4)) I1 = iter(G) # è¿™é‡Œå®é™…ä¸Šiter(G) = G next(I1) # è¾“å‡º0 next(G) # è¾“å‡º1 next(I1) # è¾“å‡º4 #ï¼ˆ2ï¼‰ç”Ÿæˆå™¨ä¸ä¿ç•™è¿­ä»£åçš„ç»“æœ gen = (i for i in range(4)) 2 in gen # è¿”å›True 3 in gen # è¿”å›True 1 in gen # è¿”å›Falseï¼Œå…¶å®æ£€æµ‹2çš„æ—¶å€™ï¼Œ1å·²ç»å°±ä¸åœ¨ç”Ÿæˆå™¨ä¸­äº†ï¼Œå³1å·²ç»è¢«è¿­ä»£è¿‡äº†ï¼ŒåŒç†2ã€3ä¹Ÿä¸åœ¨äº†#-- æœ¬åœ°å˜é‡æ˜¯é™æ€æ£€æµ‹çš„ X = 22 # å…¨å±€å˜é‡Xçš„å£°æ˜å’Œå®šä¹‰ def test(): print(X) # å¦‚æœæ²¡æœ‰ä¸‹ä¸€è¯­å¥ åˆ™è¯¥å¥åˆæ³• æ‰“å°å…¨å±€å˜é‡X X = 88 # è¿™ä¸€è¯­å¥ä½¿å¾—ä¸Šä¸€è¯­å¥éæ³• å› ä¸ºå®ƒä½¿å¾—Xå˜æˆäº†æœ¬åœ°å˜é‡ ä¸Šä¸€å¥å˜æˆäº†æ‰“å°ä¸€ä¸ªæœªå®šä¹‰çš„æœ¬åœ°å˜é‡(å±€éƒ¨å˜é‡) if False: # å³ä½¿è¿™æ ·çš„è¯­å¥ ä¹Ÿä¼šæŠŠprintè¯­å¥è§†ä¸ºéæ³•è¯­å¥ å› ä¸º: X = 88 # Pythonä¼šæ— è§†ifè¯­å¥è€Œä»ç„¶å£°æ˜äº†å±€éƒ¨å˜é‡X def test(): # æ”¹è¿› global X # å£°æ˜å˜é‡Xä¸ºå…¨å±€å˜é‡ print(X) # æ‰“å°å…¨å±€å˜é‡X X = 88 # æ”¹å˜å…¨å±€å˜é‡X #-- å‡½æ•°çš„é»˜è®¤å€¼æ˜¯åœ¨å‡½æ•°å®šä¹‰çš„æ—¶å€™å®ä¾‹åŒ–çš„ è€Œä¸æ˜¯åœ¨è°ƒç”¨çš„æ—¶å€™ ä¾‹å­: def foo(numbers=[]): # è¿™é‡Œçš„[]æ˜¯å¯å˜çš„ numbers.append(9) print(numbers) foo() # first time, like before, [9] foo() # second time, not like before, [9, 9] foo() # third time, not like before too, [9, 9, 9] # æ”¹è¿›: def foo(numbers=None): if numbers is None: numbers = [] numbers.append(9) print(numbers) # å¦å¤–ä¸€ä¸ªä¾‹å­ å‚æ•°çš„é»˜è®¤å€¼ä¸ºä¸å¯å˜çš„: def foo(count=0): # è¿™é‡Œçš„0æ˜¯æ•°å­—, æ˜¯ä¸å¯å˜çš„ count += 1 print(count) foo() # è¾“å‡º1 foo() # è¿˜æ˜¯è¾“å‡º1 foo(3) # è¾“å‡º4 foo() # è¿˜æ˜¯è¾“å‡º1 å‡½æ•°ä¾‹å­ æ•°å­¦è¿ç®—ç±» abs(x) # æ±‚ç»å¯¹å€¼ï¼Œå‚æ•°å¯ä»¥æ˜¯æ•´å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤æ•°ï¼Œè‹¥å‚æ•°æ˜¯å¤æ•°ï¼Œåˆ™è¿”å›å¤æ•°çš„æ¨¡ complex([real[, imag]]) # åˆ›å»ºä¸€ä¸ªå¤æ•° divmod(a, b) # åˆ†åˆ«å–å•†å’Œä½™æ•°ï¼Œæ³¨æ„ï¼šæ•´å‹ã€æµ®ç‚¹å‹éƒ½å¯ä»¥ float([x]) # å°†ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–æ•°è½¬æ¢ä¸ºæµ®ç‚¹æ•°ã€‚å¦‚æœæ— å‚æ•°å°†è¿”å›0.0 int([x[, base]]) # å°†ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–æµ®ç‚¹æ•°è½¬æ¢ä¸ºintç±»å‹ï¼Œbaseè¡¨ç¤ºè¿›åˆ¶ long([x[, base]]) # å°†ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–æµ®ç‚¹æ•°è½¬æ¢ä¸ºlongç±»å‹ pow(x, y) # è¿”å›xçš„yæ¬¡å¹‚ range([start], stop[, step]) # äº§ç”Ÿä¸€ä¸ªåºåˆ—ï¼Œé»˜è®¤ä»0å¼€å§‹ round(x[, n]) # å››èˆäº”å…¥ sum(iterable[, start]) # å¯¹é›†åˆæ±‚å’Œ oct(x) # å°†ä¸€ä¸ªæ•°å­—è½¬åŒ–ä¸º8è¿›åˆ¶å­—ç¬¦ä¸² hex(x) # å°†ä¸€ä¸ªæ•°å­—è½¬æ¢ä¸º16è¿›åˆ¶å­—ç¬¦ä¸² chr(i) # è¿”å›ç»™å®šintç±»å‹å¯¹åº”çš„ASCIIå­—ç¬¦ unichr(i) # è¿”å›ç»™å®šintç±»å‹çš„unicode ord(c) # è¿”å›ASCIIå­—ç¬¦å¯¹åº”çš„æ•´æ•° bin(x) # å°†æ•´æ•°xè½¬æ¢ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸² bool([x]) # å°†xè½¬æ¢ä¸ºBooleanç±»å‹ é›†åˆç±»æ“ä½œ basestring() # strå’Œunicodeçš„è¶…ç±»ï¼Œä¸èƒ½ç›´æ¥è°ƒç”¨ï¼Œå¯ä»¥ç”¨ä½œisinstanceåˆ¤æ–­ format(value [, format_spec]) # æ ¼å¼åŒ–è¾“å‡ºå­—ç¬¦ä¸²ï¼Œæ ¼å¼åŒ–çš„å‚æ•°é¡ºåºä»0å¼€å§‹ï¼Œå¦‚â€œI am 0,I like 1â€ enumerate(sequence[, start=0]) # è¿”å›ä¸€ä¸ªå¯æšä¸¾çš„å¯¹è±¡ï¼Œæ³¨æ„å®ƒæœ‰ç¬¬äºŒä¸ªå‚æ•° iter(obj[, sentinel]) # ç”Ÿæˆä¸€ä¸ªå¯¹è±¡çš„è¿­ä»£å™¨ï¼Œç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºåˆ†éš”ç¬¦ max(iterable[, args...][key]) # è¿”å›é›†åˆä¸­çš„æœ€å¤§å€¼ min(iterable[, args...][key]) # è¿”å›é›†åˆä¸­çš„æœ€å°å€¼ dict([arg]) # åˆ›å»ºæ•°æ®å­—å…¸ list([iterable]) # å°†ä¸€ä¸ªé›†åˆç±»è½¬æ¢ä¸ºå¦å¤–ä¸€ä¸ªé›†åˆç±» set() # setå¯¹è±¡å®ä¾‹åŒ– frozenset([iterable]) # äº§ç”Ÿä¸€ä¸ªä¸å¯å˜çš„set tuple([iterable]) # ç”Ÿæˆä¸€ä¸ªtupleç±»å‹ str([object]) # è½¬æ¢ä¸ºstringç±»å‹ sorted(iterable[, cmp[, key[, reverse]]]) # é›†åˆæ’åº L = [(b,2),(a,1),(c,3),(d,4)] sorted(L, key=lambda x: x[1], reverse=True) # ä½¿ç”¨Keyå‚æ•°å’Œreverseå‚æ•° sorted(L, key=lambda x: (x[0], x[1])) # ä½¿ç”¨keyå‚æ•°è¿›è¡Œå¤šæ¡ä»¶æ’åºï¼Œå³å¦‚æœx[0]ç›¸åŒï¼Œåˆ™æ¯”è¾ƒx[1] é€»è¾‘åˆ¤æ–­ all(iterable) # é›†åˆä¸­çš„å…ƒç´ éƒ½ä¸ºçœŸçš„æ—¶å€™ä¸ºçœŸï¼Œç‰¹åˆ«çš„ï¼Œè‹¥ä¸ºç©ºä¸²è¿”å›ä¸ºTrue any(iterable) # é›†åˆä¸­çš„å…ƒç´ æœ‰ä¸€ä¸ªä¸ºçœŸçš„æ—¶å€™ä¸ºçœŸï¼Œç‰¹åˆ«çš„ï¼Œè‹¥ä¸ºç©ºä¸²è¿”å›ä¸ºFalse cmp(x, y) # å¦‚æœx y ,è¿”å›è´Ÿæ•°ï¼›x == y, è¿”å›0ï¼›x y,è¿”å›æ­£æ•° IOæ“ä½œ file(filename [, mode [, bufsize]]) # fileç±»å‹çš„æ„é€ å‡½æ•°ã€‚ input([prompt]) # è·å–ç”¨æˆ·è¾“å…¥ï¼Œæ¨èä½¿ç”¨raw_inputï¼Œå› ä¸ºè¯¥å‡½æ•°å°†ä¸ä¼šæ•è·ç”¨æˆ·çš„é”™è¯¯è¾“å…¥ï¼Œæ„æ€æ˜¯è‡ªè¡Œåˆ¤æ–­ç±»å‹ # åœ¨ Built-in Functions é‡Œæœ‰ä¸€å¥è¯æ˜¯è¿™æ ·å†™çš„ï¼šConsider using the raw_input() function for general input from users. raw_input([prompt]) # è®¾ç½®è¾“å…¥ï¼Œè¾“å…¥éƒ½æ˜¯ä½œä¸ºå­—ç¬¦ä¸²å¤„ç† open(name[, mode[, buffering]]) # æ‰“å¼€æ–‡ä»¶ï¼Œä¸fileæœ‰ä»€ä¹ˆä¸åŒï¼Ÿæ¨èä½¿ç”¨open å…¶ä»– callable(object) # æ£€æŸ¥å¯¹è±¡objectæ˜¯å¦å¯è°ƒç”¨ classmethod(func) # ç”¨æ¥è¯´æ˜è¿™ä¸ªfuncæ˜¯ä¸ªç±»æ–¹æ³• staticmethod(func) # ç”¨æ¥è¯´æ˜è¿™ä¸ªfuncä¸ºé™æ€æ–¹æ³• dir([object]) # ä¸å¸¦å‚æ•°æ—¶ï¼Œè¿”å›å½“å‰èŒƒå›´å†…çš„å˜é‡ã€æ–¹æ³•å’Œå®šä¹‰çš„ç±»å‹åˆ—è¡¨ï¼›å¸¦å‚æ•°æ—¶ï¼Œè¿”å›å‚æ•°çš„å±æ€§ã€æ–¹æ³•åˆ—è¡¨ã€‚ help(obj) # è¿”å›objçš„å¸®åŠ©ä¿¡æ¯ eval(expression) # è®¡ç®—è¡¨è¾¾å¼expressionçš„å€¼ï¼Œå¹¶è¿”å› exec(str) # å°†strä½œä¸ºPythonè¯­å¥æ‰§è¡Œ execfile(filename) # ç”¨æ³•ç±»ä¼¼exec()ï¼Œä¸åŒçš„æ˜¯execfileçš„å‚æ•°filenameä¸ºæ–‡ä»¶åï¼Œè€Œexecçš„å‚æ•°ä¸ºå­—ç¬¦ä¸²ã€‚ filter(function, iterable) # æ„é€ ä¸€ä¸ªåºåˆ—ï¼Œç­‰ä»·äº[item for item in iterable if function(item)]ï¼Œfunctionè¿”å›å€¼ä¸ºTrueæˆ–Falseçš„å‡½æ•° list(filter(bool, range(-3, 4)))# è¿”å›[-3, -2, -1, 1, 2, 3], æ²¡æœ‰0 hasattr(object, name) # åˆ¤æ–­å¯¹è±¡objectæ˜¯å¦åŒ…å«åä¸ºnameçš„ç‰¹æ€§ getattr(object, name [, defalut]) # è·å–ä¸€ä¸ªç±»çš„å±æ€§ setattr(object, name, value) # è®¾ç½®å±æ€§å€¼ delattr(object, name) # åˆ é™¤objectå¯¹è±¡åä¸ºnameçš„å±æ€§ globals() # è¿”å›ä¸€ä¸ªæè¿°å½“å‰å…¨å±€ç¬¦å·è¡¨çš„å­—å…¸ hash(object) # å¦‚æœå¯¹è±¡objectä¸ºå“ˆå¸Œè¡¨ç±»å‹ï¼Œè¿”å›å¯¹è±¡objectçš„å“ˆå¸Œå€¼ id(object) # è¿”å›å¯¹è±¡çš„å”¯ä¸€æ ‡è¯†ï¼Œä¸€ä¸²æ•°å­— isinstance(object, classinfo) # åˆ¤æ–­objectæ˜¯å¦æ˜¯classçš„å®ä¾‹ isinstance(1, int) # åˆ¤æ–­æ˜¯ä¸æ˜¯intç±»å‹ isinstance(1, (int, float)) # isinstanceçš„ç¬¬äºŒä¸ªå‚æ•°æ¥å—ä¸€ä¸ªå…ƒç»„ç±»å‹ issubclass(class, classinfo) # åˆ¤æ–­classæ˜¯å¦ä¸ºclassinfoçš„å­ç±» locals() # è¿”å›å½“å‰çš„å˜é‡åˆ—è¡¨ map(function, iterable, ...) # éå†æ¯ä¸ªå…ƒç´ ï¼Œæ‰§è¡Œfunctionæ“ä½œ list(map(abs, range(-3, 4))) # è¿”å›[3, 2, 1, 0, 1, 2, 3] next(iterator[, default]) # ç±»ä¼¼äºiterator.next() property([fget[, fset[, fdel[, doc]]]]) # å±æ€§è®¿é—®çš„åŒ…è£…ç±»ï¼Œè®¾ç½®åå¯ä»¥é€šè¿‡c.x=valueç­‰æ¥è®¿é—®setterå’Œgetter reduce(function, iterable[, initializer]) # åˆå¹¶æ“ä½œï¼Œä»ç¬¬ä¸€ä¸ªå¼€å§‹æ˜¯å‰ä¸¤ä¸ªå‚æ•°ï¼Œç„¶åæ˜¯å‰ä¸¤ä¸ªçš„ç»“æœä¸ç¬¬ä¸‰ä¸ªåˆå¹¶è¿›è¡Œå¤„ç†ï¼Œä»¥æ­¤ç±»æ¨ def add(x,y):return x + y reduce(add, range(1, 11)) # è¿”å›55 (æ³¨:1+2+3+4+5+6+7+8+9+10 = 55) reduce(add, range(1, 11), 20) # è¿”å›75 reload(module) # é‡æ–°åŠ è½½æ¨¡å— repr(object) # å°†ä¸€ä¸ªå¯¹è±¡å˜å¹»ä¸ºå¯æ‰“å°çš„æ ¼å¼ slice(start, stop[, step]) # äº§ç”Ÿåˆ†ç‰‡å¯¹è±¡ type(object) # è¿”å›è¯¥objectçš„ç±»å‹ vars([object]) # è¿”å›å¯¹è±¡çš„å˜é‡åã€å˜é‡å€¼çš„å­—å…¸ a = Class(); # Classä¸ºä¸€ä¸ªç©ºç±» a.name = qi, a.age = 9 vars(a) # name:qi, age:9 zip([iterable, ...]) # è¿”å›å¯¹åº”æ•°ç»„ list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)] a = [1, 2, 3], b = [a, b, c] z = zip(a, b) # å‹ç¼©ï¼š[(1, a), (2, b), (3, c)] zip(*z) # è§£å‹ç¼©ï¼š[(1, 2, 3), (a, b, c)] unicode(string, encoding, errors) # å°†å­—ç¬¦ä¸²stringè½¬åŒ–ä¸ºunicodeå½¢å¼ï¼Œstringä¸ºencoded stringã€‚â€‹ æ¨¡å—Moudle#-- Pythonæ¨¡å—æœç´¢è·¯å¾„: (1)ç¨‹åºçš„ä¸»ç›®å½• (2)PYTHONPATHç›®å½• (3)æ ‡å‡†é“¾æ¥åº“ç›®å½• (4)ä»»ä½•.pthæ–‡ä»¶çš„å†…å®¹ #-- æŸ¥çœ‹å…¨éƒ¨çš„æ¨¡å—æœç´¢è·¯å¾„ import sys sys.path sys.argv # è·å¾—è„šæœ¬çš„å‚æ•° sys.builtin_module_names # æŸ¥æ‰¾å†…å»ºæ¨¡å— sys.platform # è¿”å›å½“å‰å¹³å° å‡ºç°å¦‚ï¼š win32 linux darwinç­‰ sys.modules # æŸ¥æ‰¾å·²å¯¼å…¥çš„æ¨¡å— sys.modules.keys() sys.stdout # stdout å’Œ stderr éƒ½æ˜¯ç±»æ–‡ä»¶å¯¹è±¡ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æ˜¯åªå†™çš„ã€‚å®ƒä»¬éƒ½æ²¡æœ‰ read æ–¹æ³•ï¼Œåªæœ‰ write æ–¹æ³• sys.stdout.write(hello) sys.stderr sys.stdin #-- æ¨¡å—çš„ä½¿ç”¨ä»£ç  import module1, module2 # å¯¼å…¥module1 ä½¿ç”¨module1.printer() from module1 import printer # å¯¼å…¥module1ä¸­çš„printerå˜é‡ ä½¿ç”¨printer() from module1 import * # å¯¼å…¥module1ä¸­çš„å…¨éƒ¨å˜é‡ ä½¿ç”¨ä¸å¿…æ·»åŠ module1å‰ç¼€#-- é‡è½½æ¨¡å—reload: è¿™æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•° è€Œä¸æ˜¯ä¸€æ¡è¯­å¥ from imp import reload reload(module) #-- æ¨¡å—çš„åŒ…å¯¼å…¥:ä½¿ç”¨ç‚¹å·(.)è€Œä¸æ˜¯è·¯å¾„(dir1\\dir2)è¿›è¡Œå¯¼å…¥ import dir1.dir2.mod # då¯¼å…¥åŒ…(ç›®å½•)dir1ä¸­çš„åŒ…dir2ä¸­çš„modæ¨¡å— æ­¤æ—¶dir1å¿…é¡»åœ¨Pythonå¯æœç´¢è·¯å¾„ä¸­ from dir1.dir2.mod import * # fromè¯­æ³•çš„åŒ…å¯¼å…¥#-- __init__.pyåŒ…æ–‡ä»¶:æ¯ä¸ªå¯¼å…¥çš„åŒ…ä¸­éƒ½åº”è¯¥åŒ…å«è¿™ä¹ˆä¸€ä¸ªæ–‡ä»¶ è¯¥æ–‡ä»¶å¯ä»¥ä¸ºç©º é¦–æ¬¡è¿›è¡ŒåŒ…å¯¼å…¥æ—¶ è¯¥æ–‡ä»¶ä¼šè‡ªåŠ¨æ‰§è¡Œ é«˜çº§åŠŸèƒ½:åœ¨è¯¥æ–‡ä»¶ä¸­ä½¿ç”¨__all__åˆ—è¡¨æ¥å®šä¹‰åŒ…(ç›®å½•)ä»¥from*çš„å½¢å¼å¯¼å…¥æ—¶ éœ€è¦å¯¼å…¥ä»€ä¹ˆ #-- åŒ…ç›¸å¯¹å¯¼å…¥:ä½¿ç”¨ç‚¹å·(.) åªèƒ½ä½¿ç”¨fromè¯­å¥ from . import spam # å¯¼å…¥å½“å‰ç›®å½•ä¸‹çš„spamæ¨¡å—ï¼ˆPython2: å½“å‰ç›®å½•ä¸‹çš„æ¨¡å—, ç›´æ¥å¯¼å…¥å³å¯ï¼‰ from .spam import name # å¯¼å…¥å½“å‰ç›®å½•ä¸‹çš„spamæ¨¡å—çš„nameå±æ€§ï¼ˆPython2: å½“å‰ç›®å½•ä¸‹çš„æ¨¡å—, ç›´æ¥å¯¼å…¥å³å¯ï¼Œä¸ç”¨åŠ .ï¼‰ from .. import spam # å¯¼å…¥å½“å‰ç›®å½•çš„çˆ¶ç›®å½•ä¸‹çš„spamæ¨¡å— #-- åŒ…ç›¸å¯¹å¯¼å…¥ä¸æ™®é€šå¯¼å…¥çš„åŒºåˆ« from string import * # è¿™é‡Œå¯¼å…¥çš„stringæ¨¡å—ä¸ºsys.pathè·¯å¾„ä¸Šçš„ è€Œä¸æ˜¯æœ¬ç›®å½•ä¸‹çš„stringæ¨¡å—(å¦‚æœå­˜åœ¨ä¹Ÿä¸æ˜¯) from .string import * # è¿™é‡Œå¯¼å…¥çš„stringæ¨¡å—ä¸ºæœ¬ç›®å½•ä¸‹çš„(ä¸å­˜åœ¨åˆ™å¯¼å…¥å¤±è´¥) è€Œä¸æ˜¯sys.pathè·¯å¾„ä¸Šçš„ #-- æ¨¡å—æ•°æ®éšè—:æœ€å°åŒ–from*çš„ç ´å _X # å˜é‡åå‰åŠ ä¸‹åˆ’çº¿å¯ä»¥é˜²æ­¢from*å¯¼å…¥æ—¶è¯¥å˜é‡åè¢«å¤åˆ¶å‡ºå» __all__ = [x, x1, x2] # ä½¿ç”¨__all__åˆ—è¡¨æŒ‡å®šfrom*æ—¶å¤åˆ¶å‡ºå»çš„å˜é‡å(å˜é‡ååœ¨åˆ—è¡¨ä¸­ä¸ºå­—ç¬¦ä¸²å½¢å¼)#-- å¯ä»¥ä½¿ç”¨__name__è¿›è¡Œæ¨¡å—çš„å•å…ƒæµ‹è¯•:å½“æ¨¡å—ä¸ºé¡¶å±‚æ‰§è¡Œæ–‡ä»¶æ—¶å€¼ä¸º__main__ å½“æ¨¡å—è¢«å¯¼å…¥æ—¶ä¸ºæ¨¡å—å if __name__ == __main__: doSomething # æ¨¡å—å±æ€§ä¸­è¿˜æœ‰å…¶ä»–å±æ€§ï¼Œä¾‹å¦‚ï¼š __doc__ # æ¨¡å—çš„è¯´æ˜æ–‡æ¡£ __file__ # æ¨¡å—æ–‡ä»¶çš„æ–‡ä»¶åï¼ŒåŒ…æ‹¬å…¨è·¯å¾„ __name__ # ä¸»æ–‡ä»¶æˆ–è€…è¢«å¯¼å…¥æ–‡ä»¶ __package__ # æ¨¡å—æ‰€åœ¨çš„åŒ… #-- importè¯­å¥fromè¯­å¥çš„asæ‰©å±• import modulename as name from modulename import attrname as name #-- å¾—åˆ°æ¨¡å—å±æ€§çš„å‡ ç§æ–¹æ³• å‡è®¾ä¸ºäº†å¾—åˆ°nameå±æ€§çš„å€¼ M.name M.__dict__[name] sys.modules[M].name getattr(M, name) ç±»ä¸é¢å‘å¯¹è±¡#-- æœ€æ™®é€šçš„ç±» class C1(C2, C3): spam = 42 # æ•°æ®å±æ€§ def __init__(self, name): # å‡½æ•°å±æ€§:æ„é€ å‡½æ•° self.name = name def __del__(self): # å‡½æ•°å±æ€§:ææ„å‡½æ•° print(goodbey , self.name) I1 = C1(bob) #-- Pythonçš„ç±»æ²¡æœ‰åŸºäºå‚æ•°çš„å‡½æ•°é‡è½½ class FirstClass(object): def test(self, string): print(string) def test(self): # æ­¤æ—¶ç±»ä¸­åªæœ‰ä¸€ä¸ªtestå‡½æ•° å³åè€…test(self) å®ƒè¦†ç›–æ‰å‰è€…å¸¦å‚æ•°çš„testå‡½æ•° print(hello world)#-- å­ç±»æ‰©å±•è¶…ç±»: å°½é‡è°ƒç”¨è¶…ç±»çš„æ–¹æ³• class Manager(Person): def giveRaise(self, percent, bonus = .10): self.pay = int(self.pay*(1 + percent + bonus)) # ä¸å¥½çš„æ–¹å¼ å¤åˆ¶ç²˜è´´è¶…ç±»ä»£ç  Person.giveRaise(self, percent + bonus) # å¥½çš„æ–¹å¼ å°½é‡è°ƒç”¨è¶…ç±»æ–¹æ³•#-- ç±»å†…çœå·¥å…· bob = Person(bob) bob.__class__ # class Person bob.__class__.__name__ # Person bob.__dict__ # pay:0, name:bob, job:Manager #-- è¿”å›1ä¸­ æ•°æ®å±æ€§spamæ˜¯å±äºç±» è€Œä¸æ˜¯å¯¹è±¡ I1 = C1(bob); I2 = C2(tom) # æ­¤æ—¶I1å’ŒI2çš„spaméƒ½ä¸º42 ä½†æ˜¯éƒ½æ˜¯è¿”å›çš„C1çš„spamå±æ€§ C1.spam = 24 # æ­¤æ—¶I1å’ŒI2çš„spaméƒ½ä¸º24 I1.spam = 3 # æ­¤æ—¶I1æ–°å¢è‡ªæœ‰å±æ€§spam å€¼ä¸º3 I2å’ŒC1çš„spamè¿˜éƒ½ä¸º24 #-- ç±»æ–¹æ³•è°ƒç”¨çš„ä¸¤ç§æ–¹å¼ instance.method(arg...) class.method(instance, arg...) #-- æŠ½è±¡è¶…ç±»çš„å®ç°æ–¹æ³• # (1)æŸä¸ªå‡½æ•°ä¸­è°ƒç”¨æœªå®šä¹‰çš„å‡½æ•° å­ç±»ä¸­å®šä¹‰è¯¥å‡½æ•° def delegate(self): self.action() # æœ¬ç±»ä¸­ä¸å®šä¹‰actionå‡½æ•° æ‰€ä»¥ä½¿ç”¨delegateå‡½æ•°æ—¶å°±ä¼šå‡ºé”™ # (2)å®šä¹‰actionå‡½æ•° ä½†æ˜¯è¿”å›å¼‚å¸¸ def action(self): raise NotImplementedError(action must be defined) # (3)ä¸Šè¿°çš„ä¸¤ç§æ–¹æ³•è¿˜éƒ½å¯ä»¥å®šä¹‰å®ä¾‹å¯¹è±¡ å®é™…ä¸Šå¯ä»¥åˆ©ç”¨@è£…é¥°å™¨è¯­æ³•ç”Ÿæˆä¸èƒ½å®šä¹‰çš„æŠ½è±¡è¶…ç±» from abc import ABCMeta, abstractmethod class Super(metaclass = ABCMeta): @abstractmethod def action(self): pass x = Super() # è¿”å› TypeError: Cant instantiate abstract class Super with abstract methods action #-- # OOPå’Œç»§æ‰¿: is-açš„å…³ç³» class A(B): pass a = A() isinstance(a, B) # è¿”å›True, Aæ˜¯Bçš„å­ç±» aä¹Ÿæ˜¯Bçš„ä¸€ç§ # OOPå’Œç»„åˆ: has-açš„å…³ç³» pass # OOPå’Œå§”æ‰˜: åŒ…è£…å¯¹è±¡ åœ¨Pythonä¸­å§”æ‰˜é€šå¸¸æ˜¯ä»¥__getattr__é’©å­æ–¹æ³•å®ç°çš„, è¿™ä¸ªæ–¹æ³•ä¼šæ‹¦æˆªå¯¹ä¸å­˜åœ¨å±æ€§çš„è¯»å– # åŒ…è£…ç±»(æˆ–è€…ç§°ä¸ºä»£ç†ç±»)å¯ä»¥ä½¿ç”¨__getattr__æŠŠä»»æ„è¯»å–è½¬å‘ç»™è¢«åŒ…è£…çš„å¯¹è±¡ class wrapper(object): def __init__(self, object): self.wrapped = object def __getattr(self, attrname): print(Trace: , attrname) return getattr(self.wrapped, attrname) # æ³¨:è¿™é‡Œä½¿ç”¨getattr(X, N)å†…ç½®å‡½æ•°ä»¥å˜é‡åå­—ç¬¦ä¸²Nä»åŒ…è£…å¯¹è±¡Xä¸­å–å‡ºå±æ€§ ç±»ä¼¼äºX.__dict__[N] x = wrapper([1, 2, 3]) x.append(4) # è¿”å› Trace: append [1, 2, 3, 4] x = wrapper(a:1, b:2) list(x.keys()) # è¿”å› Trace: keys [a, b]#-- ç±»çš„ä¼ªç§æœ‰å±æ€§:ä½¿ç”¨__attr class C1(object): def __init__(self, name): self.__name = name # æ­¤æ—¶ç±»çš„__nameå±æ€§ä¸ºä¼ªç§æœ‰å±æ€§ åŸç† å®ƒä¼šè‡ªåŠ¨å˜æˆself._C1__name = name def __str__(self): return self.name = %s % self.__name I = C1(tom) print(I) # è¿”å› self.name = tom I.__name = jeey # è¿™é‡Œæ— æ³•è®¿é—® __nameä¸ºä¼ªç§æœ‰å±æ€§ I._C1__name = jeey # è¿™é‡Œå¯ä»¥ä¿®æ”¹æˆåŠŸ self.name = jeey #-- ç±»æ–¹æ³•æ˜¯å¯¹è±¡:æ— ç»‘å®šç±»æ–¹æ³•å¯¹è±¡ / ç»‘å®šå®ä¾‹æ–¹æ³•å¯¹è±¡ class Spam(object): def doit(self, message): print(message) def selfless(message) print(message) obj = Spam() x = obj.doit # ç±»çš„ç»‘å®šæ–¹æ³•å¯¹è±¡ å®ä¾‹ + å‡½æ•° x(hello world) x = Spam.doit # ç±»çš„æ— ç»‘å®šæ–¹æ³•å¯¹è±¡ ç±»å + å‡½æ•° x(obj, hello world) x = Spam.selfless # ç±»çš„æ— ç»‘å®šæ–¹æ³•å‡½æ•° åœ¨3.0ä¹‹å‰æ— æ•ˆ x(hello world)#-- è·å–å¯¹è±¡ä¿¡æ¯: å±æ€§å’Œæ–¹æ³• a = MyObject() dir(a) # ä½¿ç”¨dirå‡½æ•° hasattr(a, x) # æµ‹è¯•æ˜¯å¦æœ‰xå±æ€§æˆ–æ–¹æ³• å³a.xæ˜¯å¦å·²ç»å­˜åœ¨ setattr(a, y, 19) # è®¾ç½®å±æ€§æˆ–æ–¹æ³• ç­‰åŒäºa.y = 19 getattr(a, z, 0) # è·å–å±æ€§æˆ–æ–¹æ³• å¦‚æœå±æ€§ä¸å­˜åœ¨ åˆ™è¿”å›é»˜è®¤å€¼0 #è¿™é‡Œæœ‰ä¸ªå°æŠ€å·§ï¼Œsetattrå¯ä»¥è®¾ç½®ä¸€ä¸ªä¸èƒ½è®¿é—®åˆ°çš„å±æ€§ï¼Œå³åªèƒ½ç”¨getattrè·å– setattr(a, cant touch, 100) # è¿™é‡Œçš„å±æ€§åå¸¦æœ‰ç©ºæ ¼ï¼Œä¸èƒ½ç›´æ¥è®¿é—® getattr(a, cant touch, 0) # ä½†æ˜¯å¯ä»¥ç”¨getattrè·å–#-- ä¸ºç±»åŠ¨æ€ç»‘å®šå±æ€§æˆ–æ–¹æ³•: MethodTypeæ–¹æ³• # ä¸€èˆ¬åˆ›å»ºäº†ä¸€ä¸ªclassçš„å®ä¾‹å, å¯ä»¥ç»™è¯¥å®ä¾‹ç»‘å®šä»»ä½•å±æ€§å’Œæ–¹æ³•, è¿™å°±æ˜¯åŠ¨æ€è¯­è¨€çš„çµæ´»æ€§ class Student(object): pass s = Student() s.name = Michael # åŠ¨æ€ç»™å®ä¾‹ç»‘å®šä¸€ä¸ªå±æ€§ def set_age(self, age): # å®šä¹‰ä¸€ä¸ªå‡½æ•°ä½œä¸ºå®ä¾‹æ–¹æ³• self.age = age from types import MethodType s.set_age = MethodType(set_age, s) # ç»™å®ä¾‹ç»‘å®šä¸€ä¸ªæ–¹æ³• ç±»çš„å…¶ä»–å®ä¾‹ä¸å—æ­¤å½±å“ s.set_age(25) # è°ƒç”¨å®ä¾‹æ–¹æ³• Student.set_age = MethodType(set_age, Student) # ä¸ºç±»ç»‘å®šä¸€ä¸ªæ–¹æ³• ç±»çš„æ‰€æœ‰å®ä¾‹éƒ½æ‹¥æœ‰è¯¥æ–¹æ³•ç±»çš„é«˜çº§è¯é¢˜ #-- å¤šé‡ç»§æ‰¿: æ··åˆç±», æœç´¢æ–¹å¼ä»ä¸‹åˆ°ä¸Š ä»å·¦åˆ°å³ å¹¿åº¦ä¼˜å…ˆ class A(B, C): pass#-- ç±»çš„ç»§æ‰¿å’Œå­ç±»çš„åˆå§‹åŒ– # 1.å­ç±»å®šä¹‰äº†__init__æ–¹æ³•æ—¶ï¼Œè‹¥æœªæ˜¾ç¤ºè°ƒç”¨åŸºç±»__init__æ–¹æ³•ï¼Œpythonä¸ä¼šå¸®ä½ è°ƒç”¨ã€‚ # 2.å­ç±»æœªå®šä¹‰__init__æ–¹æ³•æ—¶ï¼Œpythonä¼šè‡ªåŠ¨å¸®ä½ è°ƒç”¨é¦–ä¸ªåŸºç±»çš„__init__æ–¹æ³•ï¼Œæ³¨æ„æ˜¯é¦–ä¸ªã€‚ # 3.å­ç±»æ˜¾ç¤ºè°ƒç”¨åŸºç±»çš„åˆå§‹åŒ–å‡½æ•°ï¼š class FooParent(object): def __init__(self, a): self.parent = I\\m the Parent. print(Parent:a= + str(a)) def bar(self, message): print(message + from Parent) class FooChild(FooParent): def __init__(self, a): FooParent.__init__(self, a) print(Child:a= + str(a)) def bar(self, message): FooParent.bar(self, message) print(message + from Child) fooChild = FooChild(10) fooChild.bar(HelloWorld) #-- #å®ä¾‹æ–¹æ³• / é™æ€æ–¹æ³• / ç±»æ–¹æ³• class Methods(object): def imeth(self, x): print(self, x) # å®ä¾‹æ–¹æ³•ï¼šä¼ å…¥çš„æ˜¯å®ä¾‹å’Œæ•°æ®ï¼Œæ“ä½œçš„æ˜¯å®ä¾‹çš„å±æ€§ def smeth(x): print(x) # é™æ€æ–¹æ³•ï¼šåªä¼ å…¥æ•°æ® ä¸ä¼ å…¥å®ä¾‹ï¼Œæ“ä½œçš„æ˜¯ç±»çš„å±æ€§è€Œä¸æ˜¯å®ä¾‹çš„å±æ€§ def cmeth(cls, x): print(cls, x) # ç±»æ–¹æ³•ï¼šä¼ å…¥çš„æ˜¯ç±»å¯¹è±¡å’Œæ•°æ® smeth = staticmethod(smeth) # è°ƒç”¨å†…ç½®å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨@staticmethod cmeth = classmethod(cmeth) # è°ƒç”¨å†…ç½®å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨@classmethod obj = Methods() obj.imeth(1) # å®ä¾‹æ–¹æ³•è°ƒç”¨ __main__.Methods object... 1 Methods.imeth(obj, 2) # __main__.Methods object... 2 Methods.smeth(3) # é™æ€æ–¹æ³•è°ƒç”¨ 3 obj.smeth(4) # è¿™é‡Œå¯ä»¥ä½¿ç”¨å®ä¾‹è¿›è¡Œè°ƒç”¨ Methods.cmeth(5) # ç±»æ–¹æ³•è°ƒç”¨ class __main__.Methods 5 obj.cmeth(6) # class __main__.Methods 6 #-- å‡½æ•°è£…é¥°å™¨:æ˜¯å®ƒåè¾¹çš„å‡½æ•°çš„è¿è¡Œæ—¶çš„å£°æ˜ ç”±@ç¬¦å·ä»¥åŠåè¾¹ç´§è·Ÿçš„å…ƒå‡½æ•°(metafunction)ç»„æˆ @staticmethod def smeth(x): print(x) # ç­‰åŒäº: def smeth(x): print(x) smeth = staticmethod(smeth) # åŒç† @classmethod def cmeth(cls, x): print(x) # ç­‰åŒäº def cmeth(cls, x): print(x) cmeth = classmethod(cmeth) #-- ç±»ä¿®é¥°å™¨:æ˜¯å®ƒåè¾¹çš„ç±»çš„è¿è¡Œæ—¶çš„å£°æ˜ ç”±@ç¬¦å·ä»¥åŠåè¾¹ç´§è·Ÿçš„å…ƒå‡½æ•°(metafunction)ç»„æˆ def decorator(aClass):..... @decorator class C(object):.... # ç­‰åŒäº: class C(object):.... C = decorator(C)#-- é™åˆ¶classå±æ€§: __slots__å±æ€§ class Student(object): __slots__ = (name, age) # é™åˆ¶StudentåŠå…¶å®ä¾‹åªèƒ½æ‹¥æœ‰nameå’Œageå±æ€§ # __slots__å±æ€§åªå¯¹å½“å‰ç±»èµ·ä½œç”¨, å¯¹å…¶å­ç±»ä¸èµ·ä½œç”¨ # __slots__å±æ€§èƒ½å¤ŸèŠ‚çœå†…å­˜ # __slots__å±æ€§å¯ä»¥ä¸ºåˆ—è¡¨listï¼Œæˆ–è€…å…ƒç»„tuple #-- ç±»å±æ€§é«˜çº§è¯é¢˜: @property # å‡è®¾å®šä¹‰äº†ä¸€ä¸ªç±»:Cï¼Œè¯¥ç±»å¿…é¡»ç»§æ‰¿è‡ªobjectç±»ï¼Œæœ‰ä¸€ç§æœ‰å˜é‡_x class C(object): def __init__(self): self.__x = None # ç¬¬ä¸€ç§ä½¿ç”¨å±æ€§çš„æ–¹æ³• def getx(self): return self.__x def setx(self, value): self.__x = value def delx(self): del self.__x x = property(getx, setx, delx, ) # propertyå‡½æ•°åŸå‹ä¸ºproperty(fget=None,fset=None,fdel=None,doc=None) # ä½¿ç”¨ c = C() c.x = 100 # è‡ªåŠ¨è°ƒç”¨setxæ–¹æ³• y = c.x # è‡ªåŠ¨è°ƒç”¨getxæ–¹æ³• del c.x # è‡ªåŠ¨è°ƒç”¨delxæ–¹æ³• # ç¬¬äºŒç§æ–¹æ³•ä½¿ç”¨å±æ€§çš„æ–¹æ³• @property def x(self): return self.__x @x.setter def x(self, value): self.__x = value @x.deleter def x(self): del self.__x # ä½¿ç”¨ c = C() c.x = 100 # è‡ªåŠ¨è°ƒç”¨setteræ–¹æ³• y = c.x # è‡ªåŠ¨è°ƒç”¨xæ–¹æ³• del c.x # è‡ªåŠ¨è°ƒç”¨deleteræ–¹æ³• #-- å®šåˆ¶ç±»: é‡å†™ç±»çš„æ–¹æ³• # (1)__str__æ–¹æ³•ã€__repr__æ–¹æ³•: å®šåˆ¶ç±»çš„è¾“å‡ºå­—ç¬¦ä¸² # (2)__iter__æ–¹æ³•ã€nextæ–¹æ³•: å®šåˆ¶ç±»çš„å¯è¿­ä»£æ€§ class Fib(object): def __init__(self): self.a, self.b = 0, 1 # åˆå§‹åŒ–ä¸¤ä¸ªè®¡æ•°å™¨aï¼Œb def __iter__(self): return self # å®ä¾‹æœ¬èº«å°±æ˜¯è¿­ä»£å¯¹è±¡ï¼Œæ•…è¿”å›è‡ªå·± def next(self): self.a, self.b = self.b, self.a + self.b if self.a 100000: # é€€å‡ºå¾ªç¯çš„æ¡ä»¶ raise StopIteration() return self.a # è¿”å›ä¸‹ä¸€ä¸ªå€¼ for n in Fib(): print(n) # ä½¿ç”¨ # (3)__getitem__æ–¹æ³•ã€__setitem__æ–¹æ³•: å®šåˆ¶ç±»çš„ä¸‹æ ‡æ“ä½œ[] æˆ–è€…åˆ‡ç‰‡æ“ä½œslice class Indexer(object): def __init__(self): self.data = def __getitem__(self, n): # å®šä¹‰getitemæ–¹æ³• print(getitem:, n) return self.data[n] def __setitem__(self, key, value): # å®šä¹‰setitemæ–¹æ³• print(setitem:key = 0, value = 1.format(key, value)) self.data[key] = value test = Indexer() test[0] = 1; test[3] = 3 # è°ƒç”¨setitemæ–¹æ³• print(test[0]) # è°ƒç”¨getitemæ–¹æ³• # (4)__getattr__æ–¹æ³•: å®šåˆ¶ç±»çš„å±æ€§æ“ä½œ class Student(object): def __getattr__(self, attr): # å®šä¹‰å½“è·å–ç±»çš„å±æ€§æ—¶çš„è¿”å›å€¼ if attr==age: return 25 # å½“è·å–ageå±æ€§æ—¶è¿”å›25 raise AttributeError(object has no attribute: %s % attr) # æ³¨æ„: åªæœ‰å½“å±æ€§ä¸å­˜åœ¨æ—¶ æ‰ä¼šè°ƒç”¨è¯¥æ–¹æ³• ä¸”è¯¥æ–¹æ³•é»˜è®¤è¿”å›None éœ€è¦åœ¨å‡½æ•°æœ€åå¼•å‘å¼‚å¸¸ s = Student() s.age # sä¸­ageå±æ€§ä¸å­˜åœ¨ æ•…è°ƒç”¨__getattr__æ–¹æ³• è¿”å›25 # (5)__call__æ–¹æ³•: å®šåˆ¶ç±»çš„å¯è°ƒç”¨æ€§ class Student(object): def __call__(self): # ä¹Ÿå¯ä»¥å¸¦å‚æ•° print(Calling......) s = Student() s() # så˜æˆäº†å¯è°ƒç”¨çš„ ä¹Ÿå¯ä»¥å¸¦å‚æ•° callable(s) # æµ‹è¯•sçš„å¯è°ƒç”¨æ€§ è¿”å›True # (6)__len__æ–¹æ³•ï¼šæ±‚ç±»çš„é•¿åº¦ def __len__(self): return len(self.data) #-- åŠ¨æ€åˆ›å»ºç±»type() # ä¸€èˆ¬åˆ›å»ºç±» éœ€è¦åœ¨ä»£ç ä¸­æå‰å®šä¹‰ class Hello(object): def hello(self, name=world): print(Hello, %s. % name) h = Hello() h.hello() # Hello, world type(Hello) # Helloæ˜¯ä¸€ä¸ªtypeç±»å‹ è¿”å›class type type(h) # hæ˜¯ä¸€ä¸ªHelloç±»å‹ è¿”å›class Hello # åŠ¨æ€ç±»å‹è¯­è¨€ä¸­ ç±»å¯ä»¥åŠ¨æ€åˆ›å»º typeå‡½æ•°å¯ç”¨äºåˆ›å»ºæ–°ç±»å‹ def fn(self, name=world): # å…ˆå®šä¹‰å‡½æ•° print(Hello, %s. % name) Hello = type(Hello, (object,), dict(hello=fn)) # åˆ›å»ºHelloç±» typeåŸå‹: type(name, bases, dict) h = Hello() # æ­¤æ—¶çš„hå’Œä¸Šè¾¹çš„hä¸€è‡´å¼‚å¸¸ç›¸å…³ #-- #æ•è·å¼‚å¸¸: try: except: # æ•è·æ‰€æœ‰çš„å¼‚å¸¸ ç­‰åŒäºexcept Exception: except name: # æ•è·æŒ‡å®šçš„å¼‚å¸¸ except name, value: # æ•è·æŒ‡å®šçš„å¼‚å¸¸å’Œé¢å¤–çš„æ•°æ®(å®ä¾‹) except (name1, name2): except (name1, name2), value: except name4 as X: else: # å¦‚æœæ²¡æœ‰å‘ç”Ÿå¼‚å¸¸ finally: # æ€»ä¼šæ‰§è¡Œçš„éƒ¨åˆ† # å¼•å‘å¼‚å¸¸: raiseå­å¥(raise IndexError) raise instance # raise instance of a class, raise IndexError() raise class # make and raise instance of a class, raise IndexError raise # reraise the most recent exception#-- Python3.xä¸­çš„å¼‚å¸¸é“¾: raise exception from otherException except Exception as X: raise IndexError(Bad) from X #-- assertå­å¥: assert test, data assert x 0, x must be negative #-- with/asç¯å¢ƒç®¡ç†å™¨:ä½œä¸ºå¸¸è§çš„try/finallyç”¨æ³•æ¨¡å¼çš„æ›¿ä»£æ–¹æ¡ˆ with expression [as variable], expression [as variable]: # ä¾‹å­: with open(test.txt) as myfile: for line in myfile: print(line) # ç­‰åŒäº: myfile = open(test.txt) try: for line in myfile: print(line) finally: myfile.close()#-- ç”¨æˆ·è‡ªå®šä¹‰å¼‚å¸¸: class Bad(Exception):..... Exceptionè¶…ç±» / exceptåŸºç±»å³å¯æ•è·åˆ°å…¶æ‰€æœ‰å­ç±» Exceptionè¶…ç±»æœ‰é»˜è®¤çš„æ‰“å°æ¶ˆæ¯å’ŒçŠ¶æ€ å½“ç„¶ä¹Ÿå¯ä»¥å®šåˆ¶æ‰“å°æ˜¾ç¤º: class MyBad(Exception): def __str__(self): return å®šåˆ¶çš„æ‰“å°æ¶ˆæ¯ try: MyBad() except MyBad as x: print(x) #-- ç”¨æˆ·å®šåˆ¶å¼‚å¸¸æ•°æ® class FormatError(Exception): def __init__(self, line ,file): self.line = line self.file = file try: raise FormatError(42, test.py) except FormatError as X: print(Error at , X.file, X.line) # ç”¨æˆ·å®šåˆ¶å¼‚å¸¸è¡Œä¸º(æ–¹æ³•):ä»¥è®°å½•æ—¥å¿—ä¸ºä¾‹ class FormatError(Exception): logfile = formaterror.txt def __init__(self, line ,file): self.line = line self.file = file def logger(self): open(self.logfile, a).write(Error at , self.file, self.line) try: raise FormatError(42, test.py) except FormatError as X: X.logger()#-- å…³äºsys.exc_info:å…è®¸ä¸€ä¸ªå¼‚å¸¸å¤„ç†å™¨è·å–å¯¹æœ€è¿‘å¼•å‘çš„å¼‚å¸¸çš„è®¿é—® try: ...... except: # æ­¤æ—¶sys.exc_info()è¿”å›ä¸€ä¸ªå…ƒç»„(type, value, traceback) # type:æ­£åœ¨å¤„ç†çš„å¼‚å¸¸çš„å¼‚å¸¸ç±»å‹ # value:å¼•å‘çš„å¼‚å¸¸çš„å®ä¾‹ # traceback:å †æ ˆä¿¡æ¯ #-- å¼‚å¸¸å±‚æ¬¡ BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- WarningUnicodeå’Œå­—èŠ‚å­—ç¬¦ä¸²#-- Pythonçš„å­—ç¬¦ä¸²ç±»å‹ Python2.x # 1.strè¡¨ç¤º8ä½æ–‡æœ¬å’ŒäºŒè¿›åˆ¶æ•°æ® # 2.unicodeè¡¨ç¤ºå®½å­—ç¬¦Unicodeæ–‡æœ¬ Python3.x # 1.strè¡¨ç¤ºUnicodeæ–‡æœ¬ï¼ˆ8ä½æˆ–è€…æ›´å®½ï¼‰ # 2.bytesè¡¨ç¤ºä¸å¯å˜çš„äºŒè¿›åˆ¶æ•°æ® # 3.bytearrayæ˜¯ä¸€ç§å¯å˜çš„bytesç±»å‹#-- å­—ç¬¦ç¼–ç æ–¹æ³• ASCII # ä¸€ä¸ªå­—èŠ‚ï¼ŒåªåŒ…å«è‹±æ–‡å­—ç¬¦ï¼Œ0åˆ°127ï¼Œå…±128ä¸ªå­—ç¬¦ï¼Œåˆ©ç”¨å‡½æ•°å¯ä»¥è¿›è¡Œå­—ç¬¦å’Œæ•°å­—çš„ç›¸äº’è½¬æ¢ ord(a) # å­—ç¬¦açš„ASCIIç ä¸º97ï¼Œæ‰€ä»¥è¿™é‡Œè¿”å›97 chr(97) # å’Œä¸Šè¾¹çš„è¿‡ç¨‹ç›¸åï¼Œè¿”å›å­—ç¬¦a Latin-1 # ä¸€ä¸ªå­—èŠ‚ï¼ŒåŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œ0åˆ°255ï¼Œå…±256ä¸ªå­—ç¬¦ï¼Œç›¸å½“äºå¯¹ASCIIç çš„æ‰©å±• chr(196) # è¿”å›ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ï¼šÃ„ Unicode # å®½å­—ç¬¦ï¼Œä¸€ä¸ªå­—ç¬¦åŒ…å«å¤šä¸ªå­—èŠ‚ï¼Œä¸€èˆ¬ç”¨äºäºšæ´²çš„å­—ç¬¦é›†ï¼Œæ¯”å¦‚ä¸­æ–‡æœ‰å¥½å‡ ä¸‡å­— UTF-8 # å¯å˜å­—èŠ‚æ•°ï¼Œå°äº128çš„å­—ç¬¦è¡¨ç¤ºä¸ºå•ä¸ªå­—èŠ‚ï¼Œ128åˆ°0X7FFä¹‹é—´çš„ä»£ç è½¬æ¢ä¸ºä¸¤ä¸ªå­—èŠ‚ï¼Œ0X7FFä»¥ä¸Šçš„ä»£ç è½¬æ¢ä¸º3æˆ–4ä¸ªå­—èŠ‚ # æ³¨æ„ï¼šå¯ä»¥çœ‹å‡ºæ¥ï¼ŒASCIIç æ˜¯Latin-1å’ŒUTF-8çš„ä¸€ä¸ªå­é›† # æ³¨æ„ï¼šutf-8æ˜¯unicodeçš„ä¸€ç§å®ç°æ–¹å¼ï¼Œunicodeã€gbkã€gb2312æ˜¯ç¼–ç å­—ç¬¦é›† #-- æŸ¥çœ‹Pythonä¸­çš„å­—ç¬¦ä¸²ç¼–ç åç§°ï¼ŒæŸ¥çœ‹ç³»ç»Ÿçš„ç¼–ç  import encodings help(encoding) import sys sys.platform # win64 sys.getdefaultencoding() # utf-8 sys.getdefaultencoding() # è¿”å›å½“å‰ç³»ç»Ÿå¹³å°çš„ç¼–ç ç±»å‹ sys.getsizeof(object) # è¿”å›objectå æœ‰çš„bytesçš„å¤§å° #-- æºæ–‡ä»¶å­—ç¬¦é›†ç¼–ç å£°æ˜: æ·»åŠ æ³¨é‡Šæ¥æŒ‡å®šæƒ³è¦çš„ç¼–ç å½¢å¼ ä»è€Œæ”¹å˜é»˜è®¤å€¼ æ³¨é‡Šå¿…é¡»å‡ºç°åœ¨è„šæœ¬çš„ç¬¬ä¸€è¡Œæˆ–è€…ç¬¬äºŒè¡Œ è¯´æ˜ï¼šå…¶å®è¿™é‡Œåªä¼šæ£€æŸ¥#å’Œcoding:utf-8ï¼Œå…¶ä½™çš„å­—ç¬¦éƒ½æ˜¯ä¸ºäº†ç¾è§‚åŠ ä¸Šçš„ # _*_ coding: utf-8 _*_ # coding = utf-8 #-- #ç¼–ç : å­—ç¬¦ä¸² -- åŸå§‹å­—èŠ‚ #è§£ç : åŸå§‹å­—èŠ‚ -- å­—ç¬¦ä¸²#-- Python3.xä¸­çš„å­—ç¬¦ä¸²åº”ç”¨ s = ... # æ„å»ºä¸€ä¸ªstrå¯¹è±¡ï¼Œä¸å¯å˜å¯¹è±¡ b = b... # æ„å»ºä¸€ä¸ªbyteså¯¹è±¡ï¼Œä¸å¯å˜å¯¹è±¡ s[0], b[0] # è¿”å›(., 113) s[1:], b[1:] # è¿”å›(.., b..) B = B xxxx yyyy # B = b xxxx yyyy # ç¼–ç ï¼Œå°†strå­—ç¬¦ä¸²è½¬åŒ–ä¸ºå…¶raw byteså½¢å¼ï¼š str.encode(encoding = utf-8, errors = strict) bytes(str, encoding) # ç¼–ç ä¾‹å­ï¼š S = egg S.encode() # begg bytes(S, encoding = ascii) # begg # è§£ç ï¼Œå°†raw byteså­—ç¬¦ä¸²è½¬åŒ–ä¸ºstrå½¢å¼ï¼š bytes.decode(encoding = utf-8, errors = strict) str(bytes_or_buffer[, encoding[, errors]]) # è§£ç ä¾‹å­ï¼š B = bspam B.decode() # spam str(B) # bspamï¼Œä¸å¸¦ç¼–ç çš„strè°ƒç”¨ï¼Œç»“æœä¸ºæ‰“å°è¯¥byteså¯¹è±¡ str(B, encoding = ascii)# spamï¼Œå¸¦ç¼–ç çš„strè°ƒç”¨ï¼Œç»“æœä¸ºè½¬åŒ–è¯¥byteså¯¹è±¡ #-- Python2.xçš„ç¼–ç é—®é¢˜ u = uæ±‰ print repr(u) # u\\xba\\xba s = u.encode(UTF-8) print repr(s) # \\xc2\\xba\\xc2\\xba u2 = s.decode(UTF-8) print repr(u2) # u\\xba\\xba # å¯¹unicodeè¿›è¡Œè§£ç æ˜¯é”™è¯¯çš„ s2 = u.decode(UTF-8) # UnicodeEncodeError: ascii codec cant encode characters in position 0-1: ordinal not in range(128) # åŒæ ·ï¼Œå¯¹strè¿›è¡Œç¼–ç ä¹Ÿæ˜¯é”™è¯¯çš„ u2 = s.encode(UTF-8) # UnicodeDecodeError: ascii codec cant decode byte 0xc2 in position 0: ordinal not in range(128)#-- byteså¯¹è±¡ B = babc B = bytes(abc, ascii) B = bytes([97, 98, 99]) B = abc.encode() # byteså¯¹è±¡çš„æ–¹æ³•è°ƒç”¨åŸºæœ¬å’Œstrç±»å‹ä¸€è‡´ ä½†:B[0]è¿”å›çš„æ˜¯ASCIIç å€¼97, è€Œä¸æ˜¯ba #-- #æ–‡æœ¬æ–‡ä»¶: æ ¹æ®Unicodeç¼–ç æ¥è§£é‡Šæ–‡ä»¶å†…å®¹ï¼Œè¦ä¹ˆæ˜¯å¹³å°çš„é»˜è®¤ç¼–ç ï¼Œè¦ä¹ˆæ˜¯æŒ‡å®šçš„ç¼–ç ç±»å‹ # äºŒè¿›åˆ¶æ–‡ä»¶ï¼šè¡¨ç¤ºå­—èŠ‚å€¼çš„æ•´æ•°çš„ä¸€ä¸ªåºåˆ— open(bin.txt, rb) #-- Unicodeæ–‡ä»¶ s = A\\xc4B\\xe8C # s = A?BÃ¨C len(s) = 5 #æ‰‹åŠ¨ç¼–ç  l = s.encode(latin-1) # l = bA\\xc4B\\xe8C len(l) = 5 u = s.encode(utf-8) # u = bA\\xc3\\x84B\\xc3\\xa8C len(u) = 7 #æ–‡ä»¶è¾“å‡ºç¼–ç  open(latindata, w, encoding = latin-1).write(s) l = open(latindata, rb).read() # l = bA\\xc4B\\xe8C len(l) = 5 open(uft8data, w, encoding = utf-8).write(s) u = open(uft8data, rb).read() # u = bA\\xc3\\x84B\\xc3\\xa8C len(u) = 7 #æ–‡ä»¶è¾“å…¥ç¼–ç  s = open(latindata, r, encoding = latin-1).read() # s = A?BÃ¨C len(s) = 5 s = open(latindata, rb).read().decode(latin-1) # s = A?BÃ¨C len(s) = 5 s = open(utf8data, r, encoding = utf-8).read() # s = A?BÃ¨C len(s) = 5 s = open(utf8data, rb).read().decode(utf-8) # s = A?BÃ¨C len(s) = 5 å…¶ä»–#-- Pythonå®ç°ä»»æ„æ·±åº¦çš„èµ‹å€¼ ä¾‹å¦‚a[0] = value1; a[1][2] = value2; a[3][4][5] = value3 class MyDict(dict): def __setitem__(self, key, value): # è¯¥å‡½æ•°ä¸åšä»»ä½•æ”¹åŠ¨ è¿™é‡Œåªæ˜¯ä¸ºäº†è¾“å‡º print(setitem:, key, value, self) super().__setitem__(key, value) def __getitem__(self, item): # ä¸»è¦æŠ€å·§åœ¨è¯¥å‡½æ•° print(getitem:, item, self) # è¾“å‡ºä¿¡æ¯ # åŸºæœ¬æ€è·¯: a[1][2]èµ‹å€¼æ—¶ éœ€è¦å…ˆå–å‡ºa[1] ç„¶åç»™a[1]çš„[2]èµ‹å€¼ if item not in self: # å¦‚æœa[1]ä¸å­˜åœ¨ åˆ™éœ€è¦æ–°å»ºä¸€ä¸ªdict å¹¶ä½¿å¾—a[1] = dict temp = MyDict() # æ–°å»ºçš„dict: temp super().__setitem__(item, temp) # èµ‹å€¼a[1] = temp return temp # è¿”å›temp ä½¿å¾—temp[2] = valueæœ‰æ•ˆ return super().__getitem__(item) # å¦‚æœa[1]å­˜åœ¨ åˆ™ç›´æ¥è¿”å›a[1] # ä¾‹å­: test = MyDict() test[0] = test print(test[0]) test[1][2] = test1 print(test[1][2]) test[1][3] = test2 print(test[1][3])#-- Pythonä¸­çš„å¤šç»´æ•°ç»„ lists = [0] * 3 # æ‰©å±•listï¼Œç»“æœä¸º[0, 0, 0] lists = [[]] * 3 # å¤šç»´æ•°ç»„ï¼Œç»“æœä¸º[[], [], []]ï¼Œä½†æœ‰é—®é¢˜ï¼Œå¾€ä¸‹çœ‹ lists[0].append(3) # æœŸæœ›çœ‹åˆ°çš„ç»“æœ[[3], [], []]ï¼Œå®é™…ç»“æœ[[3], [3], [3]]ï¼ŒåŸå› ï¼šlist*næ“ä½œï¼Œæ˜¯æµ…æ‹·è´ï¼Œå¦‚ä½•é¿å…ï¼Ÿå¾€ä¸‹çœ‹ lists = [[] for i in range(3)] # å¤šç»´æ•°ç»„ï¼Œç»“æœä¸º[[], [], []] lists[0].append(3) # ç»“æœä¸º[[3], [], []] lists[1].append(6) # ç»“æœä¸º[[3], [6], []] lists[2].append(9) # ç»“æœä¸º[[3], [6], [9]] lists = [[[] for j in range(4)] for i in range(3)] # 3è¡Œ4åˆ—ï¼Œä¸”æ¯ä¸€ä¸ªå…ƒç´ ä¸º[]","tags":["Python"],"categories":["Python"]},{"title":"Latexå­¦ä¹ ","path":"/2023/09/29/Latexå­¦ä¹ /","content":"å¸Œè…Šå­—æ¯ $$\\delta, \\lambda \\\\Delta, \\Lambda \\\\alpha, \\beta \\\\phi, \\varphi \\\\epsilon, \\varepsilon$$ ä¸Šä¸‹æ ‡ $$a^2, a_1 \\x^{y+z}, p_{ij}, p_{ij} \\x_i, x_{i} \\\\text{A B}, \\text{rm}$$ åˆ†å¼ä¸æ ¹å¼ $$\\frac{1}{2}, \\frac{1}{2} \\\\frac{1}{x+y} \\\\frac{\\frac{1}{x}+1}{y+1} \\\\sqrt{2}, \\sqrt{x+y}, \\sqrt[3]{x+y}$$ æ™®é€šè¿ç®—ç¬¦ $$+, - \\\\times, \\cdot, \\div \\\\pm, \\mp, , , \\geq, \\leq, \\gg, \\ll, eq, \\approx, \\equiv \\\\cap, \\cup, \\in, otin, \\subseteq, \\subsetneq, \\varnothing \\\\forall, \\exists, exists \\\\because, \\therefore \\\\mathbb{R}, \\mathbb{Q}, \\mathbb{N}, \\mathbb{Z}+ \\\\mathcal{F}, \\mathscr{F} \\\\cdots, \\vdots, \\ddots \\\\infty, \\partial, abla, \\propto, ^\\circ \\\\sin x, \\sec x, \\cosh x \\\\log_2 x, \\ln x, \\lg x \\\\lim\\limits{x \\to 0} \\frac{x}{\\sin x} \\\\max x$$ å¤§å‹è¿ç®—ç¬¦ $$\\sum,\\prod\\\\sum_i,\\sum_{i0}^N\\\\frac{\\sum\\limits_{i1}^n x_i}{\\prod\\limits_{i1}^n x_i}\\\\int,\\iint,\\iiint,\\oint\\int_{-\\infty}^0 f(x),\\text d x\\a,a\\a\\ a\\a\\quad a\\a\\qquad a\\$$ æ ‡æ³¨ç¬¦å· $$\\vec{x}, \\overrightarrow{AB} \\\\bar{x}, \\overline{AB}$$ ç®­å¤´ $$\\leftarrow,\\Rightarrow,\\Leftrightarrow,\\Longleftarrow$$ æ‹¬å·ä¸å®šç•Œç¬¦ $${}\\\\lceil,\\rceil,\\lfloor,\\rfloor.||\\\\left(0,\\frac 1 a\\right]\\\\left.\\frac {\\partial f}{\\partial y}\\right|_{x0}$$ å¤šè¡Œå…¬å¼ $$\\begin{align}ab+c+d\\e+f\\end{align}$$ å¤§æ‹¬å·$$f(x)\\begin{cases}\\sin x -\\pi\\le x \\le \\pi\\0, \\text{å…¶ä»–}\\end{cases}$$ çŸ©é˜µ $$\\begin{matrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{matrix}$$ $$\\begin{bmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{bmatrix}$$ $$\\begin{pmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{pmatrix}$$ $$\\begin{vmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{vmatrix}$$ $$\\bf A,\\bf B^{\\rm T}$$ å®æˆ˜æ¼”ç»ƒ $$f(x) \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\f(x) \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)$$ $$\\lim\\limits_{N \\to \\infty} P \\left{ \\left| \\frac{I\\left(\\alpha_i \\right)}{N} - H(s) \\right| \\varepsilon \\right} 1$$ $$x(n) \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X\\left(e^{j\\omega}\\right) e^{j\\omega n} , d\\omega$$ $$\\begin{align}\\vec{B} \\left(\\vec{r} \\right) \\frac{\\mu_0}{4\\pi} \\oint_C \\frac{I , {\\rm d}\\vec{l} \\times \\vec{R}}{R^3} \\ \\frac{\\mu_0}{4\\pi} \\int_V \\frac{\\vec{J}_V \\times \\vec{R}}{R^3} , {\\rm d}Vâ€™\\end{align}$$ mermaid å›¾å½¢ï¼š graph LR A(å¼€å§‹) --> input[/è¾“å…¥a,b/] --> if{a%b=0 ?} if --->|yes| f1[GCD = b] --> B(ç»“æŸ) if --->|no| f2[\"a, b = b, a % b \"]-->if","tags":["Latex","å­¦ä¹ "],"categories":["Latex"]},{"title":"labuladongç®—æ³•å°æŠ„","path":"/2023/05/17/labuladongç®—æ³•å°æŠ„/","content":"ç¬¬é›¶ç«  æ ¸å¿ƒæ¡†æ¶åŒæŒ‡é’ˆ-å•é“¾è¡¨ åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ LeetCode21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ é“¾è¡¨çš„åˆ†è§£ LeetCode86 åˆ†å‰²é“¾è¡¨ åˆå¹¶kä¸ªæœ‰åºé“¾è¡¨ LeetCode23 åˆå¹¶kä¸ªå‡åºé“¾è¡¨ å¯»æ‰¾å•é“¾è¡¨çš„å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ LeetCode19 åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ å¯»æ‰¾å•é“¾è¡¨çš„ä¸­ç‚¹ LeetCode976 é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦åŒ…å«ç¯å¹¶æ‰¾å‡ºç¯èµ·ç‚¹ åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤å¹¶æ‰¾å‡ºäº¤ç‚¹ LeetCode160 ç›¸äº¤é“¾è¡¨ åŒæŒ‡é’ˆ-æ•°ç»„å¿«æ…¢æŒ‡é’ˆ åŸåœ°ä¿®æ”¹æ•°ç»„ LeetCode26 åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ å¯¹æ•°ç»„æŸäº›å…ƒç´ è¿›è¡ŒåŸåœ°åˆ é™¤ LeetCode27 ç§»é™¤å…ƒç´  LeetCode283 ç§»åŠ¨é›¶ å·¦å³æŒ‡é’ˆ äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾æ¡†æ¶ ä¸¤æ•°ä¹‹å’Œ LeetCode167 ä¸¤æ•°ä¹‹å’Œ2 åè½¬æ•°ç»„ LeetCode344 åè½¬å­—ç¬¦ä¸² å›æ–‡ä¸²åˆ¤æ–­ LeetCode5 æœ€é•¿å›æ–‡å­ä¸² äºŒå‰æ ‘(çº²è¦ç¯‡)Tips:å¿«é€Ÿæ’åºå°±æ˜¯äºŒå‰æ ‘çš„å‰åºéå†,å½’å¹¶æ’åºæ˜¯äºŒå‰æ ‘çš„ååºéå† å¿«é€Ÿæ’åºæ¡†æ¶: def sort(nums, lo, hi) # å‰åºéå†ä½ç½® # é€šè¿‡äº¤æ¢å…ƒç´ æ„å»ºåˆ†ç•Œç‚¹ p p = partition(nums, lo, hi) sort(nums, lo, p-1) sort(nums, p+1, hi) å½’å¹¶æ’åºæ¡†æ¶: def sort(nums, lo, hi)\tint mid = (lo + hi) / 2\t# æ’åºnums[lo..mid]\tsort(nums, lo, mid)\t# æ’åºnums[mid+1..hi]\tsort(nums, mid+1, hi)\t# åˆå¹¶nums[lo..mid] å’Œ nums[mid+1..hi]\tmerge(nums, lo, mid, hi) äºŒå‰æ ‘éå†æ¡†æ¶:def traverse(root)\tif not root: return\t# å‰åºä½ç½®\ttraverse(root.left)\t# ä¸­åºä½ç½®\ttraverse(root.right)\t# ååºä½ç½® å‰åºä½ç½®çš„ä»£ç åªèƒ½ä»å‡½æ•°å‚æ•°ä¸­è·å–çˆ¶èŠ‚ç‚¹ä¼ é€’æ¥çš„æ•°æ®ï¼Œè€Œååºä½ç½®çš„ä»£ç ä¸ä»…å¯ä»¥è·å–å‚æ•°æ•°æ®ï¼Œè¿˜å¯ä»¥è·å–åˆ°å­æ ‘é€šè¿‡å‡½æ•°è¿”å›å€¼ä¼ é€’å›æ¥çš„æ•°æ® ä¸¤ç§è§£é¢˜æ€è·¯: éå†ä¸€éäºŒå‰æ ‘å¾—å‡ºç­”æ¡ˆ å›æº¯ç®—æ³•æ¡†æ¶ LeetCode104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ åˆ†è§£é—®é¢˜è®¡ç®—å‡ºç­”æ¡ˆ åŠ¨æ€è§„åˆ’æ ¸å¿ƒæ¡†æ¶ ååºä½ç½®çš„ç‰¹æ®Šä¹‹å¤„:â€‹ LeetCode543 äºŒå‰æ ‘çš„ç›´å¾„ å±‚åºéå†:def levelTraverse(root)\tif not root: return\tque = deque()\tque.append(root) # ä»ä¸Šåˆ°ä¸‹éå†äºŒå‰æ ‘çš„æ¯ä¸€å±‚\twhile que: # ä»å·¦åˆ°å³éå†æ¯ä¸€å±‚çš„æ¯ä¸ªç»“ç‚¹ for i in range(len(que)): cur = que.popleft() # å°†ä¸‹ä¸€å±‚ç»“ç‚¹æ”¾å…¥é˜Ÿåˆ— if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) â€‹ BFSç®—æ³•æ¡†æ¶ åŠ¨æ€è§„åˆ’(æ¡†æ¶)åŠ¨æ€è§„åˆ’æ¡†æ¶:# è‡ªé¡¶å‘ä¸‹é€’å½’çš„åŠ¨æ€è§„åˆ’def dp(çŠ¶æ€1, çŠ¶æ€2, ...):\tfor é€‰æ‹© in æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©: # æ­¤æ—¶çš„çŠ¶æ€å·²ç»å› ä¸ºåšäº†é€‰æ‹©è€Œæ”¹å˜ result = æ±‚æœ€å€¼(result, dp(çŠ¶æ€1, çŠ¶æ€2, ...))\treturn result# è‡ªåº•å‘ä¸Šè¿­ä»£çš„åŠ¨æ€è§„åˆ’# åˆå§‹åŒ– base casedp[0][0][...] = base case# è¿›è¡ŒçŠ¶æ€è½¬ç§»for çŠ¶æ€1 in çŠ¶æ€1çš„æ‰€æœ‰å–å€¼: for çŠ¶æ€2 in çŠ¶æ€2çš„æ‰€æœ‰å–å€¼: for ... dp[çŠ¶æ€1][çŠ¶æ€2][...] = æ±‚æœ€å€¼(é€‰æ‹©1, é€‰æ‹©2...) è§£é¢˜æ€è·¯:æš´åŠ›ç©·ä¸¾,å¸¦å¤‡å¿˜å½•çš„é€’å½’å’Œdpæ•°ç»„çš„è¿­ä»£(å¯é™ç©ºé—´å¤æ‚åº¦ä¸ºO(1)) æ–æ³¢é‚£å¥‘æ•°åˆ— LeetCode509 æ–æ³¢é‚£å¥‘æ•°åˆ— å‡‘é›¶é’± LeetCode322 é›¶é’±å…‘æ¢ æ€»ç»“è®¡ç®—æœºè§£å†³é—®é¢˜å…¶å®æ²¡æœ‰ä»»ä½•å¥‡æŠ€æ·«å·§ï¼Œå®ƒå”¯ä¸€çš„è§£å†³åŠæ³•å°±æ˜¯ç©·ä¸¾ï¼Œ ç©·ä¸¾æ‰€æœ‰å¯èƒ½æ€§ã€‚ç®—æ³•è®¾è®¡æ— éå°±æ˜¯å…ˆæ€è€ƒâ€œå¦‚ä½•ç©·ä¸¾â€ï¼Œç„¶åå†è¿½æ±‚â€œå¦‚ä½•èªæ˜åœ°ç©·ä¸¾â€ã€‚ åˆ—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå°±æ˜¯åœ¨è§£å†³â€œå¦‚ä½•ç©·ä¸¾â€çš„é—®é¢˜ã€‚ä¹‹æ‰€ä»¥è¯´å®ƒéš¾ï¼Œä¸€æ˜¯å› ä¸ºå¾ˆå¤šç©·ä¸¾éœ€è¦é€’å½’å®ç°ï¼ŒäºŒæ˜¯å› ä¸ºæœ‰çš„é—®é¢˜æœ¬èº«çš„è§£ç©ºé—´å¤æ‚ï¼Œä¸é‚£ä¹ˆå®¹æ˜“ç©·ä¸¾å®Œæ•´ã€‚ å¤‡å¿˜å½•ã€DP table å°±æ˜¯åœ¨è¿½æ±‚â€œå¦‚ä½•èªæ˜åœ°ç©·ä¸¾â€ã€‚ç”¨ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯ï¼Œæ˜¯é™ä½æ—¶é—´å¤æ‚åº¦çš„ä¸äºŒæ³•é—¨ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¯•é—®ï¼Œè¿˜èƒ½ç©å‡ºå•¥èŠ±æ´»ï¼Ÿ å›æº¯ç®—æ³•(æ¡†æ¶)Tips:å›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„ç»†å¾®å·®åˆ«æ˜¯ï¼šå›æº¯ç®—æ³•æ˜¯åœ¨éå†ã€Œæ ‘æã€ï¼ŒDFS ç®—æ³•æ˜¯åœ¨éå†ã€ŒèŠ‚ç‚¹ã€ å›æº¯ç®—æ³•æ¡†æ¶res = []def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨):\tif æ»¡è¶³ç»“æŸæ¡ä»¶: res.add(è·¯å¾„) return\tfor é€‰æ‹© in é€‰æ‹©åˆ—è¡¨: åšé€‰æ‹© backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨) æ’¤é”€xrz å…¶æ ¸å¿ƒå°±æ˜¯ for å¾ªç¯é‡Œé¢çš„é€’å½’ï¼Œåœ¨é€’å½’è°ƒç”¨ä¹‹å‰ã€Œåšé€‰æ‹©ã€ï¼Œåœ¨é€’å½’è°ƒç”¨ä¹‹åã€Œæ’¤é”€é€‰æ‹©ã€ å…¨æ’åˆ—é—®é¢˜ LeetCode46 å…¨æ’åˆ— å…¨æ’åˆ—è¯¦è§£ Nçš‡åé—®é¢˜ LeetCode51 Nçš‡å æ€»ç»“ æ—¶é—´å¤æ‚åº¦éƒ½ä¸å¯èƒ½ä½äº O(N!)ï¼Œå› ä¸ºç©·ä¸¾æ•´æ£µå†³ç­–æ ‘æ˜¯æ— æ³•é¿å…çš„ã€‚è¿™ä¹Ÿæ˜¯å›æº¯ç®—æ³•çš„ä¸€ä¸ªç‰¹ç‚¹ï¼Œä¸åƒåŠ¨æ€è§„åˆ’å­˜åœ¨é‡å å­é—®é¢˜å¯ä»¥ä¼˜åŒ–ï¼Œå›æº¯ç®—æ³•å°±æ˜¯çº¯æš´åŠ›ç©·ä¸¾ï¼Œå¤æ‚åº¦ä¸€èˆ¬éƒ½å¾ˆé«˜ã€‚ å†™ backtrack å‡½æ•°æ—¶ï¼Œéœ€è¦ç»´æŠ¤èµ°è¿‡çš„ã€Œè·¯å¾„ã€å’Œå½“å‰å¯ä»¥åšçš„ã€Œé€‰æ‹©åˆ—è¡¨ã€ï¼Œå½“è§¦å‘ã€Œç»“æŸæ¡ä»¶ã€æ—¶ï¼Œå°†ã€Œè·¯å¾„ã€è®°å…¥ç»“æœé›†ã€‚ å›æº¯-æ’åˆ—,ç»„åˆ,å­é›†æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— nums ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š å…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ [7]ã€‚ å…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,5,2,1,2]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,2,1] å’Œ [5,2]ã€‚ å…ƒç´ æ— é‡å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡ã€‚ â€‹ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,3] å’Œ [7]ã€‚ â€‹\tä½†æ— è®ºå½¢å¼æ€ä¹ˆå˜åŒ–ï¼Œå…¶æœ¬è´¨å°±æ˜¯ç©·ä¸¾æ‰€æœ‰è§£ï¼Œè€Œè¿™äº›è§£å‘ˆç°æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥åˆç†ä½¿ç”¨å›æº¯ç®—æ³•æ¡†æ¶ï¼Œç¨æ”¹ä»£ç æ¡†æ¶å³å¯æŠŠè¿™äº›é—®é¢˜ä¸€ç½‘æ‰“å°½ã€‚ â€‹\tå›æº¯ç®—æ³•æ ¸å¿ƒ å­é›†(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode78 å­é›† ç»„åˆ(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode77 ç»„åˆ æ’åˆ—(å…ƒç´ æ— é‡ä¸å¯å¤é€‰) LeetCode46 å…¨æ’åˆ— å­é›†ç»„åˆ(å…ƒç´ å¯é‡ä¸å¯å¤é€‰) LeetCode å­é›†2 LeetCode ç»„åˆæ€»å’Œ2 æ’åˆ—(å…ƒç´ å¯é‡ä¸å¯å¤é€‰) å…¨æ’åˆ—2 å­é›†ç»„åˆ(å…ƒç´ æ— é‡å¯å¤é€‰) LeetCode39 ç»„åˆæ€»å’Œ æ’åˆ—(å…ƒç´ æ— é‡å¯å¤é€‰) æ€»ç»“ å…ƒç´ æ— é‡å¤ä¸å¯å¤é€‰ # ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums, start)\tfor i in range(start, len(nums)) # åšé€‰æ‹© tarck.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i+1) # æ’¤é”€é€‰æ‹© track.removeLast()\t# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums) for i in range(len(nums)) # å‰ªæé€»è¾‘ if used[i]: continue # åšé€‰æ‹© used[i] = true track.addLast(nums[i]) backtrack(nums) # æ’¤é”€é€‰æ‹© track.removeLast() used[i] = false å…ƒç´ å¯é‡ä¸å¯å¤é€‰ nums.sort()# ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums, start) # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ for i in range(start, len(nums)) # å‰ªæé€»è¾‘,è·³è¿‡ç›¸åŒçš„ç›¸é‚»æ ‘æ if istart and nums[i]==nums[i-1]: continue # åšé€‰æ‹© track.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i+1) # æ’¤é”€é€‰æ‹© track.removeLast() nums.sort()# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums) for i in range(len(nums)) # å‰ªæé€»è¾‘ if used[i]:continue # å‰ªæé€»è¾‘,å›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½® if i0 and nums[i]==nums[i-1] and not used[i-1]: continue # åšé€‰æ‹© used[i] = true track.addLast(nums[i]) backtrack(nums) #æ’¤é”€é€‰æ‹© track.removeLast() used[i] = false å…ƒç´ æ— é‡å¯å¤é€‰ # ç»„åˆ/å­é›†é—®é¢˜å›æº¯æ¡†æ¶def backtrack(nums, start) # å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶\tfor i in range(start, len(nums)) # åšé€‰æ‹© track.addLast(nums[i]) # æ³¨æ„å‚æ•° backtrack(nums, i) # æ’¤é”€é€‰æ‹© track.removeLase()\t# æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶def backtrack(nums)\tfor i in range(len(nums)) # åšé€‰æ‹© track.addLast(nums[i]) backtrack(nums) # æ’¤é”€é€‰æ‹© track.removeLast() BFS(æ¡†æ¶) BFSæ¡†æ¶: å±‚åºéå† äºŒå‰æ ‘çš„æœ€å°é«˜åº¦ LeetCode111 äºŒå‰æ ‘çš„æœ€å°é«˜åº¦ è§£å¼€å¯†ç é”çš„æœ€å°‘æ¬¡æ•° LeetCode752 æ‰“å¼€è½¬ç›˜é” åŒå‘BFSä¼˜åŒ– ä¼ ç»Ÿçš„ BFS æ¡†æ¶å°±æ˜¯ä»èµ·ç‚¹å¼€å§‹å‘å››å‘¨æ‰©æ•£ï¼Œé‡åˆ°ç»ˆç‚¹æ—¶åœæ­¢ï¼›è€ŒåŒå‘ BFS åˆ™æ˜¯ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶å¼€å§‹æ‰©æ•£ï¼Œå½“ä¸¤è¾¹æœ‰äº¤é›†çš„æ—¶å€™åœæ­¢ã€‚ äºŒåˆ†æœç´¢ å¯»æ‰¾ä¸€ä¸ªæ•°(åŸºæœ¬çš„äºŒåˆ†æœç´¢) LeetCode704 äºŒåˆ†æŸ¥æ‰¾ def binarySearch(nums, target)\tleft, right = 0, len(nums)-1\twhile(left=right): mid = left+(right-left)//2 if(nums[mid]==target): # ç›´æ¥è¿”å› return mid elif nums[mid]target: right = mid-1 elif nums[mid]target: left = mid+1 # ç›´æ¥è¿”å›\treturn -1 å¯»æ‰¾å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æœç´¢ def left_bound(nums, target) left, right = 0, len(nums)-1 # æœç´¢åŒºé—´ä¸º[left, right] while left=right: mid = left + (right-left)//2 if nums[mid]==target: # æ”¶ç¼©å³ä¾§è¾¹ç•Œ right = mid+1 elif nums[mid]target: # æœç´¢åŒºé—´å˜ä¸º[mid+1, right] left = mid+1 elif nums[mid]target: # æœç´¢åŒºé—´å˜ä¸º[left, mid-1] right = mid # åˆ¤æ–­targetæ˜¯å¦å­˜åœ¨äºnumsä¸­ # æ­¤æ—¶targetæ¯”æ‰€æœ‰æ•°éƒ½å¤§,è¿”å›-1 if left==len(nums): return -1 # åˆ¤æ–­ä¸€ä¸‹nums[left]æ˜¯ä¸æ˜¯target return nums[left]==target ? left : -1 å¯»æ‰¾å³ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ def right_bound(nums, target) left, right = 0, len(nums)-1 while left=right: mid = left+(right-left)//2 if nums[mid]target: left=mid+1 elif nums[mid]target: right = mid-1 elif nums[mid]==target: # æ”¶ç¼©å·¦è¾¹ç•Œ left = mid+1 # æœ€åæ”¹æˆè¿”å›left-1 if left-1 0: return -1 return nums[left-1]==target ? left-1 :-1 æ€»ç»“: â€‹\tLeetCode34 åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½® æœ€åŸºæœ¬çš„äºŒåˆ†æŸ¥æ‰¾ç®—æ³• å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.length - 1æ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right]æ‰€ä»¥å†³å®šäº† while (left = right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid+1 å’Œ right = mid-1å› ä¸ºæˆ‘ä»¬åªéœ€æ‰¾åˆ°ä¸€ä¸ª target çš„ç´¢å¼•å³å¯æ‰€ä»¥å½“ nums[mid] == target æ—¶å¯ä»¥ç«‹å³è¿”å› å¯»æ‰¾å·¦ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.lengthæ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right)æ‰€ä»¥å†³å®šäº† while (left right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid + 1 å’Œ right = midå› ä¸ºæˆ‘ä»¬éœ€æ‰¾åˆ° target çš„æœ€å·¦ä¾§ç´¢å¼•æ‰€ä»¥å½“ nums[mid] == target æ—¶ä¸è¦ç«‹å³è¿”å›è€Œè¦æ”¶ç´§å³ä¾§è¾¹ç•Œä»¥é”å®šå·¦ä¾§è¾¹ç•Œ å¯»æ‰¾å³ä¾§è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾ å› ä¸ºæˆ‘ä»¬åˆå§‹åŒ– right = nums.lengthæ‰€ä»¥å†³å®šäº†æˆ‘ä»¬çš„ã€Œæœç´¢åŒºé—´ã€æ˜¯ [left, right)æ‰€ä»¥å†³å®šäº† while (left right)åŒæ—¶ä¹Ÿå†³å®šäº† left = mid + 1 å’Œ right = midå› ä¸ºæˆ‘ä»¬éœ€æ‰¾åˆ° target çš„æœ€å³ä¾§ç´¢å¼•æ‰€ä»¥å½“ nums[mid] == target æ—¶ä¸è¦ç«‹å³è¿”å›è€Œè¦æ”¶ç´§å·¦ä¾§è¾¹ç•Œä»¥é”å®šå³ä¾§è¾¹ç•Œåˆå› ä¸ºæ”¶ç´§å·¦ä¾§è¾¹ç•Œæ—¶å¿…é¡» left = mid + 1æ‰€ä»¥æœ€åæ— è®ºè¿”å› left è¿˜æ˜¯ rightï¼Œå¿…é¡»å‡ä¸€ æ»‘åŠ¨çª—å£ æ»‘åŠ¨çª—å£æ¡†æ¶ left, right = 0,0while rightlen(s): # cæ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ window.add(s[right]) # å¢å¤§çª—å£ right += 1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... # debugè¾“å‡ºçš„ä½ç½® printf(Window:[%d, %d] , left, right) # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while window needs shrink: # dæ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ char d = s[left] # ç¼©å°çª—å£ left+=1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... æœ€å°è¦†ç›–å­ä¸² LeetCode76 æœ€å°è¦†ç›–å­ä¸² å­—ç¬¦ä¸²æ’åˆ— LeetCode567 å­—ç¬¦ä¸²çš„æ’åˆ— æ‰¾æ‰€æœ‰å­—æ¯å¼‚ä½è¯ LeetCode438 æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ æœ€é•¿æ— é‡å¤å­ä¸² LeetCode3 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² æ€»ç»“: 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥æ‰©å¤§çª—å£? 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥ç¼©å°çª—å£? 1. ä»€ä¹ˆæ—¶å€™åº”è¯¥æ›´æ–°ç­”æ¡ˆ? ä¹°è‚¡ç¥¨(DP) çŠ¶æ€è½¬ç§»æ–¹ç¨‹ base caseï¼šdp[-1][...][0] = dp[...][0][0] = 0dp[-1][...][1] = dp[...][0][1] = -infinityçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) base case dp[-1][...][0] = 0è§£é‡Šï¼šå› ä¸º i æ˜¯ä» 0 å¼€å§‹çš„ï¼Œæ‰€ä»¥ i = -1 æ„å‘³ç€è¿˜æ²¡æœ‰å¼€å§‹ï¼Œè¿™æ—¶å€™çš„åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚dp[-1][...][1] = -infinityè§£é‡Šï¼šè¿˜æ²¡å¼€å§‹çš„æ—¶å€™ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚dp[...][0][0] = 0è§£é‡Šï¼šå› ä¸º k æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ k = 0 æ„å‘³ç€æ ¹æœ¬ä¸å…è®¸äº¤æ˜“ï¼Œè¿™æ—¶å€™åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚dp[...][0][1] = -infinityè§£é‡Šï¼šä¸å…è®¸äº¤æ˜“çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚ LeetCode121 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº LeetCode122 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº2 LeetCode309 æœ€ä½³ä¹°å–è‚¡ç¥¨å«å†·å†»æœŸ LeetCode714 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹ LeetCode123 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº3 LeetCode188 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº4 æ‰“å®¶åŠ«èˆ(DP) æ‰“å®¶åŠ«èˆ1 LeetCode198 æ‰“å®¶åŠ«èˆ # å¸¦å¤‡å¿˜å½•def rob(nums): n = len(nums) if n==0: return 0\tif n==1: return nums[0]\tdp = [0]*n dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[n-1]# ä¼˜åŒ–ç©ºé—´def rob(nums): prev, curr = 0, 0 for i in nums: prev, curr = curr, max(curr, prev+1) return curr æ‰“å®¶åŠ«èˆ2 LeetCode213 æ‰“å®¶åŠ«èˆ2 æ‰“å®¶åŠ«èˆ3 LeetCode337 æ‰“å®¶åŠ«èˆ3 nSum ä¸¤æ•°ä¹‹å’Œ LeetCode1 ä¸¤æ•°ä¹‹å’Œ 3Sum LeetCode15 ä¸‰æ•°ä¹‹å’Œ 4Sum LeetCode18 å››æ•°ä¹‹å’Œ ç¬¬ä¸€ç«  æ•°æ®ç»“æ„é“¾è¡¨1æ‹‰å®¾-å¡æ™® æ•°ç»„äºŒå‰æ ‘å›¾è®¾è®¡æ•°æ®ç»“æ„","tags":["ç®—æ³•","æ•°æ®ç»“æ„","LeetCode","Python"],"categories":["ç®—æ³•"]},{"title":"è“æ¡¥æ¯å¤‡èµ›","path":"/2023/04/19/è“æ¡¥æ¯å¤‡èµ›/","content":"è“æ¡¥æ¯æš´åŠ›dfsbfså›æº¯åŠ¨æ€è§„åˆ’èƒŒåŒ…é—®é¢˜æ•°è®ºæœ€å¤§å…¬çº¦æ•°def gcd(a, b): if b == 0: reutrn a a, b = b, a % b return gcd(a, b) ä¸­å›½å‰©ä½™å®šç†def exgcd(a, b): if b == 0: return 1, 0 else: x, y = exgcd(b, a % b) return y, (x - a // b * y)def CRT(k, a, r): n = 1; ans = 0 for i in range(1, k + 1): n = n * r[i] for i in range(1, k + 1): m = n // r[i] b, y = exgcd(m, r[i]) # b * m mod r[i] = 1 while b 0: b += r[i] ans = (ans + a[i] * m * b) % n return (ans % n + n) % nr = [0, 3, 5, 7]a = [0, 2, 3, 2]print(CRT(3, a, r)) ç­›æ³•æ±‚ç´ æ•°def isPrime(n):\tprime = [True] * n for i in range(2, n + 1): if prime[i]: for i in range(i * 2, n + 1, i): prime[i] = False return [i for i in range(2, n) if prime[i]] å›¾è®ºå›¾è®ºåŸºç¡€åŠéå†æ„å»ºå›¾(é‚»æ¥è¡¨) def buildGraph(numCourses: int, prerequisites: List[List[int]]) - List[List[int]]: # å›¾ä¸­å…±æœ‰ numCourses ä¸ªèŠ‚ç‚¹ graph = [[] for _ in range(numCourses)] for edge in prerequisites: from_, to_ = edge[1], edge[0] # æ·»åŠ ä¸€æ¡ä» from æŒ‡å‘ to çš„æœ‰å‘è¾¹ # å¦‚æœæ˜¯æ— å‘å›¾ï¼Œåˆ™å†åå‘æ·»åŠ ä¸€æ¬¡ graph[from_].append(to_) return graph å›¾çš„éå† # è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹visited = []# è®°å½•ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„onPath = []def traverse(graph, s): if visited[s]: return # ç»è¿‡èŠ‚ç‚¹ sï¼Œæ ‡è®°ä¸ºå·²éå† visited[s] = True # åšé€‰æ‹©ï¼šæ ‡è®°èŠ‚ç‚¹ s åœ¨è·¯å¾„ä¸Š onPath[s] = True for neighbor in graph.neighbors(s): traverse(graph, neighbor) # æ’¤é”€é€‰æ‹©ï¼šèŠ‚ç‚¹ s ç¦»å¼€è·¯å¾„ onPath[s] = False ç¯æ£€æµ‹åŠæ‹“æ‰‘æ’åºç¯æ£€æµ‹ def canFinish(self, numCourses: int, prerequisites: List[List[int]]) - bool: graph = self.buildGraph(numCourses, prerequisites) self.visited = [False] * numCourses self.onPath = [False] * numCourses self.hasCycle = False for i in range(numCourses): self.traverse(graph, i) return not self.hasCycledef traverse(self, graph, s): if self.onPath[s]: self.hasCycle = True if self.visited[s] or self.hasCycle: return self.visited[s] = True self.onPath[s] = True for t in graph[s]: self.traverse(graph, t) self.onPath[s] = Falsedef buildGraph(self, numCourses, prerequisites): # ä»£ç è§å‰æ–‡ æ‹“æ‰‘æ’åº def findOrder(numCourses: int, prerequisites: List[List[int]]) - List[int]: # è®°å½•ååºéå†ç»“æœ postorder = [] # è®°å½•æ˜¯å¦å­˜åœ¨ç¯ hasCycle = False visited = [False] * numCourses onPath = [False] * numCourses # å»ºå›¾å‡½æ•° def buildGraph(numCourses, prerequisites): # ä»£ç è§å‰æ–‡ pass # å›¾éå†å‡½æ•° def traverse(graph, s): if onPath[s]: # å‘ç°ç¯ hasCycle = True if visited[s] or hasCycle: return # å‰åºéå†ä½ç½® onPath[s] = True visited[s] = True for t in graph[s]: traverse(graph, t) # ååºéå†ä½ç½® postorder.append(s) onPath[s] = False graph = buildGraph(numCourses, prerequisites) # éå†å›¾ for i in range(numCourses): traverse(graph, i) # æœ‰ç¯å›¾æ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº if hasCycle[0]: return [] # é€†ååºéå†ç»“æœå³ä¸ºæ‹“æ‰‘æ’åºç»“æœ return postorder[::-1] äºŒåˆ†å›¾åˆ¤å®šdef __init__(self): # è®°å½•å›¾æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾æ€§è´¨ self.ok = True # è®°å½•å›¾ä¸­èŠ‚ç‚¹çš„é¢œè‰²ï¼ŒFalseå’ŒTrueä»£è¡¨ä¸¤ç§ä¸åŒé¢œè‰² self.color = [] # è®°å½•å›¾ä¸­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ self.visited = []# ä¸»å‡½æ•°ï¼Œè¾“å…¥é‚»æ¥è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾def isBipartite(self, graph: List[List[int]]) - bool: n = len(graph) self.color = [False] * n self.visited = [False] * n # å› ä¸ºå›¾ä¸ä¸€å®šæ˜¯è”é€šçš„ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå­å›¾ # æ‰€ä»¥è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹éƒ½ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¸€æ¬¡éå† # å¦‚æœå‘ç°ä»»ä½•ä¸€ä¸ªå­å›¾ä¸æ˜¯äºŒåˆ†å›¾ï¼Œæ•´å¹…å›¾éƒ½ä¸ç®—äºŒåˆ†å›¾ for v in range(n): if not self.visited[v]: self.traverse(graph, v) if not self.ok: break return self.ok# DFS éå†æ¡†æ¶def traverse(self, graph: List[List[int]], v: int) - None: # å¦‚æœå·²ç»ç¡®å®šä¸æ˜¯äºŒåˆ†å›¾äº†ï¼Œå°±ä¸ç”¨æµªè´¹æ—¶é—´å†é€’å½’éå†äº† if not self.ok: return self.visited[v] = True for w in graph[v]: if not self.visited[w]: # ç›¸é‚»èŠ‚ç‚¹ w æ²¡æœ‰è¢«è®¿é—®è¿‡ # é‚£ä¹ˆåº”è¯¥ç»™èŠ‚ç‚¹ w æ¶‚ä¸Šå’ŒèŠ‚ç‚¹ v ä¸åŒçš„é¢œè‰² self.color[w] = not self.color[v] # ç»§ç»­éå† w self.traverse(graph, w) else: # ç›¸é‚»èŠ‚ç‚¹ w å·²ç»è¢«è®¿é—®è¿‡ # æ ¹æ® v å’Œ w çš„é¢œè‰²åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾ if self.color[w] == self.color[v]: # è‹¥ç›¸åŒï¼Œåˆ™æ­¤å›¾ä¸æ˜¯äºŒåˆ†å›¾ self.ok = False return Primæœ€å°ç”Ÿæˆæ ‘import heapqclass Prim: # æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå­˜å‚¨ã€Œæ¨ªåˆ‡è¾¹ã€çš„ä¼˜å…ˆçº§é˜Ÿåˆ— def __init__(self, graph: List[List[int]]): self.graph = graph self.pq = [] # PriorityQueueint[] çš„å®ç° self.inMST = [False] * len(graph) # ç±»ä¼¼ visited æ•°ç»„çš„ä½œç”¨ï¼Œè®°å½•å“ªäº›èŠ‚ç‚¹å·²ç»æˆä¸ºæœ€å°ç”Ÿæˆæ ‘çš„ä¸€éƒ¨åˆ† self.weightSum = 0 # è®°å½•æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡å’Œ self.inMST[0] = True # éšä¾¿ä»ä¸€ä¸ªç‚¹å¼€å§‹åˆ‡åˆ†éƒ½å¯ä»¥ï¼Œæˆ‘ä»¬ä¸å¦¨ä»èŠ‚ç‚¹ 0 å¼€å§‹ self.cut(0) # ä¸æ–­è¿›è¡Œåˆ‡åˆ†ï¼Œå‘æœ€å°ç”Ÿæˆæ ‘ä¸­æ·»åŠ è¾¹ while self.pq: # æŒ‰ç…§è¾¹çš„æƒé‡ä»å°åˆ°å¤§æ’åº edge = heapq.heappop(self.pq) to = edge[1] # è¡¨ç¤ºç›¸é‚»èŠ‚ç‚¹ weight = edge[2] # è¡¨ç¤ºè¿™æ¡è¾¹çš„æƒé‡ if self.inMST[to]: # èŠ‚ç‚¹ to å·²ç»åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œè·³è¿‡ã€‚å¦åˆ™è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ continue self.weightSum += weight # å°†è¾¹ edge åŠ å…¥æœ€å°ç”Ÿæˆæ ‘ self.inMST[to] = True self.cut(to) # èŠ‚ç‚¹ to åŠ å…¥åï¼Œè¿›è¡Œæ–°ä¸€è½®åˆ‡åˆ†ï¼Œä¼šäº§ç”Ÿæ›´å¤šæ¨ªåˆ‡è¾¹ # å°† s çš„æ¨ªåˆ‡è¾¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ— def cut(self, s): for edge in self.graph[s]: # éå† s çš„é‚»è¾¹ to = edge[1] # ç›¸é‚»çš„èŠ‚ç‚¹ if self.inMST[to]: # ç›¸é‚»æ¥ç‚¹ to å·²ç»åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œè·³è¿‡ continue heapq.heappush(self.pq, edge) # åŠ å…¥æ¨ªåˆ‡è¾¹é˜Ÿåˆ— # æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡å’Œ def weightSum(self) - int: return self.weightSum # åˆ¤æ–­æœ€å°ç”Ÿæˆæ ‘æ˜¯å¦åŒ…å«å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ def allConnected(self) - bool: for i in range(len(self.inMST)): if not self.inMST[i]: return False return True Dijstraæœ€çŸ­è·¯å¾„import heapqfrom typing import List# å‡è®¾ graph æ˜¯ä¸€ä¸ªé‚»æ¥çŸ©é˜µï¼Œgraph[i][j] æ˜¯ä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„è·ç¦»def dijkstra(start: int, graph: List[List[int]]) - List[int]: V = len(graph) distTo = [float(inf)] * V distTo[start] = 0 pq = [(0, start)] # ä½¿ç”¨å…ƒç»„ (distance, node)ï¼Œä»¥ä¾¿æŒ‰ç…§ distance è¿›è¡Œæ’åº while pq: (dist, curNodeID) = heapq.heappop(pq) if dist distTo[curNodeID]: continue for weight, nextNodeID in graph[curNodeID]: if weight is not None: # å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ‰è¾¹ distToNextNode = distTo[curNodeID] + weight if distTo[nextNodeID] distToNextNode: distTo[nextNodeID] = distToNextNode heapq.heappush(pq, (distToNextNode, nextNodeID)) return distTo","tags":["ç®—æ³•","Python","è“æ¡¥æ¯"],"categories":["ç®—æ³•"]},{"title":"Hello World","path":"/2023/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":["Hexo"],"categories":["Hexo"]},{"title":"å®‰å“ç¬¬ä¸€æ¬¡è¯¾","path":"/2022/11/19/å®‰å“ç¬¬ä¸€æ¬¡è¯¾/","content":"æ­å–œå¤§å®¶éƒ½è¿˜èƒ½æ´»åˆ°è¿™èŠ‚è¯¾ï¼Œä»ç°åœ¨å¼€å§‹æˆ‘ä»¬è¿›å…¥Androidçš„å­¦ä¹ ï¼Œå‰é¢Javaæ²¡å­¦ä¼šçš„ä¹Ÿä¸è¦ç´§ï¼Œåœ¨ä»¥åçš„å­¦ä¹ ä¸­å°±èƒ½æ…¢æ…¢ç†è§£äº†ï¼Œæ¥ä¸‹æ¥å¼€å§‹èµ·é£ã€‚ å®‰è£…Android Studioå·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨ã€‚åœ¨å­¦ä¹ ä¹‹å‰ï¼Œè¿™é‡Œæœ‰ä»½å²è¯—çº§æ–°æ‰‹è£…å¤‡å¾…ä½ é¢†å–ï¼Œå®ƒå«ASã€‚ å’ŒIDEAä¸€æ ·ï¼Œè¿›å…¥ToolBoxä¸‹è½½ æ‰“å¼€ASï¼Œé€‰æ‹©ä¸å¯¼å…¥ ä¸å‘è°·æ­Œå‘é€ï¼Œä¸‹ä¸€æ­¥ å…ˆä¸è®¾ç½®ä»£ç†ï¼Œä¸‹ä¸€æ­¥ æœ‰æ¢¯å­çš„åŒå­¦å¯ä»¥è®¾ç½®ä»£ç† é€‰æ‹©æ ‡å‡†å®‰è£…ï¼Œä¸‹ä¸€æ­¥ é€‰æ‹©ä¸»é¢˜ï¼Œä¸‹ä¸€æ­¥ ä¸‹ä¸€æ­¥ï¼Œæ¥å—æ¡æ¬¾ï¼Œä¸‹ä¸€æ­¥ ç­‰å¾…ä¸‹è½½ï¼Œç„¶åç‚¹å‡»Finish ç­‰å¾…æ—¶é—´è¾ƒé•¿ï¼Œè§‰å¾—æ…¢ç”¨æµé‡å¼€çƒ­ç‚¹ï¼Œè¿™æ ¡å›­ç½‘å¤ªåƒåœ¾ï¼ å®‰è£…å®Œæˆï¼Œæ¥ä¸‹æ¥å¼€å§‹ä½ çš„ç¬¬ä¸€ä¸ªAPPğŸ‰ æ³¨ï¼šä»ASæ˜¯çº¯è‹±æ–‡ç‰ˆï¼Œæ±‰åŒ–æ’ä»¶éœ€è¦è‡ªå·±å»æ‰¾ï¼Œä¸æ¨èä½¿ç”¨æ±‰åŒ–ï¼Œä»¥åçš„å¾ˆå¤šæ–‡æ¡£éƒ½æ˜¯è‹±æ–‡çš„ï¼Œå„ä½éœ€æ‰“å¥½è‹±è¯­åŸºç¡€ã€‚ ç¬¬ä¸€ä¸ªAPP æ–°å»ºä¸€ä¸ªé¡¹ç›® é€‰æ‹©Empty Activityï¼Œç‚¹å‡»ä¸‹ä¸€æ­¥ å…¶ä»–Activityæœ‰å¾ˆå¤šæ¨¡æ¿ä»£ç ï¼Œæˆ‘ä»¬ä¹Ÿç”¨ä¸åˆ° é€‰æ‹©Javaè¯­è¨€ï¼Œå®‰å“å…¼å®¹æœ€ä½ç‰ˆæœ¬ä¸ºå®‰å“7 ç›®å‰å¸‚åœºä¸Šå¤§éƒ¨åˆ†å®‰å“ç‰ˆæœ¬éƒ½åœ¨å®‰å“7ä»¥ä¸Šï¼Œåªæœ‰å°éƒ¨åˆ†è¿˜æ˜¯å®‰å“5ï¼Œæˆ‘ä»¬ä¸ç”¨å»ç®¡å®ƒ ç­‰å¾…ä¸‹è½½å®Œæˆ ç­‰å¾…æ—¶é—´è¾ƒé•¿ï¼Œè§‰å¾—æ…¢ç”¨æµé‡å¼€çƒ­ç‚¹ï¼Œè¿™æ ¡å›­ç½‘å¤ªåƒåœ¾ï¼ è¿è¡Œç¬¬ä¸€ä¸ªAppï¼Œç‚¹å‡»ç»¿è‰²çš„ä¸‰è§’ Pixel_3a_API_33_x86_64æ˜¯æˆ‘ä»¬åœ¨ASçš„æ¨¡æ‹Ÿå™¨ ç­‰ä¸€ä¼šå°±è¿è¡ŒæˆåŠŸäº†ğŸ‰ åˆšæ‰é‚£ä¸ªæ˜¯åœ¨æ¨¡æ‹Ÿå™¨ä¸Šè¿è¡Œï¼Œå®é™…ä¸Šï¼Œæˆ‘ä»¬ä¸€èˆ¬é€‰æ‹©ç”¨çœŸæœºè°ƒè¯•ï¼Œå› ä¸ºæ¨¡æ‹Ÿå™¨ä¸Šæœ‰ä¸€äº›å¥‡æ€ªçš„bugï¼Œè€Œä¸”è½»è–„æœ¬ç”¨æ¨¡æ‹Ÿå™¨ä¼šå¡ğŸ¥€ æ‰‹æœºæ‰“å¼€usbè°ƒè¯•ï¼Œä»¥å°ç±³æ‰‹æœºä¸ºä¾‹ï¼šè¿ç»­ç‚¹å‡»MIUIç‰ˆæœ¬7ä¸‹ï¼Œå¼€å¯å¼€å‘è€…é€‰é¡¹ï¼Œæ‰“å¼€USBè°ƒè¯• ç”¨æ•°æ®çº¿è¿æ¥ç”µè„‘ ç¬¬ä¸€æ¬¡è¿æ¥ä¼šæç¤ºä½ é…å¯¹ï¼Œç‚¹ç¡®å®šå°±å¥½äº† ç„¶åASä¸Šä¼šæ˜¾ç¤ºä½ çš„è®¾å¤‡ ç‚¹å‡»ç»¿ä¸‰è§’è¿è¡Œ æ‰‹æœºä¸ŠåŒæ„é€šè¿‡USBå®‰è£…åº”ç”¨ ä½ æˆåŠŸåœ¨æ‰‹æœºä¸Šè¿è¡Œäº†è‡ªå·±çš„APPğŸ‰ğŸ‰ğŸ‰ æ¨èä¹¦ç± åœ¨æ­¤æ¨èçœŸæ­£çš„éƒ­ç¥å†™çš„ä¹¦ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹ç¬¬äºŒç‰ˆï¼ˆç”±äºè¯¥ä¹¦æ—¶é—´å‘è¡Œè¾ƒä¹…ï¼Œå¯èƒ½ä¸å¥½ä¹°åˆ°ä¸€æ‰‹ã€‚ç¾¤é‡Œæœ‰ pdfï¼‰ åˆ«ä¹°åˆ°è“è‰²çš„ç¬¬ä¸‰ç‰ˆäº† ç¬¬ä¸‰ç‰ˆå…¨éƒ¨ç”¨çš„ kotlinï¼Œé‡Œé¢è™½ç„¶ä¹Ÿæœ‰ä¸€äº› kotlin çš„è¯­æ³•è®²è§£ï¼Œä½†ä½ ä»¬ç›®å‰é˜¶æ®µå¯¹äº java æŒæ¡ä¸ç‰¢å›ºï¼Œä¸é€‚åˆå»å­¦ä¹  kotlin ä¹¦ä¸­çš„å‘ ç”±äº Android ä¸€å¹´ä¸€ä¸ªç‰ˆæœ¬ï¼Œæ‰€ä»¥ä¹¦ä¸­å¾ˆå¤šæ•™ç¨‹åˆ°ç°åœ¨éƒ½å·²ç»å¾ˆæ—§äº†ï¼Œåœ¨æ­¤æä¸€äº›å‘ support å¯¼åŒ…é—®é¢˜ ä¹¦ä¸­åœ¨è®²ä¸€äº›å¯¼åŒ…æ—¶éƒ½ä¼šè®©ä½ ä»¬åƒä¸Šå›¾ä¸€æ ·å¯¼å…¥ suport åŒ…ï¼Œç›®å‰è¯¥åŒ…å·²è¢«å®˜æ–¹åœæ­¢ç»´æŠ¤ï¼Œä¸”å·²ç»è¿ç§»è‡³ androidx çš„åŒ…ã€‚ è¿™æ˜¯ç›®å‰çš„androidxåŒ…ï¼ŒæŠ¥é»„çš„åŸå› æ˜¯å¯ä»¥å‡çº§äº†ï¼Œé¼ æ ‡ç§»è¿‡å»å°±å¯ä»¥å‡çº§ åœ¨è¿™é‡Œæˆ‘å»ºè®®åœ¨ä»£ç ä¸­ç›´æ¥è¾“å…¥è¦ä½¿ç”¨çš„æ§ä»¶çš„å…¨åï¼Œå†ä½¿ç”¨ Alt + Enterï¼ŒAS ä¼šè‡ªåŠ¨å¸®ä½ å¯¼åŒ…ï¼Œå¯¹äº build.gradle æ–‡ä»¶ä¸å»ºè®®ä½ ä»¬ä¿®æ”¹ ä¾‹å¦‚ï¼šå¯¼å…¥ RecyclerView å¯ä»¥ç›´æ¥åœ¨ä»£ç ä¸­å†™ï¼Œåœ¨é€‰æ‹©å AS ä¼šè‡ªåŠ¨å¸®ä½ å¯¼åŒ… ä½†ä»å­˜åœ¨éƒ¨åˆ†æ§ä»¶æˆ–è€…ä¾èµ– AS ä¹Ÿä¸çŸ¥é“çš„æƒ…å†µï¼Œè¿™æ—¶å°±éœ€è¦ä½ ä»¬è‡ªå·±è°·æ­Œæ‰¾æœ€æ–°çš„ä¾èµ–åŒ…äº† XMLç®€å•ä»‹ç» ä»€ä¹ˆæ˜¯XML XML (eXtensible Markup Language)æŒ‡å¯æ‰©å±•æ ‡è®°è¯­è¨€ï¼Œæ˜¯ä¸€ç§ç”¨äºæ ‡è®°ç”µå­æ–‡ä»¶ä½¿å…¶å…·æœ‰ç»“æ„æ€§çš„æ ‡è®°è¯­è¨€ã€‚ XMLçš„ç”¨é€”xmlè¢«ç”¨äºä¿¡æ¯çš„è®°å½•å’Œä¼ é€’ï¼Œå› æ­¤xmlç»å¸¸è¢«ç”¨äºå……å½“é…ç½®æ–‡ä»¶ã€‚ åœ¨Androidä¸­ï¼Œresæ–‡ä»¶ä¸‹å’Œmanifestä½¿ç”¨çš„æ˜¯xmlè¯­è¨€ XML ä»…ä»…æ˜¯çº¯æ–‡æœ¬XML æ²¡ä»€ä¹ˆç‰¹åˆ«çš„ï¼Œå®ƒä»…ä»…æ˜¯çº¯æ–‡æœ¬è€Œå·²ï¼Œæ‰€ä»¥resä¸‹çš„æ–‡ä»¶éœ€è¦å—åˆ°javaä¸‹çš„ä»£ç è°ƒç”¨ã€‚ XMLçš„æ ¼å¼ XML æ–‡æ¡£ç¬¬ä¸€è¡Œä»¥ XML å£°æ˜å¼€å§‹ï¼Œç”¨æ¥è¡¨è¿°æ–‡æ¡£çš„ä¸€äº›ä¿¡æ¯ ?xml version=1.0 encoding=UTF-8?site nameRedrock/name urlhttps://redrock.team/url logoredrock.png/logo descçº¢å²©ç½‘æ ¡å·¥ä½œç«™/desc/site ã€ã€ã€ åˆ†åˆ«ä¸ºæ ‡ç­¾ï¼Œæ ‡ç­¾å†…åŒ…å«äº†è¦ä¼ é€’çš„ä¿¡æ¯ã€‚ æ ‡ç­¾å¿…é¡»æˆå¯¹å‡ºç°ï¼Œæœ‰å¼€å§‹æ ‡ç­¾å°±éœ€è¦æœ‰ç»“æŸæ ‡ç­¾ï¼Œä¾‹å¦‚ï¼šå¼€å§‹æ ‡ç­¾ï¼š**** å’Œ ç»“æŸæ ‡ç­¾ï¼š**** æ ‡ç­¾æ˜¯æœ‰å±‚çº§çš„ï¼Œå¿…é¡»æ­£ç¡®çš„åµŒå¥—ï¼› æ ‡ç­¾åŒºåˆ†å¤§å°å†™ï¼› xmlå±æ€§å€¼å¿…é¡»åŠ å¼•å·ï¼Œä¾‹ TextView android:layout_width=wrap_content android:layout_height=wrap_content / Android é¡¹ç›®ç»“æ„ Android ä¸ä¹‹å‰ Java çš„ä¸€ä¸ªé¡¹ç›®ç›¸æ¯”å¤æ‚äº†è®¸å¤šï¼Œä¸‹é¢æˆ‘ä»¬å…ˆç®€å•è®¤è¯†ä¸€ä¸‹ã€‚ ç»“æ„è§†å›¾æœ‰Projectå’ŒAndroidä¸¤ç§ï¼ŒProjectå°±æ˜¯ä»¥æ–‡ä»¶å¤¹çš„å½¢å¼å±•ç¤ºï¼ŒAndroidæ˜¯ç¼–è¯‘åæ›´æ–¹ä¾¿çš„ä¸€ç§å±•ç¤ºã€‚ è°·æ­Œçˆ¸çˆ¸ä¸ºäº†ä½¿æˆ‘ä»¬çš„åº”ç”¨æ›´å¥½å¼€å‘ï¼ŒæŠŠä»£ç ä¸è§†å›¾è¿›è¡Œäº†åˆ†å±‚ï¼Œä¸»è¦çš„ç»“æ„è§†å›¾å¦‚ä¸‹ï¼šï¼ˆåœ¨ Android è§†å›¾ä¸‹)ï¼š javaä¸‹é¢å†™æˆ‘ä»¬çš„é€»è¾‘ä»£ç ï¼Œå°±å’Œä»¥å‰æˆ‘ä»¬åœ¨srcé‡Œå†™çš„ä¸€æ · resæ˜¯å†™å¸ƒå±€ä»£ç ï¼ŒåŒ…æ‹¬ä¸€äº›å›¾ç‰‡ï¼Œå¸ƒå±€ï¼Œä¸»é¢˜ï¼Œé¢œè‰²ç­‰ç­‰ã€‚ gradleæ˜¯é¡¹ç›®æ„å»ºï¼Œç›®å‰æˆ‘ä»¬ä¸ç”¨ç®¡ manifests ç”¨æ¥æ”¾ AndroidManifests.xml ç®€ç§°â€œæ³¨å†Œæ–‡ä»¶â€ æ³¨ï¼šä½†ç”±äºAndroid12çš„é—®é¢˜ï¼Œç›®å‰éœ€è¦åœ¨å¯åŠ¨çš„ activity çš„æ ‡ç­¾æ–°åŠ ä¸€å¥android:exportedâ€trueâ€ï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼šæ˜¯å¦æ”¯æŒå…¶å®ƒåº”ç”¨è°ƒç”¨å½“å‰ç»„ä»¶ javaä½ çš„æ‰€æœ‰ç”¨äºæ§åˆ¶è§†å›¾çš„ä»£ç éƒ½åœ¨è¿™é‡Œ ç¬¬ä¸€ä¸ªåŒ…å°±æ˜¯ä½ çš„æºä»£ç  java æ–‡ä»¶ï¼Œåé¢ä¸¤ä¸ªåŒ…æ˜¯æœ‰å…³æµ‹è¯•çš„ï¼Œä¸ç”¨å»äº†è§£ï¼Œä¹‹åçš„ä¸ªäººå¼€å‘ä¹Ÿä¸ä¼šç”¨åˆ°ä»–ä»¬ï¼Œç½‘æ ¡å¼€å‘ä¹Ÿæ²¡æœ‰ç”¨åˆ° resç”¨äºæ”¾è§†å›¾å’Œèµ„æºæ–‡ä»¶ drawableç”¨äºæ”¾å›¾ç‰‡èµ„æºä»¥åŠ xml ç±»å‹çš„å›¾ç‰‡ layoutç”¨äºæ”¾åº”ç”¨ä¸­æ¯ä¸ªç•Œé¢çš„åœ°æ–¹ mipmapè¿™é‡Œåªç”¨æ¥æ”¾åº”ç”¨çš„æ¡Œé¢å›¾æ ‡çš„ï¼ˆæ³¨ï¼šè¿™é‡Œä¸€èˆ¬ä¸æ˜¯ç”¨æ¥æ”¾åº”ç”¨å†…éƒ¨å›¾ç‰‡æˆ–è€…å›¾æ ‡çš„ï¼Œè¯¥æ–‡ä»¶å¤¹ä¸€èˆ¬ä¸ç”¨ï¼‰ valuesç”¨äºæ”¾ä¸€äº›å¼•ç”¨çš„æ–‡å­—æˆ–è€…é¢œè‰²ç­‰æ‚ä¸œè¥¿ è®¤è¯†HelloWorld ç›¸ä¿¡å„ä½éƒ½æƒ³è‡ªå·±å¼€å§‹åŠ¨æ‰‹æ”¹å†™ HelloWorldï¼Œä½†ä¸€æ‰“å¼€ java ä»£ç å´å‚»äº†çœ¼ï¼Œè¿™éƒ½æ˜¯äº›ä»€ä¹ˆé¬¼ï¼Ÿ java ä»£ç è®²è§£ ä½ ä¸€çœ‹MainActivityç»§æ‰¿äº AppCompatActivityï¼Œç„¶åç‚¹è¿›å»ä¸€çœ‹ï¼Œ666 è¡Œçš„è‹±æ–‡ï¼Œä»€ä¹ˆä¹Ÿçœ‹ä¸æ‡‚ã€‚ å…¶å®ä¸ç”¨ç®¡è¿™ä¹ˆå¤šï¼Œå°±è·Ÿä½ ä»¬å¼€å§‹å­¦ä¹  java ä¸€æ ·ï¼Œåªè¦è®°ä½ä¹‹å‰çš„ main() æ˜¯æ•´ä¸ªç¨‹åºçš„å…¥å£ï¼Œåœ¨ Android ä¸­è¿™ä¸ªå…¥å£â€œå˜æˆäº†â€ onCreated() ï¼ˆå…¶å®å…¥å£å¹¶ä¸æ˜¯å®ƒï¼‰ä»¥åä»£ç å°± â€œå…¨â€ å†™åœ¨ onCreated() ä¸­å°±å¯ä»¥äº†ï¼ˆåˆ«çœŸçš„æŠŠä»£ç å…¨å†™åœ¨ä¸€ä¸ªå‡½æ•°ä¸­äº†ï¼ï¼‰ å…³é”®è¯­å¥ setContentView()ç»†å¿ƒçš„ä½ è‚¯å®šèƒ½å‘ç°é™¤äº† super.onCreate() å¤–ï¼Œä»–è¿˜è‡ªå·±å¤šå†™äº†ä¸€ä¸ª setContentView(R.layout.activity_main)ã€‚ setContentView å­—é¢æ„æ€å°±æ˜¯ï¼šè®¾ç½®å†…å®¹è§†å›¾å‰é¢æˆ‘ä»¬è®²è¿‡ Android å°† è§†å›¾ ä¸ ä»£ç  è¿›è¡Œäº†åˆ†ç¦»ï¼Œè€Œè¿™å°±è¯å°±æ˜¯å°†è§†å›¾ä¸ä»£ç è¿›è¡Œåˆ¤å®šï¼Œå…¶ä¸­ R.layout æ˜¯ä¸€ç§å›ºå®šå†™æ³•ï¼Œç”¨äºå¼•ç”¨ layout æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶ï¼ˆtips: åŒç†ï¼ŒR.drawable è¡¨ç¤ºå¼•ç”¨ drawable æ–‡ä»¶å¤¹ä¸­çš„å›¾ç‰‡ï¼‰ layout ä¸­çš„ XML ç‚¹å‡» activity_main åè‚¯å®šæ›´æ‡µé€¼äº†ï¼Œè¿™åˆæ˜¯å†™çš„ä»€ä¹ˆï¼Ÿï¼ˆ555ï¼Œæˆ‘è¿˜æ˜¯é€€å­¦å§ï¼ï¼‰ ç›®å‰å¯ä»¥æ­»è®°ä½éœ€è¦è¿™æ ·å†™å³å¯ ä½†æˆ‘è¿˜æ˜¯ç»™å¤§å®¶ç®€å•æ¢³ç†ä¸‹ï¼š å…¶ä¸­ 2 ~ 8 è¡Œæ˜¯ä¸€ä½“çš„ï¼ˆä¸¥æ ¼æ¥è¯´è¿˜åŒ…æ‹¬ç¬¬19è¡Œï¼‰ï¼Œæç»˜äº†ä¸€ä¸ªåœ¨ androidx.constraintlayout.widget ä¸‹ä¸€ä¸ªå« ConstraintLayout çš„æ§ä»¶çš„è¡Œä¸ºï¼ˆä½•ä¸ºæ§ä»¶ï¼Ÿåé¢ä¼šè®²ï¼‰ åŒç†ï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªåå­—å« TextView çš„æ§ä»¶ å…¶ä¸­ç¬¬ 13 è¡Œæœ‰ä¸€ä¸ª â€œHello World!â€ï¼Œæˆ‘ä»¬æŠŠä»–æ”¹æˆ â€œHello RedRockï¼â€ï¼Œå†æ‰“åŒ…è¿è¡Œä¸€ä¸‹ï¼Œä½ å°±ä¼šå‘ç°åº”ç”¨çš„å­—å˜æˆäº† â€œHello Redrockï¼â€ ç®€å•çš„è®¤è¯†äº†HelloWorldåï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥è¿›è¡Œæ›´ç»†è‡´çš„è®²è§£ è§†å›¾çš„åŸºæœ¬å•ä½â€”â€”æ§ä»¶ æ§ä»¶ä¸­åˆ†ä¸ºå•ä¸€çš„ï¼Œç”¨äºä¸ç”¨æˆ·äº¤äº’çš„æ§ä»¶ (View) å’Œ è´Ÿè´£å¸ƒå±€çš„æ§ä»¶ (ViewGroup) View å¸¸ç”¨çš„ ViewTextViewä¸€ä¸ªç”¨äºæ˜¾ç¤ºæ–‡æœ¬çš„æ§ä»¶ è‡ªèº«å±æ€§ ä½œç”¨ android:text è®¾ç½®æ˜¾ç¤ºçš„æ–‡å­— android:textSize è®¾ç½®å­—ä½“å¤§å° android:textStyle è®¾ç½®å­—ä½“æ ·å¼ï¼ˆåªæœ‰åŠ ç²—å’Œæ–œä½“ï¼‰ android:fontFamily è®¾ç½®æ–‡å­—çš„å­—ä½“ app:drawableStartCompat è®¾ç½®æ–‡å­—å·¦è¾¹çš„å›¾ç‰‡ï¼ˆç±»ä¼¼çš„å¯ä»¥æŠŠ Start æ¢æˆ Topã€Bottomã€Endï¼‰ å¦‚æœè¦è®¾ç½®ä¸€ä¸ªå›¾ç‰‡åœ¨ TextView æ—è¾¹ï¼Œå°½é‡ä½¿ç”¨ app:drawableStartCompat å±æ€§ï¼Œè€Œä¸æ˜¯å†™ä¸€ä¸ª ImageView åœ¨æ—è¾¹ Buttonä¸€ä¸ªä¸ç”¨æˆ·è¿›è¡Œäº¤äº’çš„æŒ‰é’®ï¼ˆæ³¨æ„ï¼šå¹¶ä¸æ˜¯åªæœ‰ Button å¯ä»¥ç‚¹å‡»ï¼Œæ‰€æœ‰çš„ View éƒ½å¯ä»¥è®¾ç½®ç‚¹å‡»ç›‘å¬ï¼‰ è‡ªèº«å±æ€§ ä½œç”¨ æ‰€æœ‰ TestView çš„å±æ€§ å› ä¸º Button æ˜¯ç›´æ¥ç»§æ‰¿äº TestView çš„ï¼Œæ‰€ä»¥æ‹¥æœ‰æ‰€æœ‰ TestView çš„å±æ€§ EditTextä¸€ä¸ªä¸ç”¨æˆ·è¿›è¡Œäº¤äº’çš„è¾“å…¥æ§ä»¶ è‡ªèº«å±æ€§ ä½œç”¨ æ‰€æœ‰ TestView çš„å±æ€§ å› ä¸º EditText ä¹Ÿæ˜¯ç›´æ¥ç»§æ‰¿äº TestView çš„ï¼Œæ‰€æœ‰æ‹¥æœ‰æ‰€æœ‰ TestView çš„å±æ€§ android:hint è®¾ç½®æç¤ºæ–‡å­— android:textColorHint è®¾ç½®æç¤ºæ–‡å­—é¢œè‰² android:inputType è®¾ç½®è¾“å…¥çš„ç±»å‹ android:digits è®¾ç½®å€¼æ¥å—æŒ‡å®šçš„æ–‡æœ¬å†…å®¹ android:lines è®¾ç½®æ˜¾ç¤ºè¡Œæ•° android:maxLines è®¾ç½®æœ€å¤§æ˜¾ç¤ºè¡Œæ•° ï¼ˆç®€å•æä¸€å¥ï¼šå…¶å®åé¢å‡ ä¸ªå±æ€§ä¹Ÿä¸æ˜¯ EditText ç‹¬æœ‰çš„ï¼‰ ImageViewä¸€ä¸ªæ˜¾ç¤ºå›¾ç‰‡çš„æ§ä»¶ å±æ€§ ä½œç”¨ android:src è®¾ç½®ï¼ˆå‰æ™¯ï¼‰å›¾ç‰‡ android:scaleType è®¾ç½®å½“å›¾ç‰‡ä¸æ§ä»¶å¤§å°ä¸ä¸€è‡´æ—¶ç¼©æ”¾æ¨¡å¼ å¦‚ä½•æ·»åŠ å›¾ç‰‡ï¼š æ™®é€šå›¾ç‰‡ ç›´æ¥å°†å›¾ç‰‡æ”¾åˆ°resdrawableç›®å½•ä¸‹å³å¯ çŸ¢é‡å›¾ æ¨èä¸€ä¸ªçŸ¢é‡å›¾ç½‘ç«™ï¼šé˜¿é‡Œå·´å·´çŸ¢é‡å›¾æ ‡åº“ï¼Œé‡Œé¢æœ‰å¾ˆå¤šå¥½çœ‹çš„å›¾æ ‡ï¼Œè€Œä¸”æ˜¯å…è´¹çš„ã€‚ å…ˆä¸‹è½½SVGå›¾ç‰‡ï¼Œä¿å­˜åˆ°ä½ è‡ªå·±èƒ½æ‰¾åˆ°çš„åœ°æ–¹ åœ¨resæ–‡ä»¶å¤¹ä¸‹æ–°å»ºä¸€ä¸ªVector Asset é€‰æ‹©åŠ è½½æœ¬åœ°èµ„æºï¼Œæ‰¾åˆ°ä½ çš„å›¾ç‰‡ è°ƒæ•´ä¸€äº›å‚æ•° å®Œæˆ è¡¥å……ä¹¦æ²¡æœ‰çš„å†…å®¹scaleTypeæ¨èåšå®¢ï¼šscaleType çš„ä½¿ç”¨ ä¸€èˆ¬ä½¿ç”¨ centeInside æ¨¡å¼ï¼Œå½“ size å¤§äº ImageView çš„å›¾ç‰‡è¿›è¡Œç­‰æ¯”ä¾‹ç¼©å°ï¼Œå°äº ImageView çš„å›¾ç‰‡ä¸å˜ï¼Œç›´æ¥å±…ä¸­æ˜¾ç¤ºã€‚ï¼ˆå½“ä¸å†™è¯¥å±æ€§æ—¶ï¼Œé»˜è®¤æ˜¯ fitCenter æ„æ€æ˜¯å½“ size å¤§äº ImageView çš„å›¾ç‰‡è¿›è¡Œç­‰æ¯”ä¾‹ç¼©å°ï¼Œå°äº ImageView çš„å›¾ç‰‡è¿›è¡Œç­‰æ¯”ä¾‹æ”¾å¤§ï¼Œç›´æ¥å±…ä¸­æ˜¾ç¤ºï¼‰ ShapeableImageViewå¦‚æœæƒ³å®ç°åœ†å¤´åƒæˆ–è€…å…¶ä»–æ ·å¼çš„å¤´åƒï¼Œå¯ä»¥è¯•è¯•è¿™ä¸ªæ§ä»¶ æ¨èåšå®¢ï¼šShapeableImageView çš„ä½¿ç”¨ å¸¸ç”¨å±æ€§android:layout_margin ä¸ paddingåˆå­¦è€…å¾€å¾€ä¼šæä¸æ‡‚è¿™ä¸¤ä¸ªçš„å«ä¹‰ å…¶ä¸­ layout_margin æ˜¯ä»¥çˆ¶å¸ƒå±€ä¸ºå‚è€ƒç³»ï¼Œè®¾ç½®å¤–éƒ¨è¾¹è· **padding **æ˜¯ä»¥è‡ªèº«ä¸ºå‚è€ƒç³»è®¾ç½®è®¾ç½®å†…éƒ¨å­ View æˆ–è€…æ–‡æœ¬ç­‰è¾¹è· android:backgroundè®¾ç½®èƒŒæ™¯ï¼ˆä¸ ImageView çš„ android:src ä¸åŒï¼Œsrc æ˜¯è®¾ç½®å‰æ™¯ï¼Œå¯ä»¥é€‰æ‹©ç¼©æ”¾æ¨¡å¼ï¼Œè€Œ background æ˜¯è®¾ç½®èƒŒæ™¯ï¼Œæ˜¯ç›´æ¥å¼ºè¡Œæ‹‰ä¼¸æˆ–è€…å‹ç¼©å›¾ç‰‡ï¼‰ Materialç»„ä»¶åº“Material Design æ˜¯ç”±Googleå¼€å‘è®¾è®¡ï¼Œæ‰©å±•äºGoogleå³æ—¶çš„â€œå¡ç‰‡â€è®¾è®¡ï¼Œæè´¨è®¾è®¡åŸºäºç½‘æ ¼çš„å¸ƒå±€ã€å“åº”åŠ¨ç”»ä¸è¿‡æ¸¡ã€å¡«å……ã€æ·±åº¦æ•ˆæœï¼ˆå¦‚å…‰çº¿å’Œé˜´å½±ï¼‰ã€‚ Materialå®˜ç½‘ Githubåœ°å€ å¼ºçƒˆå»ºè®®ä½ ä»¬ä¸‹è½½ä¸‹æ¥ï¼Œé‡Œé¢æœ‰å¾ˆå¤šå¥½çœ‹çš„æ§ä»¶ï¼Œç›´æ¥æ‹¿æ¥ç”¨ã€‚ ViewGroup ViewGroup è¢«ç¿»è¯‘æˆå®¹å™¨ï¼Œä»–çš„ä½œç”¨å°±æ˜¯ç”¨æ¥è£… TextViewã€Button è¿™äº›æ§ä»¶çš„ åŸºç¡€ ViewGroupä»¥ä¸‹ç®€å•è®²è§£ä½ ä»¬ç°é˜¶æ®µä¼šç”¨åˆ°çš„ ViewGroupï¼Œç”±äºã€Šç¬¬ä¸€è¡Œä»£ç ã€‹ä¸­æœ‰å…³äºè¿™äº›çš„æ¼”ç¤ºå’Œè®²è§£ï¼Œæ‰€ä»¥è¿™æ¬¡è¯¾æˆ‘æ›´å¤šçš„æ˜¯è¿›è¡Œå®è·µæ“ä½œ LinearLayouté¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P94é¡µ è¯¥å¸ƒå±€åœ¨å…¥é—¨é˜¶æ®µæœ€å¸¸ç”¨ è‡ªèº«å±æ€§ ä½œç”¨ android:orientation è®¾ç½®æ’åˆ—æ–¹å‘ å­æ§ä»¶å±æ€§ ä½œç”¨ android:layout_gravity è®¾ç½®å­æ§ä»¶åœ¨çˆ¶æ§ä»¶ä¸­çš„ä½ç½® android:layout_weight è®¾ç½®å­æ§ä»¶åœ¨çˆ¶æ§ä»¶ä¸­çš„æ¯”é‡ å­æ§ä»¶å±æ€§ï¼Ÿçˆ¶å¸ƒå±€å¯ä»¥é¢å¤–æ·»åŠ å­æ§ä»¶çš„å±æ€§çš„ï¼Œå…¶ä¸­æœ‰ä¸ªæ˜æ˜¾çš„ç‰¹ç‚¹å°±æ˜¯ï¼Œå±æ€§éƒ½ä»¥ layout_ å¼€å¤´. RelativeLayout é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P100é¡µ è¯¥å¸ƒå±€ä¸å¸¸ä½¿ç”¨ï¼Œè·³è¿‡ FramLayouté¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P103é¡µ è¯¥å¸ƒå±€åœ¨å…¥é—¨é˜¶æ®µä¸€èˆ¬ä¸ç”¨ï¼Œè·³è¿‡ï¼ˆä¸€èˆ¬åœ¨è‡ªå®šä¹‰ View ä¸­ç”¨çš„å¤šï¼Œé€šè¿‡ç»§æ‰¿å®ƒæ¥å®ç°è‡ªå·±çš„æ§ä»¶ï¼‰ CardViewé¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P431é¡µ è¯¥å¸ƒå±€åæœŸå¾ˆå¸¸ç”¨ï¼Œè¿™é‡Œåšä¸€äº›è¡¥å…… è‡ªèº«å±æ€§ ä½œç”¨ app:cardCornerRadius è®¾ç½®åœ†è§’ app:elevation è®¾ç½®é˜´å½±åšåº¦ï¼ˆä¹ŸæŒ‡ Z è½´é«˜åº¦ï¼‰ app:cardBackgroundColor è®¾ç½®èƒŒæ™¯é¢œè‰²ï¼ˆæ³¨æ„ï¼šè¯¥æ§ä»¶ä½¿ç”¨ android:background æ¥æ”¹å˜èƒŒæ™¯é¢œè‰²æ˜¯æ— æ•ˆçš„ï¼Œéœ€è¦æ¢æˆå·¦è¾¹è¿™ä¸ªå±æ€§ï¼‰ app:cardPreventCornerOverlap æ˜¾ç¤ºå®Œæ•´é˜´å½±ï¼ˆå¦‚æœä½ çš„é˜´å½±åšåº¦è¾ƒåšï¼Œä½ ä¼šå‘ç°ä½ çš„é˜´å½±åªæ˜¾ç¤ºäº†éƒ¨åˆ†ï¼Œä½¿ç”¨è¯¥å±æ€§å¯ä»¥å°†é˜´å½±æ˜¾ç¤ºå®Œæ•´ï¼‰ app:contentPadding è®¾ç½®å†…å®¹çš„ poaddingï¼ˆé—´è·ï¼‰ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜æœ‰app:contentPaddingLeftRightTopBotom ç”¨äºå¤æ‚å¸ƒå±€æ—¶çš„ ConstraintLayoutè¯¥å¸ƒå±€ä¸ºæœ€å¸¸ç”¨å¸ƒå±€ï¼Œè€Œä¸”ç°åœ¨ASé»˜è®¤çš„å¸ƒå±€å°±æ˜¯ConstraintLayoutå¸ƒå±€ï¼Œåªéœ€è¦ç®€å•çš„ä¸€æ‹–ä¸€æ‹‰ï¼Œå°±èƒ½å®ç°æ¯” LinearLayoutã€RelativeLayout æ›´å¼ºå¤§çš„æ•ˆæœã€‚ è¿™é‡Œç›´æ¥æ¨èçœ‹åšå®¢å†…å®¹ï¼šçº¦æŸå¸ƒå±€ ä¹Ÿè®¸ä½ ä»¬è§‰å¾—å†™è¿™äº›å¥½éº»çƒ¦ï¼Œå…¶å®ï¼Œè¿™äº›å¤šç”¨å³ä¾¿å°±è®°ä½äº†ï¼Œè¿˜æœ‰å°±æ˜¯æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ XML ä¸­çš„ Design çª—å£ç”¨é¼ æ ‡æ¥æ‹–åŠ¨ï¼Œå…·ä½“çš„ä½¿ç”¨ä¼šåœ¨è¯¾ä¸Šæ¼”ç¤º å¸¸ç”¨å±æ€§android:gravity éƒ¨åˆ† ViewGroup æ‹¥æœ‰è¯¥å±æ€§ï¼Œç”¨äºè®¾ç½®å­æ§ä»¶çš„é‡å¿ƒ æ§ä»¶è¿™ä¹ˆå¤šçš„å±æ€§æˆ‘è¯¥æ€ä¹ˆè®°ï¼Ÿ å…¶å®ä½ æ ¹æœ¬ä¸ç”¨è®°ä½ï¼Œç›´æ¥ç…§ä¹¦æŠ„å°±æ˜¯äº†ï¼Œåé¢ä½ æƒ³æ‰¾æŸä¸ªå±æ€§ï¼Œæ¨èå…ˆå» Android å®˜ç½‘ï¼ˆç‚¹æˆ‘è¿›å®˜ç½‘ï¼Œå°±æ˜¯ä½ ä¸‹ AS çš„åœ°æ–¹ï¼‰æ‰¾æ‰¾ï¼Œå†å»ç™¾åº¦çœ‹ä»–çš„ç”¨æ³•ï¼Œåªè¦ä½ ç”¨å¾—å¤šäº†ï¼Œè‡ªç„¶è€Œç„¶å°±è®°ä½è¿™äº›å±æ€§äº† å…¶ä»– å‘½åè§„èŒƒid å‘½åè§„èŒƒ å…·ä½“å¯å‚è€ƒç¾¤é‡Œçš„ã€Šé˜¿é‡Œå·´å·´Androidå¼€å‘æ‰‹å†Œã€‹ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰å¦‚ä¸‹å‘½åè§„èŒƒï¼š ã€æ¨¡å—åã€‘_ã€æ§ä»¶ã€‘_ã€ç•Œé¢ä½ç½®ã€‘_ã€ä½œç”¨ã€‘ æ¨¡å—åï¼šç›®å‰ä½ ä»¬è¿˜è®¾è®¡ä¸åˆ°æ¨¡å—ç›¸å…³ï¼Œå¯ä»¥ä¸ç”¨å†™ æ§ä»¶åï¼šå¸¸è§çš„æ§ä»¶å¯é‡‡ç”¨é¦–å­—æ¯ç¼©å†™çš„å½¢å¼ï¼Œè‡ªå®šä¹‰æ§ä»¶å’Œä¸å¸¸ç”¨çš„å»ºè®®å…¨å†™ ç•Œé¢ä½ç½®ï¼šç®€å•çš„æè¿°æ˜¯å“ªä¸ªç•Œé¢ï¼Œå¦‚ä¸‹å›¾çš„ stamp_detail è¡¨ç¤ºé‚®ç¥¨è¯¦ç»†ç•Œé¢ï¼ˆå¯ä»¥åŠ ä¸Š activityã€fragmentã€item ç­‰å­—çœ¼ç”¨äºè¡¨ç¤ºæ§ä»¶æ‰€åœ¨çš„å®¹å™¨ï¼‰ ä½œç”¨ï¼šå¦‚æœå½“å‰ç•Œé¢ç›¸åŒæ§ä»¶è¿‡å¤šï¼Œå¼ºçƒˆå»ºè®®åŠ ä¸Šä½œç”¨ å¤§è‡´ä»¥ä¸Šé¢è¿™æ ·æ¥å†™ idï¼Œè¿™æ ·æ›´åˆ©äºå¿«é€ŸæŸ¥æ‰¾ï¼Œä¹Ÿä¼šè®©ä¹‹åçš„å­¦å¼Ÿä¸ä¼šå¯¹ä½ çš„ä»£ç ç•™ä¸‹ä»€ä¹ˆå°è±¡ : ) æ§ä»¶å¯¹è±¡å‘½åè§„èŒƒ è™½ç„¶æ˜¯ kt å†™å¾—ï¼Œä½†å„ä½åº”è¯¥èƒ½çœ‹æ‡‚ ã€æ§ä»¶ç¼©å†™ã€‘+ã€ä½œç”¨ã€‘ è¿™é‡Œæä¸€å¥ï¼Œä¸ºä»€ä¹ˆä»¥ m å¼€å¤´ï¼Œå› ä¸º Android å®˜æ–¹æ¨èç±»ä¸­çš„æˆå‘˜å˜é‡ä»¥ m å¼€å¤´ï¼Œä½ å‡ ä¹å¯ä»¥åœ¨ Android å®˜æ–¹æºç ä¸­éƒ½èƒ½å‘ç°è¿™ç§å†™æ³•ï¼Œå»ºè®®éµå®ˆå®˜æ–¹è§„èŒƒ ç°æ“ä¸€ä¸ªç™»å½•ç•Œé¢ å…‰å¬è¿™äº›ä¼°è®¡å¾ˆæ— èŠï¼Œæ¥ä¸‹æ¥æˆ‘å°†ç°æ“ä¸€ä¸ªç™»é™†ç•Œé¢ï¼Œå†™ç™»å½•ç•Œé¢æ˜¯è¿™æ¬¡ä½œä¸šä¸­çš„ Lv2ï¼Œå„ä½å¯ä»¥ç”¨å¿ƒå¬ä¸€ä¸‹ å¸ƒå±€ä»£ç ?xml version=1.0 encoding=utf-8?androidx.constraintlayout.widget.ConstraintLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:app=http://schemas.android.com/apk/res-auto xmlns:tools=http://schemas.android.com/tools android:layout_width=match_parent android:layout_height=match_parent tools:context=.MainActivity ImageView android:id=@+id/img_main_head android:layout_width=100dp android:layout_height=100dp android:layout_marginTop=128dp android:src=@drawable/cqupt app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toTopOf=parent / EditText android:id=@+id/et_main_username android:layout_width=300dp android:layout_height=wrap_content android:layout_marginTop=64dp android:drawableStart=@drawable/ic_baseline_account_box_24 android:hint=è´¦å· android:inputType=number android:lines=1 app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/img_main_head / EditText android:id=@+id/et_main_password android:layout_width=300dp android:layout_height=wrap_content android:layout_marginTop=16dp android:digits=0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ?!=+-_., android:drawableStart=@drawable/ic_baseline_vpn_key_24 android:hint=å¯†ç  android:inputType=textPassword android:lines=1 app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/et_main_username / Button android:id=@+id/btn_main_login android:layout_width=wrap_content android:layout_height=wrap_content android:layout_marginTop=64dp android:text=ç™»å½• app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/et_main_password //androidx.constraintlayout.widget.ConstraintLayout Activityä»£ç public class LoginActivity extends AppCompatActivity private ImageView mImgHead; private EditText mEtUsername; private EditText mEtPassword; private Button mBtnLogin; @Override protected void onCreate(Bundle savedInstanceState) super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); initView(); initLogin(); /** * å†™ä¸€ä¸ªæ–¹æ³•ä¸“é—¨ç”¨äºåˆå§‹åŒ– View */ private void initView() mImgHead = findViewById(R.id.img_main_head); mEtUsername = findViewById(R.id.et_main_username); mEtPassword = findViewById(R.id.et_main_password); mBtnLogin = findViewById(R.id.btn_main_login); /** * ä¸“é—¨ç”¨äºç™»å½•çš„æ–¹æ³• */ private void initLogin() mBtnLogin.setOnClickListener(new View.OnClickListener() @Override public void onClick(View v) login(); ); /** * æ‰§è¡Œç™»å½•æ“ä½œ */ private void login() String username = mEtUsername.getText().toString(); String password = mEtPassword.getText().toString(); if (username.equals(123456) password.equals(123456)) loginSuccess(username, password); else loginFailure(); /** * ç™»å½•æˆåŠŸçš„æ–¹æ³• */ private void loginSuccess(String username, String password) Toast.makeText(this, ç™»é™†æˆåŠŸ!, Toast.LENGTH_SHORT).show(); MainActivity2.startActivity(this, username, password); /** * ç™»å½•å¤±è´¥çš„æ–¹æ³• */ private void loginFailure() Toast.makeText(this, è´¦å·æˆ–è€…å¯†ç å¥½åƒè¾“é”™äº† :(, Toast.LENGTH_SHORT).show(); private long mExitTime = 0L; /** * ä»¥ä¸‹ä¸ºè¿æŒ‰ä¸¤æ¬¡æ‰èƒ½é€€å‡º */ @Override public boolean onKeyDown(int keyCode, KeyEvent event) if (keyCode == KeyEvent.KEYCODE_BACK) /* * å½“å½“å‰æ—¶é—´å¤§äºä¸Šæ¬¡æŒ‰è¿”å›é”®çš„æ—¶é—´ 2 ç§’æ—¶ */ if (System.currentTimeMillis() - mExitTime 2000) Toast.makeText(this, å†æŒ‰ä¸€æ¬¡é€€å‡ºç¨‹åº, Toast.LENGTH_SHORT).show(); mExitTime = System.currentTimeMillis(); return false; return super.onKeyDown(keyCode, event); å†å†™ä¸€ä¸ª Activityè¿™å°±å†™å®Œäº†ï¼Ÿè¿™ä¹Ÿå¤ªç®€å•äº†å§ï¼Œç®€ç›´æœ‰æ‰‹å°±è¡Œã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ç»™è¿™ä¸ªç•Œé¢åŠ ä¸Šç™»å½•åçš„è·³è½¬ intent è·³è½¬é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P41 ~ P43 åªéœ€è¦ä½¿ç”¨æ˜¾ç¤º Intent å°±å¯ä»¥äº†ï¼Œå°±ä¸¤è¡Œä»£ç  Intent intent = new Intent(this, MainActivity.class);startActivity(intent); å¯¹äº Intent çš„æ­£ç¡®å†™æ³•ï¼ˆä»¥ä¸‹ä¸ºæ‰©å±•å†…å®¹ï¼Œå¬ä¸æ‡‚æ²¡äº‹ï¼‰ å¦‚æœæˆ‘ä»¬è¦ä¼ å…¥ä¸€äº›æ•°æ®ç»™ ContentActivity æ—¶ï¼Œä¸€èˆ¬æˆ‘ä»¬ä¼šåœ¨ MainActivity ç›´æ¥è¿™æ ·å†™ Intent intent = new Intent(this, ContentActivity.class);intent.putExtra(username, username);intent.putExtra(password, password);startActivity(intent); è¿™æ ·å†™ç¡®å®å¾ˆæ–¹ä¾¿ï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ ä½†åœ¨ä¹‹åçš„å¼€å‘ä¸­ï¼Œæˆ‘ä»¬æ›´æ¨èå°†å¯åŠ¨äº‹ä»¶äº¤ç»™è¦å¯åŠ¨çš„ç±»æ¥å¤„ç†ï¼Œè¿™æ ·å¯ä»¥å®ç°ç±»ä¸ç±»ä¹‹é—´çš„è§£è€¦åˆ åº”è¯¥åœ¨ MainActivity2 ä¸­å†™ä¸€ä¸ª static çš„æ–¹æ³•ç”¨äºå¯åŠ¨è‡ªå·±ï¼Œè®©å®ƒæ¥å†³å®šä½ è¯¥ä¼ å…¥ä»€ä¹ˆæ•°æ®æ‰èƒ½å¯åŠ¨å®ƒ public class MainActivity2 extends AppCompatActivity private static final String INTENT_USER_NAME = username; // intent ä¸­çš„æ•°æ®æ ‡è®° private static final String INTENT_PASSWORD = password; // intent ä¸­çš„æ•°æ®æ ‡è®° /** * å†™ä¸€ä¸ª static æ–¹æ³•ï¼Œè®©å®ƒæ¥å†³å®šè¯¥ä¼ å…¥é‚£äº›æ•°æ® */ public static void startActivity(Context context, String username, String password) Intent intent = new Intent(context, MainActivity2.class); intent.putExtra(INTENT_USER_NAME, username); intent.putExtra(INTENT_PASSWORD, password); context.startActivity(intent); @Override protected void onCreate(Bundle savedInstanceState) super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Intent intent = getIntent(); String mUserName = intent.getStringExtra(INTENT_USER_NAME); String mPassword = intent.getStringExtra(INTENT_PASSWORD); é‚£ä¹ˆåœ¨ LoginActivityä¸­å¯ä»¥ç›´æ¥ä¸€è¡Œä»£ç å¯åŠ¨ MainActivity2 MainActivity2.startActivity(this, username, password); è¿™æ ·çš„å†™æ³•åœ¨å†™å¤§é¡¹ç›®æ—¶æ˜¯å¿…é¡»éµå®ˆçš„ï¼Œå†™åœ¨è¿™é‡Œåªæ˜¯ä¸ºäº†è®©ä½ ä»¬æå‰çŸ¥é“æœ‰è¿™ä¸ªè§„èŒƒ è¡¥å……å¯åŠ¨ç•Œé¢æ³¨å†Œæ–‡ä»¶æ”¹é»˜è®¤å¯åŠ¨ é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P35 æœ€åº•éƒ¨ intent-filter\taction android:name=android.intent.action.MAIN /category android:name=android.intent.category.LAUNCHER //intent-filter ä¸Šé¢è¿™ä¸€è¡Œä»£ç å°±æ˜¯è®¾ç½®å¯åŠ¨ Activity çš„ åªéœ€è¦æŠŠå®ƒæ”¹åˆ°ä½ æƒ³è®¾ç½®çš„ Activity é‡Œï¼Œåœ¨Android12ä¸­ï¼Œé»˜è®¤å¯åŠ¨activityå¿…éœ€è¦è®¾ç½®android:exported=true Activity çš„ finish() æ–¹æ³•é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P40 æœ€åº•éƒ¨ è°ƒç”¨è¯¥æ–¹æ³•ä¼šç›´æ¥é”€æ¯å½“å‰ Activityï¼Œå¹¶ç§»å‡º Activity æ ˆï¼ˆActivity æ ˆçš„æ¦‚å¿µå¯ä»¥çœ‹ä¹¦ P53ï¼‰ æ‰©å±•å†…å®¹Activity æ˜¯ä»€ä¹ˆï¼Ÿç›¸ä¿¡åœ¨å†™äº†ä¸Šé¢æ‡µæ‡µæ‡‚æ‡‚çš„ä»£ç åï¼Œä½ ä¹Ÿå¯¹ Activity æœ‰äº†ä¸€ä¸ªåˆæ­¥çš„è®¤è¯†ã€‚ å¦‚æœè¯´ XML å¸ƒå±€æ˜¯åº”ç”¨çš„å¤–è¡¨ï¼Œé‚£ä¹ˆ Activity å°±æ˜¯åº”ç”¨çš„å†…æ ¸ï¼Œç”¨äºæ§åˆ¶ XML(å¤–è¡¨) å®æ—¶å˜åŒ–ï¼Œè¾¾åˆ°ä¸ç”¨æˆ·äº¤æµçš„ç›®çš„ å…¶ä¸­ä¸€ä¸ª Activity æŒç®¡äº†ä¸€ä¸ªå¯¹åº”çš„ XML å¸ƒå±€ï¼ŒXML å¸ƒå±€ä¸­çš„æ§ä»¶ï¼Œéƒ½å¯ä»¥ä½¿ç”¨ findViewById() è¿™ä¸ªæ–¹æ³•è½¬æ¢æˆå¯¹åº”çš„ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶å Activity å°±å¯ä»¥ç›´æ¥è°ƒç”¨è¿™äº›å¯¹è±¡è‡ªå¸¦çš„æ–¹æ³•ç”¨äºè®¾ç½®ä¸€äº›å±æ€§ Activity å¯åŠ¨æ¨¡å¼é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P63 è¿™ä¸œè¥¿å¹³æ—¶ä¸ä¼šç»å¸¸ç”¨åˆ°ï¼Œä½¿ç”¨ä¹Ÿå¾ˆç®€å•ï¼Œä½ ä»¬ä¸‹å»çœ‹ä¸€ä¸‹ä¹¦å°±èƒ½ç†è§£äº†ã€‚ä¸»è¦ç”¨äºä½¿ç”¨è¿”å›é”®é€€å‡ºå½“å‰ Activity æˆ–è€… Activity äº’ç›¸å¯åŠ¨æ—¶ä¼šç”¨åˆ° Fragment é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P142 Fragment å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå°å‹çš„ Activityï¼Œå®ƒä¹Ÿå¯ä»¥å‘ Activity ä¸€æ ·ï¼Œä¸ XML è§†å›¾è¿›è¡Œä¸€å¯¹ä¸€ç»‘å®šï¼Œä½†å®ƒå¿…é¡»å¯„ç”Ÿäºä¸€ä¸ª Activity ä¸­ï¼Œä¸èƒ½ç‹¬ç«‹å­˜åœ¨ ä¸è®²å†…å®¹ è¯¥éƒ¨åˆ†å†…å®¹å¯¹äºä½ ä»¬ç›®å‰é˜¶æ®µéš¾ä»¥ç†è§£ï¼Œæ•…å†™åœ¨è¿™é‡Œï¼Œç°åœ¨åªä½œäº†è§£å³å¯ï¼Œä¹‹åä¼šå†æ¥è¯¦ç»†è®²è§£ Activity ç”Ÿå‘½å‘¨æœŸ é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P53é¡µ ä¸‹å­¦æœŸä¼šè¿›è¡Œæ›´æ·±å…¥çš„è®²è§£ï¼Œå†åŠ ä¸Šç›®å‰ä½ ä»¬æ¶‰åŠä¸åˆ°è¿™ä¸ªï¼Œæ‰€ä»¥å°±ä¸å†™è¿™ä¸ªäº† Fragment ç”Ÿå‘½å‘¨æœŸ é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P151 ä¸ Activity ç”Ÿå‘½å‘¨æœŸç±»ä¼¼ï¼Œè¿™èŠ‚è¯¾ä¹Ÿä¸ä¼šè®²è§£è¯¥å†…å®¹ FragmentManger é¡µæ•°ï¼šã€Šç¬¬ä¸€è¡Œä»£ç ã€‹P147 Activity ä¸­ Fragment çš„ç®¡ç†è€… è¡¥å……é—®é¢˜è®¾ç½®å­—ä½“å¤§å° ASé»˜è®¤çš„å­—ä½“æœ‰ç‚¹å°ï¼Œæˆ‘ä»¬è®¾ç½®ä¸€ä¸‹ çª—å£å­—å·è®¾ç½®File - Settings - Appearance æ³¨æ„ï¼šè¿™ä¸ªåªèƒ½è®¾ç½®é™¤ä»£ç å¤–çš„å­—ä½“å¤§å°ï¼Œä¹Ÿå°±æ˜¯çª—å£å­—ä½“å¤§å° ä»£ç å­—ä½“è®¾ç½®File - Settings - Editor - Font è¿™é‡Œæ‰æ˜¯è®¾ç½®ä»£ç å­—ä½“å¤§å°çš„åœ°æ–¹ Ctrl + æ»‘è½® è®¾ç½®ä»£ç å­—å·File - Settings - Editor - General å¼€å¯ Ctrl + æ»‘è½®è®¾ç½®å­—ä½“å¤§å°å¾ˆæœ‰ç”¨ å¿«æ·é”®è®¾ç½® ç›¸ä¿¡åœ¨å†™ java ä¸­ç›´æ¥è¾“ sout è€Œæ„Ÿåˆ°ååˆ†æ–¹ä¾¿ï¼Œå…¶å®è¿™äº›éƒ½æ˜¯å¯ä»¥è‡ªå·±å»è®¾ç½®çš„ ä¸‹é¢ç»™å‡ºä¸€ä¸ªå¯ä»¥å¿«æ·æ‰“å‡º Log.d çš„å¿«æ·é”®çš„è®¾ç½®æ–¹å¼ æ‰“å¼€è®¾ç½® åŸºæœ¬è®¾ç½® android.util.Log.d(TAG,($class$:$line$)--);// TAG: æ¢æˆä½ è‡ªå·±æƒ³è®¾ç½®çš„ tagï¼ˆç”¨äºè¿‡æ»¤ Logï¼Œå¿«é€Ÿæ‰¾åˆ°ï¼‰// $class$ã€$line$: å›ºå®šå†™æ³• è®¾ç½®å±æ€§ è®¾ç½®è¯­è¨€ OKï¼Œæ¥ä¸‹æ¥ä½ å¯ä»¥åœ¨ä»£ç ä¸­ç›´æ¥è¾“å…¥ â€œldâ€ ç„¶åå›è½¦ï¼Œå®ç° sout ä¸€æ ·çš„æ•ˆæœ ç»è¿‡äº†è¿™ä¸ªæ•™ç¨‹åï¼Œç›¸ä¿¡ä½ ä¹Ÿå¯ä»¥è®¾ç½®å…¶ä»–å¿«æ·é”®äº†. æ¨èæ’ä»¶ è£…ä¸Šä¸€äº›æ’ä»¶å¯ä»¥å¾ˆå¤§éƒ¨åˆ†ä¸Šæé«˜æˆ‘ä»¬å·¥ä½œæ•ˆç‡ï¼Œåœ¨è¿™é‡Œåˆ†äº«ç»™å¤§å®¶å‡ ä¸ªæ’ä»¶ æ’ä»¶åœ¨è¿™é‡Œä¸‹è½½ï¼š Translation ä¸€ä¸ªå¾ˆå¥½ç”¨çš„ç¿»è¯‘æ’ä»¶ï¼Œå¯¹äºè‹±æ–‡æ³¨é‡Šæ¥è¯´å¯ä»¥ç›´æ¥ç¿»è¯‘æˆä¸­æ–‡ ä½¿ç”¨æ–¹å¼ï¼šé€‰ä¸­è‹±æ–‡åç›´æ¥ Ctrl + Shift + Yï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç¿»è¯‘æ–‡æ¡£ æ³¨ï¼šè°·æ­Œç¿»è¯‘åœæ­¢ä¸­å›½è®¿é—®ï¼Œè¯¥æœåŠ¡éœ€è¦æ¢¯å­ï¼Œæˆ–è€…ä½¿ç”¨æ›¿ä»–ç¿»è¯‘å¼•æ“ã€‚ å¦‚æœæŒ‚äº†æ¢¯å­è¿˜æ˜¾ç¤ºè¿™ä¸ªå°±éœ€è¦è®¾ç½®ä»£ç† è¿™é‡Œå¯ä»¥æ›¿æ¢å…¶ä»–æœç´¢å¼•æ“ Rainbow Brackets æ‹¬å·æ€»æ˜¯ç™½è‰²ï¼Œå¤ªéš¾æ‰¾åˆ°å¯¹åº”ï¼Ÿè¯•è¯•è¿™æ¬¾æ’ä»¶ï¼Œè®©ä½ ä»£ç ä¸­çš„æ‹¬å·å……æ»¡è‰²å½©ï¼ å¦‚ä½•æ‰“åŒ… å½“æ‰‹æœºè£…ä¸Šäº†ä½ è‡ªå·±çš„Appï¼Œä½ ä¹Ÿæƒ³åˆ†äº«ç»™å…¶ä»–å°ä¼™ä¼´ä¸€èµ·ä½¿ç”¨ï¼Œå¯æ˜¯å½“ä½ å‘ç°é€šè¿‡qqå‘é€ç»™åˆ«äººçš„æ—¶å€™ï¼Œä»–ä»¬å®‰è£…ä¸äº†ï¼Œå› ä¸ºæˆ‘ä»¬æ‰‹æœºæ˜¯é€šè¿‡ASç›´æ¥è£…çš„ï¼Œä¸æ˜¯æ­£å¼çš„apkã€‚ æ‰“å¼€Build - Generate Signed Bundle APKâ€¦ é€‰æ‹©apkï¼Œç‚¹å‡»next åˆ›å»ºç­¾åæ–‡ä»¶ ç”Ÿæˆ apk éœ€è¦ç­¾åæ–‡ä»¶ï¼Œè¿™ä¸ªç­¾åæ–‡ä»¶ä¸»è¦æ˜¯ç”¨äºæ£€æµ‹å½“å‰ apk æ˜¯å¦å·²ç»è¢«ä¿®æ”¹ã€‚æ¯”å¦‚ä½ é€šè¿‡åç¼–è¯‘ä¿®æ”¹äº†æˆ‘çš„ apkï¼Œé‚£ä¹ˆç­¾åæ–‡ä»¶å°±ä¼šè¢«ç ´åï¼Œå…¶ä»–äººå°±å¯ä»¥é€šè¿‡ç­¾åæ–‡ä»¶æ¥åˆ¤æ–­æ˜¯å¦è¢«ä¿®æ”¹ é€‰æ‹©relsaseåŒ… æŸ¥çœ‹apk ASå½»åº•å¸è½½ æ—¶é—´é•¿äº†ASä¼šå‡ºç°ä¸€äº›å¥‡æ€ªçš„é—®é¢˜ï¼Œæˆ‘ä»¬å°±éœ€è¦å½»åº•å¸è½½ASäº† åœ¨è®¾ç½®é‡Œå¸è½½AS æ‰“å¼€ä¸‹é¢è¿™ä¸ªè·¯å¾„ï¼Œåˆ é™¤æ‰€æœ‰ä¸ AS æœ‰å…³çš„å³å¯ C:\\Users\\WhiteNight\\AppData\\Roaming\\Google æ³¨1ï¼šå›¾ä¸­çš„ â€œWhiteNightâ€ æ˜¯ç”µè„‘çš„ç”¨æˆ·åï¼Œæ‰“å¼€ä½ è‡ªå·±çš„ç”¨æˆ·ç›®å½• æ³¨2ï¼šå…¶ä¸­ â€œAppDataâ€ ä¸ºéšè—æ–‡ä»¶å¤¹ï¼Œè‡ªå·±æ‰“å¼€æ˜¾ç¤ºéšè—æ–‡ä»¶å¤¹å³å¯æ‰¾åˆ° å¦‚æœä½ æƒ³å¼ƒå‘ Android äº† ï¼Œå°±å¯ä»¥æŠŠ gradle åˆ äº†ğŸ¥€ æ›´æ”¹gradleè·¯å¾„ ASä¸‹è½½çš„gradleè·¯å¾„æ˜¯åœ¨Cç›˜çš„ï¼ˆå¦‚ä¸Šå›¾ï¼‰ï¼Œåˆ°äº†åæœŸgradleæ–‡ä»¶ä¼šè¶Šæ¥è¶Šå¤§ï¼ŒCç›˜ä¼šçˆ†æ»¡ï¼Œæˆ‘ä»¬å°†å®ƒç§»åˆ°å…¶ä»–ç›˜ 1.æ‰“å¼€â€œç³»ç»Ÿé«˜çº§è®¾ç½®â€ï¼Œé€‰æ‹©â€œç¯å¢ƒå˜é‡â€ æ‰¾åˆ°GRADLE_USER_HOME é€‰æ‹©ä½ æƒ³å­˜æ”¾çš„åœ°æ–¹ ç¡®å®šä¿å­˜ æ¢¯å­çš„é—®é¢˜githubå’Œgooleéœ€è¦æ¢¯å­ï¼Œæè®¡ç®—æœºçš„ï¼Œæ¢¯å­æ˜¯å¿…ä¸å¯å°‘çš„ï¼Œä½ ä»¬å¯ä»¥è‡ªå·±å»æ‰¾æ¢¯å­ï¼Œä¹Ÿå¯ä»¥ç§ä¸‹æ‰¾æˆ‘ä»¬ã€‚ è®¾ç½®ä»£ç† å¦‚æœä½ æœ‰æ¢¯å­çš„è¯å¯ä»¥ç»™ASè®¾ç½®ä»£ç†ï¼Œè¿™æ ·å¯ä»¥åœ¨ASé‡Œè®¿é—®å¤–ç½‘ï¼ˆä¾‹å¦‚è°·æ­Œç¿»è¯‘ï¼‰ æ‰“å¼€è®¾ç½®ï¼Œæ‰¾åˆ°HTTP Proxyï¼Œé€‰æ‹©æ‰‹åŠ¨ä»£ç†è®¾ç½®ï¼Œæ–¹å¼é€‰æ‹©HTTPï¼Œåœ°å€é»˜è®¤å°±æ˜¯127.0.0.1,ç«¯å£å·å¯ä»¥åˆ°Windowsçš„è®¾ç½®-ç½‘ç»œå’ŒInternet-ä»£ç†-æ‰‹åŠ¨ä»£ç†è®¾ç½®-ç¼–è¾‘ï¼Œç‚¹å‡»ç¼–è¾‘å°±èƒ½çœ‹åˆ°ç«¯å£å·äº† æ€»ç»“æœ¬èŠ‚è¯¾æˆ‘ä»¬ä¸»è¦å­¦ä¹ äº†Android Studioçš„ä½¿ç”¨ï¼ŒæŒæ¡äº†ä¸€äº›å¸¸ç”¨æ§ä»¶å’Œå¸ƒå±€ï¼Œå¯¹Activityä¹Ÿæœ‰äº†ä¸€äº›è®¤è¯†ã€‚ åœ¨ç»å†äº†è¿™åŠå­¦æœŸçš„å­¦ä¹ åï¼Œç›¸ä¿¡ä½ ä»¬ä»ç½‘æ ¡è¿™é‡Œå­¦ä¹ åˆ°äº†å¾ˆå¤šï¼Œè¿˜è®°å¾—å¼€å§‹å…¥ç¾¤æ—¶æœ‰500å¤šäººï¼Œåˆ°ç°åœ¨åªæœ‰å°‘æ•°äººåœ¨æ´»è·ƒï¼Œå¸Œæœ›åœ¨æ¥ä¸‹æ¥çš„è·¯ï¼Œä½ ä»¬èƒ½åšæŒèµ°å®Œï¼Œæœ€åå›å¤´æ¥çœ‹ä½ ä¼šæ„Ÿè°¢å¦‚ä»Šçš„è‡ªå·±ã€‚","tags":["Android"],"categories":["Android"]},{"title":"Androidå­¦ä¹ æ¸…å•","path":"/2022/09/29/Androidå­¦ä¹ /","content":"Androidå­¦ä¹ æ¸…å• å¯’å‡å­¦ä¹ è·¯çº¿ æŒ‰ç…§ä¼ ç»Ÿï¼Œå¯’å‡è€ƒæ ¸ä¸èƒ½ä½¿ç”¨éå®˜æ–¹åº“ï¼Œæ‰€ä»¥ä»¥ä¸‹å†…å®¹ä¸åŒ…å«ç¬¬ä¸‰æ–¹åº“ éš¾åº¦ï¼škotlin æ¡†æ¶ è‡ªå®šä¹‰View 1ã€kotlin å¯ä»¥ä¹°ã€Šç¬¬ä¸€è¡Œä»£ç ã€‹ç¬¬ä¸‰ç‰ˆè¿›è¡Œå­¦ä¹ ï¼Œä¸Šé¢é™„å¸¦è®²è§£äº† kotlin çš„ä½¿ç”¨ æ³¨æ„ï¼š kotlin å¹¶ä¸æ˜¯å¯’å‡å¿…é¡»å­¦ä¹ çš„å†…å®¹ï¼Œå¯’å‡ä»èƒ½ä½¿ç”¨ java æ¥å†™ã€‚åœ¨ä¸‹å­¦æœŸå¼€å­¦ä¼šç»™ä½ ä»¬å‡ å‘¨çš„æ—¶é—´æ¥å­¦ä¹ ï¼ˆè‡ªå­¦ï¼Œæˆ‘ä»¬ä¸ä¼šæ•™ï¼‰ï¼Œæ‰€ä»¥å¯ä»¥è·³è¿‡å…ˆå­¦ä¸‹é¢çš„ 2ã€æ¡†æ¶ç›¸å…³ æ¡†æ¶æ–¹é¢æ¯”è¾ƒæ·±å¥¥éš¾æ‡‚ï¼Œå»ºè®®å»GitHubä¸Šæœç´¢ wanAndroid é¡¹ç›®é˜…è¯»ä¸€ä¸‹åˆ«äººå†™çš„æºç ï¼Œä¸ç„¶å…‰çœ‹åšå®¢çš„è§£é‡Šä¸åŠ¨æ‰‹æ“ä½œï¼Œæ˜¯å¾ˆéš¾ç†è§£æ¡†æ¶çš„ä½¿ç”¨çš„ 2.1ã€MVP è™½ç„¶åæœŸAndroidå¼€å‘éƒ½æ˜¯ä½¿ç”¨çš„MVVMï¼Œä½†MVVMæ˜¯MVPçš„æ¼”åŒ–ç‰ˆï¼ŒMVPè¿˜æ˜¯å€¼å¾—å»çœ‹ä¸€çœ‹çš„ 2.2ã€MVVM Androidå®˜æ–¹æ¨èæ¶æ„ï¼ˆä½†ç›®å‰åœ¨å‘ MVI æ¼”åŒ–äº†ï¼‰ï¼Œéœ€è¦ä¸ LiveDataã€ViewModel é…åˆä½¿ç”¨ 2.2.1ã€ViewModel ViewModel ä¸»è¦ä¸ç”Ÿå‘½å‘¨æœŸç›¸å…³ï¼Œç”Ÿå‘½å‘¨æœŸè¿™æ¦‚å¿µéœ€è¦ä½ ä»¬å¤šå†™ä»£ç æ‰èƒ½å½»åº•ç†è§£ï¼Œå¯ä»¥ä¸æ€¥ç€å»å½»åº•å­¦æ‡‚ 2.2.2ã€LiveData å¯’å‡æœŸé—´ææ¸…æ¥šæ€ä¹ˆç”¨å³å¯ï¼Œä¸»è¦æ˜¯é…åˆMVVMä¸­çš„ç½‘ç»œå±‚è¿›è¡Œå›è°ƒ 2.2.3ã€DataBinding ç›®å‰ DataBinding æœ‰ä¸€äº›å¥‡æ€ªçš„bugï¼Œæˆ‘ä»¬ä¸€èˆ¬æŠŠä»–å½“æˆäº† ViewBinding åœ¨ç”¨ 3ã€è‡ªå®šä¹‰Viewä¸æ»‘åŠ¨å†²çª è‡ªå®šä¹‰ View æ–¹é¢æ¯”è¾ƒéš¾ä¸”è€—æ—¶é—´ï¼Œå¦‚æœä½ æœ‰æƒ³å®ç°çš„ä¸€äº›å¤æ‚æ§ä»¶ï¼Œå¯ä»¥æ¥çœ‹çœ‹è¿™ä¸€å—ï¼ˆæ¯”å¦‚å†™ä¸€ä¸ªè½¬åŠ¨çš„é£è½¦ï¼‰ 3.1ã€è‡ªå®šä¹‰View ç‚¹å‡»è·³è½¬è‡ªå®šä¹‰View 3.2ã€æ»‘åŠ¨å†²çª æ»‘åŠ¨å†²çªæ˜¯è®¾è®¡è‡ªå®šä¹‰Viewå¿…ä¼šçš„ ç‚¹å‡»è·³è½¬æ»‘åŠ¨å†²çª 4ã€è‡ªå·±æ’¸åç«¯ï¼ˆä¸æ¨èï¼‰ ä¸æ˜¯å¾ˆæ¨èï¼Œå…‰æ˜¯ Android çš„çŸ¥è¯†ä½ éƒ½å­¦ä¸å®Œï¼Œå½“ç„¶ï¼Œå·ç‹é™¤å¤– å¤§ä¸€ä¸‹åŠä»¥åå­¦ä¹ è·¯çº¿ ä¸œè¥¿æœ‰äº›å¤šï¼Œå…¶å®å­¦é•¿æˆ‘ä»¬å¥½å¤šéƒ½æ²¡å­¦è¿‡ğŸ˜‚ 1ã€å¿…é¡»å†…å®¹1.1ã€kotlin1.2ã€å››å¤§ç»„ä»¶ é™¤æ‰ ContenProvder å¯ä¸ç”¨å­¦ä¹  ActivityServiceBroadcast 1.3ã€Rxjavaçš„ä½¿ç”¨1.4ã€Retrofitçš„ä½¿ç”¨ ä¸Rxjavaé…å¥—ä½¿ç”¨ä¸åç¨‹é…å¥—ä½¿ç”¨ 1.5ã€Roomçš„ä½¿ç”¨ ä¸Rxjavaé…å¥—ä½¿ç”¨ä¸åç¨‹é…å¥—ä½¿ç”¨ 1.6ã€MVVM + ViewModel + LiveData + DataBinding + Retrofit + Rxjava + Room è¿™æ˜¯æŒé‚®ç›®å‰çš„æ¡†æ¶ï¼Œå¸‚é¢ä¸Šçš„å¤§éƒ¨åˆ†åº”ç”¨åº”è¯¥éƒ½æ˜¯ç±»ä¼¼äºè¿™æ ·è®¾è®¡çš„ ä»¥ä¸‹æ˜¯å¯¹äº Android ä¹‹åå‘å±•çš„æ¨æµ‹ï¼ˆä»…ä»£è¡¨ä¸ªäººè§‚ç‚¹ï¼‰ï¼š Rxjava ä¸ åç¨‹ å¤§æ¦‚ç‡ä¼šå…±å­˜ï¼Œå› ä¸º Rxjava é€‚åˆå¤„ç†å¤æ‚æ•°æ®æµï¼Œåç¨‹æ›´é€‚åˆä¸€èˆ¬ä½¿ç”¨ LiveData æœ‰å‡ ç‡ä¼šè¢« Flow ä»£æ›¿ï¼Œä½† LiveData æ›´ç®€ä¾¿ï¼Œé€‚ç”¨äºå¤§éƒ¨åˆ†éœ€æ±‚ XML View ä¸ Compose ä»¥ååº”è¯¥ä¼šå…±å­˜ï¼ˆä¸ªäººè®¤ä¸ºå„æœ‰å„çš„ä¼˜åŠ¿ï¼‰ è¿˜æœ‰ç°åœ¨è°·æ­Œå¼€å§‹æ¨è MVI æ¶æ„äº†ï¼ˆé ï¼Œè°·æ­ŒçœŸçš„æ˜¯è¦ç´¯æ­»æˆ‘ä»¬å¼€å‘è€…ï¼‰ 2ã€æ‰©å±•å†…å®¹ å­¦é•¿ä»¬ä¸è®²æˆ–è®²ä¸ç»†çš„è‡ªå­¦å†…å®¹æ¨èå­¦ä¹ è½¯ä»¶ï¼šç¨€åœŸæ˜é‡‘æ¨èå¤§ä½¬æ–‡ç« ï¼šhttps://github.com/leavesC/AndroidGuide 2.1ã€Material Design è¿™é‡Œé¢å¾ˆå¤šä¾¿æ·çš„æ§ä»¶åŠç”¨æ³•ï¼Œæ¯”å¦‚ï¼šTabLayout ç›´æ¥æ·»åŠ å°åœ†ç‚¹ã€å…±äº«å…ƒç´ åŠ¨ç”»ç­‰ æ¨èç›´æ¥çœ‹å®˜ç½‘ï¼šhttps://material.io/ æ¨èå»æ‰“åŒ…ä»–çš„æºç ï¼šæºç ï¼ˆè™½ç„¶æºç æ²¡å†™æ³¨é‡Šï¼Œä½†æƒ³å®ç°æŸä¸ªåŠŸèƒ½æ—¶å¯ä»¥å»çœ‹çœ‹æ˜¯å¦å·²ç»æœ‰å®ç°äº†çš„ï¼‰ 2.2ã€çº¿ç¨‹æ±  çº¿ç¨‹æ± ä½œä¸šï¼šhttps://github.com/985892345/Android_Learning_Route/blob/main/çº¿ç¨‹æ± ä½œä¸š.md é˜»å¡é˜Ÿåˆ— ä½¿ç”¨LinedListå®ç°é˜»å¡é˜Ÿåˆ— ä»¿å†™CacheThreadPoolç­‰javaè‡ªå¸¦çš„å‡ ä¸ªçº¿ç¨‹æ±  2.3ã€RecyclerViewé«˜é˜¶ç”¨æ³• RecyclerViewè¿›é˜¶ä½œä¸šï¼šhttps://github.com/985892345/Android_Learning_Route/blob/main/RecyclerViewè¿›é˜¶ä½œä¸š.md 1ã€ç‚¹å‡»äº‹ä»¶ä¸è¦å†™åœ¨onBindViewHolderä¸­2ã€å®ç°ä¾§æ»‘åˆ é™¤ã€é•¿æŒ‰ç§»åŠ¨Itemï¼ˆè¿™äº›å®˜æ–¹éƒ½æœ‰å°è£…å¥½çš„æ¥å£ï¼‰3ã€notifyItemChanged ( positionï¼šInt, paylosdï¼šAny? ) è¿™æ˜¯ä¸¤ä¸ªå½¢å‚çš„åˆ·æ–°ï¼Œåé¢æœ‰ä¸€ä¸ªå•ç‹¬çš„å‚æ•° paylosd: Any? è¯¥æ–¹æ³•ä¸ onBindViewHolder(holder, position, payloads) ä¸‰ä¸ªå‚æ•°çš„å›è°ƒæœ‰å…³ç³» è¡¥å……å†…å®¹ åˆ·æ–°æ—¶å›¾ç‰‡ rv çš„å›¾ç‰‡ä¼šé—ªåŠ¨ è¯¥é—®é¢˜ä¸ rv çš„ç¼“å­˜æœ‰å…³ï¼Œå› ä¸ºåœ¨åˆ·æ–°æ—¶è¿™ä¸ª ViewHolder ä¸ç¼“å­˜ä¸­è¿›è¡Œäº†äº’æ¢ï¼Œç›¸å½“äºé‡æ–°åŠ è½½äº†å›¾ç‰‡ è§£å†³åŠæ³•ï¼šè°ƒç”¨å¸¦æœ‰ paylosd å‚æ•°çš„åˆ·æ–°ï¼Œå–æ¶ˆä¸ç¼“å­˜çš„äº’æ¢ 4ã€å·®åˆ†åˆ·æ–° DiffUtil DiffUtil ä¸­ä¹Ÿæœ‰ä¸€ä¸ªå¯é‡å†™çš„æ–¹æ³•ï¼Œå…¶ä¸­å¸¦æœ‰ paylosd å‚æ•° æ³¨ï¼š ç½‘ä¸Šéƒ¨åˆ†åšå®¢çš„å·®åˆ†æ¯”è¾ƒæœ‰äº›é—®é¢˜ï¼Œå°½é‡è‡ªå·±ææ‡‚åŸç†ï¼ˆä¸æ˜¯ç®—æ³•åŸç†ï¼Œè€Œæ˜¯ç©¶ç«Ÿè¯¥æ¯”è¾ƒä»€ä¹ˆæ•°æ®æ‰ä¼šæ˜¯çœŸæ­£çš„å·®åˆ†ï¼Œå°¤å…¶æ˜¯ areItemsTheSame æ–¹æ³•ï¼‰ 2.4ã€è‡ªå®šä¹‰View è‡ªå®šä¹‰Viewé¢„ä¹ ä½œä¸šï¼šhttps://github.com/985892345/Android_Learning_Route/blob/main/è‡ªå®šä¹‰Viewé¢„ä¹ ä½œä¸š.md è‡ªå®šä¹‰Viewè¯¾ä»¶ï¼šhttps://github.com/985892345/CustomViewWithAnimStudy æ¨èï¼š å…¥é—¨ï¼šã€ŠAndroidè‡ªå®šä¹‰æ§ä»¶å¼€å‘å…¥é—¨ä¸å®æˆ˜ã€‹ è¿›é˜¶ï¼šã€ŠAndroidè‡ªå®šä¹‰æ§ä»¶é«˜é˜¶è¿›é˜¶ä¸ç²¾å½©å®ä¾‹ã€‹ åšå®¢ï¼šè‡ªå®šä¹‰Viewæºç åŸç† 1ã€onLayout2ã€onMearsure3ã€onDraw4ã€åŠ¨ç”»ä½ éœ€è¦çŸ¥é“çš„å…¶ä»–çŸ¥è¯†ï¼š View.postpostdelay()æ–¹æ³•å¦‚ä½•åœ¨activityå¾—åˆ°æ§ä»¶çš„å®½å’Œé«˜ å¯ä»¥åšçš„å®ä¾‹ æµå¼å¸ƒå±€ 2.5ã€æ»‘åŠ¨å†²çª æ™®é€šæ»‘åŠ¨ æ¨èï¼š åšå®¢ï¼šå›¾è§£äº‹ä»¶åˆ†å‘dispatchTouchEventæºç è§£æ å›¾ç‰‡ï¼šéƒ­ç¥¥ç‘çš„æ»‘åŠ¨åˆ†å‘åˆ†æ”¯å›¾ dispatchTouchEventonInterceptTouchEventonTouchEventrequestDisallowInterceptTouchEvent åµŒå¥—æ»‘åŠ¨ æ¨èï¼š åšå®¢ï¼šå›¾è§£åµŒå¥—æ»‘åŠ¨ NestedScrollingParentå’ŒNestedScrollingParent2 NestedScrollingChild2å®˜æ–¹æ–‡æ¡£ NestedScrollingChildå’ŒNestedScrollingChild2 NestedScrollingParent2å®˜æ–¹æ–‡æ¡£ é¢˜å¤–è¯ï¼šä¸ºä»€ä¹ˆè¿˜è¦çœ‹1ï¼Œä¸ç›´æ¥çœ‹2ï¼Ÿå› ä¸ºéƒ¨åˆ†å®˜æ–¹æ§ä»¶ä¸­åªä½¿ç”¨äº†1ï¼Œæ‰€ä»¥ä½ è¦çŸ¥é“1å’Œ2çš„åŒºåˆ«ã€‚è¿˜æœ‰ä¸€ä¸ª3ï¼Œè¿™ä¸ª3åœ¨ç½‘ä¸Šçš„æ•™ç¨‹è¾ƒå°‘ï¼Œç›´æ¥ç»§æ‰¿äº†2ï¼Œæ–°å¢äº†åœ¨åµŒå¥—æ»‘åŠ¨ä¸­åªæ¶ˆè€—éƒ¨åˆ†å€¼çš„æ–¹æ³•ã€‚NestedScrollingParent3å®˜æ–¹æ–‡æ¡£ ä¸è®¾è®¡å¤šå±‚è‡ªå®šä¹‰Viewæ—¶çš„ä½¿ç”¨ å»ºè®®è‡ªå·±å†™ä¸€äº›å¤æ‚è‡ªå®šä¹‰Viewï¼ŒåŒ…å«å•å‡»ã€æ»‘åŠ¨ç­‰ä¸€ç³»åˆ—äº‹ä»¶ å¯å‚è€ƒéƒ­ç¥¥ç‘å†™çš„ TimeSelectView æ§ä»¶(æŒ‰ç…§ READMEå¯¼å…¥ç®€å•ä½¿ç”¨ä¸€ä¸‹ï¼Œæºç å†™çš„å¾ˆæ‹‰ï¼Œåœ¨é‡å†™äº†ğŸ˜«ï¼Œè¿™é‡Œç›´æ¥ç»™å‡ºè½¯ä»¶ä¸‹è½½åœ°å€ï¼Œä¸‹è½½åè‡ªå·±è¯•ç€æƒ³æƒ³è¯¥æ€ä¹ˆè®¾è®¡: https://wwi.lanzouo.com/iC1JGy08a0h ç®€å•çœ‹çœ‹Viewå’ŒViewGroupä¸­æ»‘åŠ¨æºç å¯ä»¥åšçš„å®ä¾‹ ä¸‹æ‹‰åˆ·æ–°ï¼ˆå¯å‚è€ƒ SmartRefreshLayoutï¼Œä¹Ÿå¯ä»¥æŠŠä¸Šæ‹‰åŠ è½½ä¸€èµ·å®ç°ï¼‰ 2.6ã€åè°ƒè€…å¸ƒå±€CoordinatorLayout å­¦ä¹ å®ƒéœ€è¦çŸ¥é“åµŒå¥—æ»‘åŠ¨ é«˜é˜¶ç”¨æ³•è‡ªå®šä¹‰ Behavior 2.7ã€ä»¿å†™Glide 1ã€å®ç°ä¸‰çº§ç¼“å­˜ 2ã€ææ‡‚å®ƒä¸ºä»€ä¹ˆèƒ½æ ¹æ® View çš„ç”Ÿå‘½å‘¨æœŸè€Œè‡ªåŠ¨å–æ¶ˆåŠ è½½å›¾ç‰‡ï¼ˆä»–å¯æ²¡æœ‰ä½¿ç”¨ Lifecycle è¿™ä¸ªä¸œè¥¿ï¼‰ 3ã€æ”¹ç”¨ Lifecycle å®ç° 2.8ã€ä»¿å†™Okhttp å°è¯•å®ç°æ‹¦æˆªå™¨ ä»¿å†™Gson 2.9ã€ä»¿å†™Rxjava å°±ç®—ä½ æ²¡æ—¶é—´ä»¿å†™å®ƒï¼Œä¹Ÿå¿…é¡»æŠŠå®ƒç”¨ç†Ÿï¼Œå› ä¸ºå®ƒçš„æ€æƒ³å¾ˆé‡è¦ 2.10ã€ä»¿å†™EventBus ä½†ä¸å»ºè®®ä½¿ç”¨ï¼Œæ­¤æ¡†æ¶å› è¿‡äºçµæ´»ï¼Œä¼šåƒgotoä¸€æ ·é€ æˆæ»¥ç”¨è€Œéš¾ä»¥æº¯æº 2.11ã€MotionLayout æœ‰å¾ˆå¤šè‡ªå®šä¹‰Viewéš¾å®ç°æ—¶ç”¨è¿™ä¸ªæ¥å†™å¾ˆç®€å• æ¨èè°·æ­Œå®˜ç½‘ï¼šhttps://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn 3ã€å…¶ä»–å†…å®¹ å­¦ä¹ æˆæœ¬è¿‡é«˜æˆ–ç›®å‰é˜¶æ®µä¸å¤Ÿæˆ–ç›®å‰ä¸ä½¿ç”¨ 3.1ã€è®¾è®¡æ¨¡å¼ æœ‰å‡ ä¸ªç®€å•çš„è¿˜æ˜¯è‡ªå·±è¦æå‰äº†è§£ä¸‹ 3.2ã€åç¨‹åŸç† æ¨èæ–‡ç« ï¼šhttps://openxu.blog.csdn.net/article/details/116016798 æ¨è21çº§çº¢å²©å­¦é•¿è”·ç¥çš„å¿ƒå¾—ä½“ä¼šï¼šhttps://github.com/False-Mask/KotlinCoroutine 3.3ã€Navigation ç›®å‰è¿˜æœ‰äº›å‘ï¼Œå®˜æ–¹è¿˜åœ¨æ”¹è¿›ä¸­ï¼ŒæŒé‚®ä¸­ä¹Ÿä¸ä½¿ç”¨ 3.4ã€RecyclerView æ»‘åŠ¨äº‹ä»¶æºç LayoutMangerå¤šçº§ç¼“å­˜ 3.5ã€paging3 ä¸æ˜¯2å’Œ1 3.6ã€ä½¿ç”¨æ³¨è§£å®ç°ä¸€äº›éªšæ“ä½œ3.7ã€gradleçš„ä½¿ç”¨3.8ã€hiltä¾èµ–æ³¨å…¥3.9ã€jvm3.10ã€Compose3.11ã€Flow3.12ã€ARouterçš„ä½¿ç”¨3.xx åˆ«å·äº†ï¼Œåˆ«å·äº†ï¼â€¦â€¦","tags":["Android"],"categories":["Android"]},{"title":"å…³äº","path":"/about/index.html","content":"ğŸ”­ I am currently studying in CQUPT and will soon go to Zhejiang University. ğŸŒ± I am familiar with Python and C++. ğŸ‘¯ I know about computer networks, data structures, operating systems and deep learning. âš¡ Fun fact: mobile and algorithm ğŸ“« How to reach me: Email:","tags":[null],"categories":[null]},{"title":"å‹é“¾","path":"/friends/index.html","content":"çº¢å²©ç½‘æ ¡ EmNets æŒä¸Šé‡é‚®","tags":[null],"categories":[null]}]