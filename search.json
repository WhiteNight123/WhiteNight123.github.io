[{"title":"保研经验贴","path":"/2024/09/29/保研经验贴/","content":"2024年（25届）四非计算机保研经验贴（浙软，北邮，重大，成电，西电杭，深大）[TOC] 前言今年是对四非地狱级外保难度的一年（以后会更难🤡），大部分学校保研率提升，盛行本校保护，工程硕博计划占用大量名额，很多学校开始优化生源质量，但所幸我的结果也还不错。 个人情况学校：某西南地区四非 专业：软件工程 rk：前五学期排名3360（夏令营根本过不了），六学期综合排名1530（排名出的太晚了，很多好学校已经截止了）。 四六级：4级490，6级没过（夏令营被拒得快奔溃了），预推免450（勉强能用） 竞赛：蓝桥杯国一，软件杯国三，数模省一（大部分老师不看，甚至有老师问蓝桥杯是什么比赛🤡） 科研：🈚，极大的短板 rk≈顶级科研6级竞赛 目标：中9或北邮。 最终去向：浙江大学软件学院人工智能专业。 夏令营入营情况不是rk1+没过6级，夏令营极其惨淡，真的快崩溃了。 学校 学院 状态 备注 南京大学 智能软件 未入 投着玩 南京大学 软件 未入 双杀 北京邮电大学 计算机 面试寄 面试15min，寄了 浙江大学 软件 优营 预推免入场券 西北工业大学 软件 未入 不懂 中山大学 软件 未入 投着玩 电子科技大学 智能计算 未入 投着玩 山东大学 软件 宣讲营 海营 中国科学技术大学 先研院 未入 发了20封邮件，无果 北京师范大学 人工智能 未入 投着玩 北京理工大学 珠海 未入 投着玩 北京交通大学 计算机 未入 不懂 华南理工大学 软件 未入 不懂 深圳大学 计算机 优营 候补第二批入了 重庆大学 计算机 未入 卡双一流 重庆大学 工程师 未入 双杀 重庆大学 软件 未入 三杀 北京航空航天大学 计算机 未入 投着玩 北京航空航天大学 软件 机试寄 不是acmer 从上面的表可以看到，夏令营十分惨烈，只拿到了深大的offer和浙软预推免的入场券。 北京邮电大学计算机，寄了入了11组，说是从200人里选了40人，最终录取8人。线上15分钟面试，8分钟自我介绍，然后是提问项目，第一次面试，准备不充分，结果就是寄了。 浙软，优营线上，总共入了2700人，我选的是大数据分营，然后里面还要再分团队。我们团队是阅读一篇论文，然后做一个汇报+面试，准备了一个星期，优了。今年出现了卓越营员（只能是985和北邮西电）相当于铁offer，然后是优秀营员（预推免入场券），今年的bar异常的高，对于双非和211基本靠优营才能进预推免。优秀营员占比10%，卓越营员占比3%。 深圳大学，优营唯一一个线下的夏令营，由于是无条件报销800元，入营门槛较高，候补了两轮进去了。首先就是听讲座，第一天晚上模拟机试，第二天晚上正式机试，难度一般数据结构的水平，后面有一点点难，最后70分，第三天下午是面试。面试方式为群面，分到各个团队里，以圆桌会议的方式聊天，最后拿到优营offer（疑似机试不爆零就给）。 不得不说，深大是真的有钱，如果不是四非就好了。 预推免入营情况 学校 学院 状态 备注 浙江大学 软件学院 候补3 最终去向 南京大学 软件学院 未入 投着玩 南京大学 智能软件 未入 投着玩 中南大学 计算机 未入 有点迷 湖南大学 工程硕博 未入 有点迷 湖南大学 信息学院 未入 有点迷 中国科学技术大学 科学岛 未入 有点迷 中国科学技术大学 工程硕博 未入 投着玩 山东大学 计算机 已入,鸽 时间太长和重大冲突了 大连理工大学 计算机 已入,鸽 和浙软冲突了 同济大学 工程硕博 未入 投着玩 西安电子科技大学 卓工 已入,寄 体验了一下 南京航空航天大学 计算机 已入,鸽 和浙软冲突了 电子科技大学 计算机 已入,鸽 浙软候补到了，没去 重庆大学 计算机 候补,鸽 体验了一下 北京邮电大学 计算机 被鸽 被老师鸽了🤡，后有惊喜 可以看到，预推免的时候我推免排名提高，入营情况也稍微好点了。但由于今年大部分学校提升生源质量，预推免仍然艰难。 浙软浙软是我预推免的第一站，也是我的最终去向。 今年bar很高，由于有夏令营的优营，过了初筛，今年双非rk1基本进不去。预推免总共筛了近800人，线下来了540人，生源明显比去年提高了，大概90%都是9爷。 浙软复试分为机试和面试，机试占比15%，第一天晚上开始机试，共4道题，难度以此递增，题目背景均与赤壁相关（考察了简单数学，dfs，dp，二分），难度比去年略大，但是ak人数更多了，我1个半小时ak，排名40+，等到结束时，约130个ak，90分以上的200+。听说往年是按机试给面试成绩，但今年机试没有区分度了（太卷了），而且老师面试的时候好像看不到你的机试成绩。 20号机试，面试排到22号了，时间20分钟，有个计时器。浙软不同的组面试风格很不同。我们组首先来个1分钟英文自我介绍，然后开始用ppt讲5-8分钟。接下来问专业课，我选择了计网，问了两个问题，没听懂（🤡），然后换了数据结构。怎么求树的直径，怎么求图的直径，树的直径和图的直径有什么区别。如何维护数组中的最大值，如何快速求出中位数。用过stl吧，如果需要一个自动排序的集合，可以有重复的元素，应该用什么。multiset插入两次2，erase一次2，结果是什么。sort函数从小到大排序，比较怎么写，如果把改成有什么区别。答的稀烂，然后开始问项目，项目里有个把n个模型分配到m个设备，我使用的线性规划，老师说这是一个算法问题，应该用什么算法解决，（完全不懂🤡），然后又问了一些项目的细节。最后问到，夏令营在哪个营，哪个课题组，干了些什么。就这样结束了。 总之面崩了，出来后整个人都不好了，那个主问的老师应该是打acm的，看见我算法不错，直接问到底。。。可我不是acmer啊😭。在外面坐了一会儿，感觉天塌了，然后就去杭州西湖散散心，顺便参加西电杭的复试（本来打算如果稳了的话，就不参加了）。 25号出了结果，排名190+540，候补第三，然后第二天就补到了，一步登天，跨越双非、双一流、211、普通985这些学院歧视链直接来到顶流985水平。 ps：浙软明年就换新校区了，来了很多新导师，生源质量也上来了，以后会越来越好，24入浙软49入党，软微已死浙软当立！ 西电杭接上，面完了浙软，感觉大寄，就去杭州面西电杭了，准备拿个保底。 西电杭需要先联系导师，这个老师是我在报完系统后主动找我的，简单聊了一下，方向也还行，然后就选他了。 复试分为笔试和面试，笔试内容为通信，数据结构，计组，计网，密码学。只会写数据结构。 面试先英语自我介绍，然后用英语介绍一个项目。接着就是问项目的一些细节。最后还有思政题，没答上来🤡。 面完感觉比较水，然后过了几天也没消息，我也没去联系老师，典型的学校和学生互鸽🕊️，反正我有浙软offer了，不管他了。 重大计算机重大今年bar很迷，计算机卡rk1，软件卡双一流，而且复试费150元。 26号面试，交了钱都鸽了13。面试内容：先英语自我介绍，然后口语对话，及其简单，感觉像是小学生对话，问了我的sports。然后专业课问了数组如何查询固定区间的和，使用前缀和。接着问项目，重大的老师是唯一一个问了我数模的项目，问的还比较细。然后问了我报了哪些学校，有什么offer，其实当时我还是0ffer。然后就结束了。 由于知道浙软肯定能补到，所以重大面试也没怎么上心，而且问的也比较水。 第二天告诉我候补，没有名单。928下午打电话说我候补到了，计算机学硕，然后我拒了。 ps：往年点击就送的重大不见了。。。 决战929今年系统又改了，928上午9点填志愿，929上午9点招生单位开始录取，所以今年的鸽子会在928先飞一批，然后929再飞一批。 首先科普一下推免系统 一个学生可以填写三个独立志愿 一个院校可以给学生发放复试、拟录取通知 先接受复试，再接受拟录取 但复试、拟录取，都是有时效性的，比如10分钟内没有接受，招生办可能会收回你的offer 只要你接受了拟录取，你的保研生涯就会结束 9月28日9点~9月29日9点这段时间，学生可以填写志愿 每个志愿填写之后自动上锁，48小时不可以修改（但是院校教务老师，可以帮你解锁你的志愿） 9月29日9点之后院校才可以开始发放复试、拟录取通知 每个志愿是平行的，院校看不到你是第几个填写的这个志愿 但是院校给你发放通知的时候，可以看到你接受了哪些学校的复试 鸽链反应：这是一个非常有趣的现象 原因1： 可以理解为28定律，80%的offer在20%的人中，但也不完全是。 原因2： 比如学生A能在厦大夏令营拿到第1，那么他绝不可能只有厦大这个offer，A很可能在华科拿到offer第20或30，人大拿到offer第60这样，而复旦拿到候补名单第5。 结果A前面参加复旦夏令营的人又同时拿到清北、计算所的offer了，纷纷释放复旦offer，然后A被候补到了，于是A就释放厦大、华科、人大的offer。在前面三个学校的人，又因为A的释放被候补到了。 然后这些被候补到的人，继续往下一层释放offer，比如西电、南航等，最后候补和鸽子就会像树形结构一样疯狂下传。 因为929之前拿的offer都不是铁offer，学生自己也可能被弱com鸽，需要拿强com院校保底。以及可能学生自身也有多个梦校，都会尝试拿offer。 原因3： 这个现象往往出现在招生办开始录取时，毕竟每个人只能去读一个学校，你可能有差一点的学校B的准offer，也有梦校C的候补。 比如差一点学校，要求你1分钟接受拟录取，否则作废。那么你面对的只有四种结果 接受，你没有候补到，一个很棒的结果，你最终去了学校B 接受，你候补到了，你痛失梦校非常遗憾，但好像还能接受，你最终去了学校B 拒绝，你等到了候补，上岸梦校，你最终去了梦校C 拒绝，你没有等到候补，一瞬间没有书读了，成为loser 很多人担心没有书读而接受了拟录取，假设候补到时已经系统已经锁了，只能继续往下滚动候补队列 一些见闻1、圣经就是圣经！ 2、好多学校被鸽穿了，该！ 3、一定要海投！ 4、尽量不要鸽老师，要鸽早点鸽，别等到录取那天临时鸽，你自己爽了，下一届学弟学妹遭殃了，更不要集邮！ 5、8月联系了一个北邮老师（15组），还进组打工一段时间，然后中秋节把我鸽了。。。928的时候又跟我说有学硕名额🤡。 6、今年想外保真的挺难的，我们学院去了不少211，甚至还有本校。 7、还有好多名场面，最后几天乐子真多，强烈建议加入绿群 943826679 另外，给还在准备保研的uu们告诫： 首先，铭记住幸存者偏差 其次，选择大于努力 不要盲目自信，不要感动自我式的努力 不要孤注一掷，多一点选项，有时候真的运气实力 总结三年的长跑终于画上了句号，最后那一段时间都在焦虑，终究还是挺过来了。在四非0科研的情况和今年地狱级的外保形势下，感觉已经是我能找到的最优解了。一个个选择塑造了人生，这次all in 浙软，希望一切都是最好的安排。 最后，愿所有的保研er们，最终都取得心仪的offer，上岸梦校","tags":["保研","计算机"],"categories":["保研"]},{"title":"洛谷题单","path":"/2024/09/19/洛谷题单/","content":"洛谷综合题单试机题 三道试机题目。 P1000 超级玛丽游戏 #include iostreamusing namespace std;int main() cout ******** ; cout ************ ;\tcout ####....#. ; cout #..###.....##.... ; cout ###.......###### ### ### ; cout ........... #...# #...# ; cout ##*####### #.#.# #.#.# ; cout ####*******###### #.#.# #.#.# ; cout ...#***.****.*###.... #...# #...# ; cout ....**********##..... ### ### ; cout ....**** *****.... ; cout #### #### ; cout ###### ###### ; cout############################################################## ; cout#...#......#.##...#......#.##...#......#.##------------------# ; cout###########################################------------------# ; cout#..#....#....##..#....#....##..#....#....##################### ; cout########################################## #----------# ; cout#.....#......##.....#......##.....#......# #----------# ; cout########################################## #----------# ; cout#.#..#....#..##.#..#....#..##.#..#....#..# #----------# ; cout########################################## ############ ; return 0; P1001 A+B Problem #include iostreamusing namespace std;int main() int a, b; cin a b; cout a + b; return 0; P1008 三连击 #include iostream#include stringusing namespace std;bool st[10];string str;void dfs(int x) if (x == 9) int a = stoi(str.substr(0, 3)); int b = stoi(str.substr(3, 3)); int c = stoi(str.substr(6, 3)); if (a * 2 == b a * 3 == c) cout a b c endl; for (int i = 1; i 10; i++) if (!st[i]) st[i] = true; str.push_back(i + 0); dfs(x + 1); st[i] = false; str.pop_back(); int main()\tdfs(0);\treturn 0; 入门阶段 本部分内容针对入门 OIer ，主要是语言基础内容。 从零开始 语言基础题。 P1421 小玉买文具 #include iostreamusing namespace std;int main() int a, b;\tcin a b;\tint c = a * 10 + b;\tcout c / 19; return 0; P1909 买铅笔 #include iostreamusing namespace std;int main() int n, a1, a2, b1, b2, c1, c2, res1, res2, res3, res;\tcin n a1 a2 b1 b2 c1 c2;\tif (n % a1 == 0) res1 = n / a1 * a2;\telse res1 = (n / a1 + 1) * a2;\tif (n % b1 == 0) res2 = n / b1 * b2;\telse res2 = (n / b1 + 1) * b2;\tif (n % c1 == 0) res3 = n / c1 * c2;\telse res3 = (n / c1 + 1) * c2;\tres = min(res1, min(res2, res3));\tcout res; return 0; P1089 津津的储蓄计划 #include iostreamusing namespace std;int main() int x, rem = 0; double res; for (int i = 1; i = 12; i++) cin x; rem = rem + 300 - x; if (rem 0) cout -i; return 0; else if (rem = 100) res += (rem / 100) * 100; rem %= 100; cout res * 1.2 + rem; return 0; P1085 不高兴的津津 #include iostreamusing namespace std;int main() int a, b;\tint res = 0, mind = 0;\tfor (int i = 1; i = 7; i++) cin a b; int t = min(0, 8 - a - b); if (mind t) res = i; mind = t; cout res; return 0; P1035 级数求和 #include iostreamusing namespace std;int main() int k;\tcin k;\tdouble t;\tfor (int i = 1; i 10000000; i++) t += 1.0 / i; if (t k) cout i; break; return 0; P1980 计数问题 #include iostream using namespace std; int main() int n, x, res = 0; cin n x; for (int i = 1; i = n; i++) int t = i; while (t 0) if (t % 10 == x) res++; t /= 10; cout res; return 0; - [P1014 Cantor表](https://www.luogu.com.cn/problem/P1014)```c++#include iostream#include stringusing namespace std;const int N = 1000;string g[N][N];int main() int n, i = 1, j = 1, t = 1, flag = 1;\tcin n;\twhile (t n) if (flag == 1) j++; flag = 2; else if (flag == 2) i++; j--; if(j == 1) flag = 3; else if (flag == 3) i++; flag = 4; else if (flag == 4) i--; j++; if (i == 1) flag = 1; t++; cout i / j; return 0; P1307 数字反转 #include iostream#include string#include algorithmusing namespace std;int main() string n;\tcin n;\tif (n[0] == -) cout -; n = n.substr(1); else if (n == 0) cout 0; return 0; reverse(n.begin(), n.end());\twhile (n[0] == 0) n.erase(0, 1); cout n; return 0; 优化 #include iostreamusing namespace std;int main() int n, m = 0;\tcin n;\twhile (n) m = m * 10 + n % 10; n /= 10; cout m; return 0; 数组基础 数组可以用于存储大量的信息。 P1046 陶陶摘苹果 #include iostreamusing namespace std;int nums[11], n, res;int main() for (int i = 0; i 10; i++) cin nums[i]; cin n;\tfor (int i = 0; i 10; i++) if (n + 30 = nums[i]) res++; cout res; return 0; P1047 校门外的树 #include iostreamusing namespace std;bool nums[10001];int main() int n, m, l, r; cin n m; for (int i = 0; i m; i++) cin l r; for (int j = l; j = r; j++) nums[j] = true; int res = 0;\tfor (int i = 0; i = n; i++) if (!nums[i]) res++;\tcout res; return 0; P1427 小鱼的数字游戏 #include iostream#include vector#include algorithmusing namespace std;int main() vectorint nums; int x; while (true) cin x; if (x == 0) break; nums.push_back(x); reverse(nums.begin(), nums.end());\tfor (auto it: nums) cout it ; return 0; P2141 珠心算测验 #include iostream#include setusing namespace std;int nums[101];bool st[20001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; st[nums[i]] = true; setint res;\tfor (int i = 0; i n; i++) for (int j = i + 1; j n; j++) if (nums[i] == nums[j]) continue; if (st[nums[i] + nums[j]]) res.insert(nums[i] + nums[j]); cout res.size(); return 0; P5594 【XR-4】模拟赛 #include iostream#include set using namespace std;setint nums[1001];int main() int n, m, k, x; cin n m k; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x].insert(j); for (int i = 1; i = k; i++) cout nums[i].size() ; return 0; 字符串基础 字符串是特殊的数组，但它也有很多自身的特点。 P5015 标题统计 #include iostream#include stringusing namespace std;int main() string s; getline(cin, s); int res = 0;\tfor (int i = 0; i s.size(); i++) if (s[i] != s[i] != ) res++; cout res; return 0; P1055 ISBN号码 #include iostreamusing namespace std;int main() int a, b, c;\tchar d, e;\tscanf(%d-%d-%d-%c, a, b, c, d);\tint t = (a + (b / 100) * 2 + (b % 100 / 10) * 3 + (b % 10) * 4 + (c / 10000) * 5 + (c % 10000 / 1000) * 6 + (c % 1000 / 100) * 7 + (c % 100 / 10) * 8 + (c % 10) * 9 ) % 11;\tif (t == 10) e = X;\telse e = 0 + t;\tif (d == e) cout Right;\telse cout a - b - c - e; return 0; P1308 统计单词数 #include iostream#include stringusing namespace std;int main() string p, s;\tcin p;\tgetchar();\tfor (int i = 0; i p.size(); i++) p[i] = tolower(p[i]);\tint id = -1, cnt = 0, j = 0;\tgetline(cin, s);\tfor (int i = 0; i s.size(); i++) if (s[i] == ) continue; int j = i; for (;j s.size(); j++) if (s[j] == ) break; s[j] = tolower(s[j]); if (p == s.substr(i, j - i)) if (id == -1) id = i; cnt++; i = j; if (id == -1) cout id;\telse cout cnt id; return 0; P2010 回文日期 #include iostream#include string#include algorithmusing namespace std;int days[13] = 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;int main() int date1, date2, res = 0;\tcin date1 date2;\tfor (int i = 1; i =12; i++) for (int j = 1; j = days[i]; j++) int t = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10; t = t * 10000 + i * 100 + j; if (t = date1 t = date2) res++; cout res; return 0; P1012 拼数 #include iostream#include string#include algorithmusing namespace std;string nums[21];bool cmp(string a, string b) return a + b b + a;int main() int n;\tcin n;\tstring a;\tfor (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n, cmp);\tfor (int i = 0; i n; i++) cout nums[i]; return 0; P5587 打字练习 #include iostream#include string#include vector#include algorithmusing namespace std;vectorstring s, t;int main() string str;\twhile(getline(cin, str)) if (str == EOF) break; string a; for (int i = 0; i str.size(); i++) if (str[i] == ) if (!a.empty()) a.pop_back(); else a.push_back(str[i]); s.push_back(a); while(getline(cin, str)) if (str == EOF) break; string a; for (int i = 0; i str.size(); i++) if (str[i] == ) if (!a.empty()) a.pop_back(); else a.push_back(str[i]); t.push_back(a); int time, cnt = 0;\tcin time;\tfor (int i = 0; i t.size(); i++) for (int j = 0; j min(s[i].size(), t[i].size()); j++) if (s[i][j] == t[i][j]) cnt++; cout cnt * 60 / time; return 0; 函数，递归及递推 这是初学者最难理解的部分，建议画出递归图来理解递归的过程。 P1028 数的计算 #include iostreamusing namespace std;int nums[1001];int main() int n;\tcin n;\tfor (int i = 1; i = n; i++) for (int j = 1; j = i / 2; j++) nums[i] += nums[j]; nums[i]++; cout nums[n]; return 0; P1036 选数 #include iostream#include vectorusing namespace std;int nums[21], n, k, res;bool st[10000001];void dfs(int a, int start, int t) if (a == k) if (!st[t]) res++; return; for (int i = start; i n; i++) dfs(a + 1, i + 1, t + nums[i]);\tint main() cin n k;\tst[0] = st[1] = true;\tfor (int i = 2; i 10000001; i++) if (!st[i]) for (int j = i + i; j 10000001; j += i) st[j] = true; for (int i = 0; i n; i++) cin nums[i];\tdfs(0, 0, 0);\tcout res; return 0; P1464 Function #include iostreamusing namespace std;typedef long long LL;LL dp[21][21][21];int main() for (int i = 0; i 21; i++) for (int j = 0; j 21; j++) dp[0][i][j] = dp[i][0][j] = dp[i][j][0] = 1; for (int i = 1; i 21; i++) for (int j = 1; j 21; j++) for (int k = 1; k 21; k++) if (i j j k) dp[i][j][k] = dp[i][j][k-1] + dp[i][j-1][k-1] - dp[i][j-1][k]; else dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j-1][k-1]; LL a, b, c;\twhile (cin a b c) if (a == -1 b == -1 c == -1) break; if (a = 0 || b = 0 || c = 0) printf(w(%lld, %lld, %lld) = 1 , a, b, c); else if (a 20 || b 20 || c 20) printf(w(%lld, %lld, %lld) = %lld , a, b, c, dp[20][20][20]); else printf(w(%lld, %lld, %lld) = %lld , a, b, c, dp[a][b][c]); return 0; P5534 【XR-3】等差数列 #include iostreamusing namespace std;int main() long long a, b, c;\tcin a b c;\tlong long res = c * a + c * (c - 1) * (b - a) / 2;\tcout res; return 0; P1192 台阶问题 #include iostreamusing namespace std;const int MOD = 100003;int dp[100001];int main() int n, k;\tcin n k;\tfor (int i = 1; i = k; i++) dp[i] = 1;\tfor (int i = 1; i = n; i++) for (int j = i - 1; j max(i - k - 1, 0); j--) dp[i] = (dp[i] + dp[j]) % MOD; cout dp[n]; return 0; P1025 数的划分 dfs #include iostreamusing namespace std;int n, k, res;void dfs(int cnt, int s, int t) if (cnt == k t == n) res++;\tif (cnt == k) return;\tfor (int i = s; t + i*(k - cnt) = n; i++) dfs(cnt + 1, i, t + i);\tint main() cin n k;\tdfs(0, 1, 0);\tcout res; return 0; dp #include iostreamusing namespace std;int dp[201][7];int main() int n, k;\tcin n k;\tfor (int i = 1; i = n; i++) dp[i][1] = 1; for (int i = 2; i = n; i++) for (int j = 2; j = k; j++) dp[i][j] += dp[i - 1][j - 1]; if (i j) dp[i][j] += dp[i - j][j]; cout dp[n][k]; return 0; P4994 终于结束的起点 #include iostream#include vectorusing namespace std;int fib[10000001];int main() int m;\tcin m;\tfib[0] = 0;\tfib[1] = 1;\tfor (int i = 2; i 10000001; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % m; int res = 0;\tfor (int i = 1; i 10000000; i++) if (fib[i] == 0 fib[i + 1] == 1) res = i; break; cout res; return 0; 基础算法 这一部分的内容包含了 OI 中的基础算法，供各位巩固基础。 当然，这里面也有一些难度比较高的题目。 模拟 模拟，顾名思义就是题目要求你做什么你就做什么，这样的题目很考验选手的代码组织能力。 这里不仅仅有非常基础的模拟，也有一些非常复杂的题目。 P1003 铺地毯 #include iostreamusing namespace std;int gg[100001][4];int main() int n, a, b, g, k, x, y, res = -1;\tcin n;\tfor (int i = 1; i = n; i++) cin a b g k; gg[i][0] = a; gg[i][1] = a + g; gg[i][2] = b; gg[i][3] = b + k; cin x y;\tfor (int i = n; i 0; i--) if (x = gg[i][0] x = gg[i][1] y = gg[i][2] y = gg[i][3]) res = i; break; cout res; return 0; P1067 多项式输出 #include iostreamusing namespace std;int main() int n, x;\tcin n x;\tif (n == 0) cout x; return 0; if (x 1) cout x x^ n;\telse if (x == 1) cout x^ n;\telse if (x == -1) cout -x^ n;\telse if (x -1) cout x x^ n;\tfor (int i = n - 1; i 1; i--) cin x; if (x 1) cout + x x^ i; else if (x == 1) cout +x^ i; else if (x == -1) cout -x^ i; else if (x -1) cout x x^ i; cin x;\tif (x 1) cout + x x;\telse if (x == 1) cout +x;\telse if (x == -1) cout -x;\telse if (x -1) cout x x;\tcin x;\tif (x 0) cout + x;\telse if (x 0) cout x; return 0; 优化版 #include iostreamusing namespace std;int main() int n, x; cin n; for (int i = n; i = 0; i--) cin x; if (x) if (x 0 i != n) cout +; if (abs(x) 1 || i == 0) cout x; if (x == -1 i) cout -; if (i 1) cout x^ i; if (i == 1) cout x; return 0; P1328 生活大爆炸版石头剪刀布 #include iostreamusing namespace std;int a[401], b[401];int main() int n, na, nb; cin n na nb; for (int i = 0; i na; i++) cin a[i];\tfor (int i = 0; i nb; i++) cin b[i];\tfor (int i = na; i n + na; i += na) for (int j = 0; j na; j++) a[i + j] = a[j]; for (int i = nb; i n + nb; i += nb) for (int j = 0; j nb; j++) b[i + j] = b[j]; int resa = 0, resb = 0;\tfor (int i = 0; i n; i++) if (a[i] == b[i]) continue; if (a[i] == 0 b[i] == 2 || a[i] == 0 b[i] == 3 || a[i] == 1 b[i] == 0 || a[i] == 1 b[i] == 3 || a[i] == 2 b[i] == 1 || a[i] == 2 b[i] == 4 || a[i] == 3 b[i] == 2 || a[i] == 3 b[i] == 4 || a[i] == 4 b[i] == 0 || a[i] == 4 b[i] == 1) resa++; else resb++; cout resa resb endl; return 0; 优化版 #include iostreamusing namespace std;int v[5][5] = 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0;int a[201], b[201];int main() int n, na, nb, resa = 0, resb = 0; cin n na nb; for (int i = 0; i na; i++) cin a[i]; for (int i = 0; i nb; i++) cin b[i]; for (int i = 0; i n; i++) resa += v[a[i % na]][b[i % nb]]; resb += v[b[i % nb]][a[i % na]]; cout resa resb endl; return 0; P1563 玩具谜题 #include iostream#include stringusing namespace std;struct node\tbool flag;\tstring name; nums[100001];int main() int n, m, a, s; cin n m; for (int i = 0; i n; i++) cin nums[i].flag nums[i].name;\tint start = 0;\tfor (int i = 0; i m; i++) cin a s; if (nums[start].flag ^ a) start = (start + s) % n; else start = (start - s + n) % n; cout nums[start].name; return 0; P1042 乒乓球 #include iostream#include string#include vector#include mapusing namespace std;vectorpairint, int res1, res2;int main() string str;\tint a = 0, b = 0, c = 0, d = 0;\tbool flag = true; while (flag getline(cin, str)) for (auto ch: str) if (ch == W) a++; c++; if (a = 11 a - b = 2) res1.push_back(a, b); a = 0; b = 0; if (c = 21 c - d = 2) res2.push_back(c, d); c = 0; d = 0; else if (ch == L) b++; d++; if (b = 11 b - a = 2) res1.push_back(a, b); a = 0; b = 0; if (d = 21 d - c = 2) res2.push_back(c, d); c = 0; d = 0; else if (ch == E) flag = false; break; if (a || b) res1.push_back(a, b);\telse res1.push_back(0, 0);\tif (c || d) res2.push_back(c, d);\telse res2.push_back(0, 0);\tfor (auto it: res1) cout it.first : it.second endl;\tcout endl;\tfor (auto it: res2) cout it.first : it.second endl; return 0; P1179 数字统计 #include iostreamusing namespace std;int main() int l, r, res = 0;\tcin l r;\tfor (int i = l; i = r; i++) int t = i; while (t 1) if (t % 10 == 2) res++; t /= 10; cout res; return 0; P2615 神奇的幻方 #include iostreamusing namespace std;int nums[40][40];int main() int n;\tcin n;\tnums[0][n/2] = 1;\tfor (int i = 2; i = n * n; i++) bool flag = false; int j = 0, k = 0; for (j = 0; j n; j++) for (k = 0; k n; k++) if (nums[j][k] == i - 1) flag = true; break; if (flag) break; if (j == 0 k != n-1) nums[n-1][k+1] = i; if (j != 0 k == n-1) nums[j-1][0] = i; if (j == 0 k == n-1) nums[1][k] = i; if (j != 0 k != n-1) if (nums[j-1][k+1]) nums[j+1][k] = i; else nums[j-1][k+1] = i; for (int i = 0; i n; i++) for (int j = 0; j n; j++) cout nums[i][j]; if (j != n - 1) cout ; else cout endl; return 0; P3952 时间复杂度 #include iostream#include stringusing namespace std;bool st[101][256], isin[101];int main() int t, n, com;\tstring O, x, y;\tchar op, val;\tcin t;\tfor (int i = 0; i t; i++) fill(st[0], st[0] + 101 * 256, false); fill(isin, isin + 101, false); bool flag = true, flag2 = true; cin n O; if (O[2] == 1) com = 0; else com = stoi(O.substr(4)); int cnt = 0, maxn = 0, cur = 0; for (int i = 0; i n; i++) cin op; if (op == F) cnt++; cin val x y; for (int j = 0; j cnt; j++) if (st[j][val]) flag = false; break; st[cnt][val] = true; if (x != n y == n ) bool flag3 = true; cur++; for (int j = 0; j cnt; j++) if (isin[j]) flag3 = false; break; if (flag3) maxn = max(maxn, cur); else if (x == n y != n || x != n y != n stoi(x) stoi(y)) isin[cnt] = true; else if (op == E) isin[cnt] = false; for (int i = 0; i 256; i++) st[cnt][i] = false; cnt--; if (cnt 0) flag = false; cnt = 0; cur--; if (cur 0) cur = 0; if (!flag || cnt != 0) cout ERR endl; else if (maxn == com) cout Yes endl; else cout No endl; return 0; 排序算法 通过排序，我们可以将数据有序化，这让我们对数据的处理方便了很多。 P1177 【模板】快速排序 #include iostream#include algorithmusing namespace std;int nums[100001];void quick_sort(int l, int r) if (l = r) return;\tint i = l - 1, j = r + 1, t = nums[l + r 1];\twhile (i j) do i++; while (nums[i] t); do j--; while (nums[j] t); if (i j) swap(nums[i], nums[j]); quick_sort(l, j);\tquick_sort(j + 1, r);int main() int n;\tcin n;\tfor (int i = 0; i n; i++) cin nums[i];\tquick_sort(0, n - 1);\tfor (int i = 0; i n; i++) cout nums[i] ; return 0; P1059 明明的随机数 #include iostream#include setusing namespace std;setint nums;int main() int n, x;\tcin n;\tfor (int i = 0; i n; i++) cin x; nums.insert(x); cout nums.size() endl;\tfor (auto it: nums) cout it ; return 0; P1068 分数线划定 #include iostream#include algorithmusing namespace std;struct node\tint num, score; nums[5001];bool cmp(node a, node b) if (a.score != b.score) return a.score b.score;\treturn a.num b.num;int main() int n, m;\tcin n m;\tfor (int i = 0; i n; i++) cin nums[i].num nums[i].score;\tsort(nums, nums + n, cmp);\tint t = m * 1.5;\twhile (t n) if (nums[t].score == nums[t-1].score) t++; else break; cout nums[t - 1].score t endl;\tfor (int i = 0; i t; i++) cout nums[i].num nums[i].score endl; return 0; P1051 谁拿了最多奖学金 #include iostream#include string#include algorithmusing namespace std;struct node\tstring name;\tint score1, score2, paper, money;\tchar ganbu, poor; nums[101];bool cmp(const node a, const node b) return a.money b.money;int main() int n, sum = 0;\tcin n;\tfor (int i = 0; i n; i++) int money = 0; cin nums[i].name nums[i].score1 nums[i].score2 nums[i].ganbu nums[i].poor nums[i].paper; if (nums[i].score1 80 nums[i].paper = 1) money += 8000; if (nums[i].score1 85 nums[i].score2 80) money += 4000; if (nums[i].score1 90) money += 2000; if (nums[i].score1 85 nums[i].poor == Y) money += 1000; if (nums[i].score2 80 nums[i].ganbu == Y) money += 850; nums[i].money = money; sum += money; stable_sort(nums, nums + n, cmp);\tcout nums[0].name nums[0].money sum; return 0; P1309 瑞士轮 #include iostream#include algorithmusing namespace std;struct node\tint num, v, score; nums[200001], a[100001], b[100001];bool cmp(const node a, const node b) if (a.score != b.score) return a.score b.score;\telse return a.num b.num;int n;void merge() int id = 0, i = 0, j = 0;\twhile (i n j n) if (a[i].score b[j].score || a[i].score == b[j].score a[i].num b[j].num) nums[id++] = a[i++]; else nums[id++] = b[j++]; while (i n) nums[id++] = a[i++];\twhile (j n) nums[id++] = b[j++];int main() int r, q;\tscanf(%d %d %d, n, r, q);\tfor (int i = 0; i 2 * n; i++) scanf(%d, nums[i].score); nums[i].num = i + 1; for (int i = 0; i 2 * n; i++) scanf(%d, nums[i].v);\tsort(nums, nums + 2 * n, cmp);\tfor (int i = 0; i r; i++) int t = 0; for (int j = 0; j 2 * n; j += 2) if (nums[j].v nums[j+1].v) nums[j].score++; a[t] = nums[j]; b[t++] = nums[j+1]; else nums[j+1].score++; a[t] = nums[j+1]; b[t++] = nums[j]; merge(); printf(%d, nums[q - 1].num); return 0; P1908 逆序对 #include iostream#include vectorusing namespace std;int nums[500001];long long res;void merge_sort(int l, int r) if (l = r) return;\tint mid = l + r 1;\tmerge_sort(l, mid);\tmerge_sort(mid + 1, r);\tvectorint t;\tint i = l, j = mid + 1;\twhile (i = mid j = r) if (nums[i] = nums[j]) t.push_back(nums[i++]); else res += mid - i + 1; t.push_back(nums[j++]); while (i = mid) t.push_back(nums[i++]);\twhile (j = r) t.push_back(nums[j++]);\tfor (int k = l; k = r; k++) nums[k] = t[k - l];int main() int n;\tcin n;\tfor (int i = 0; i n; i++) cin nums[i]; merge_sort(0, n - 1);\tcout res;\treturn 0; 二分答案 对一个满足单调性质的问题，我们可以采用二分答案的方法来解决。 P1024 一元三次方程求解 #include iostreamusing namespace std;double a, b, c, d, nums[201];double f(double x) return a * x * x * x + b * x * x + c * x + d;void check(double l, double r, bool flag) while (r - l 1e-6) double mid = (l + r) / 2; if (flag) if (f(mid) 0) r = mid; else l = mid; else if (f(mid) 0) r = mid; else l = mid; printf(%.2f , l);int main() cin a b c d;\tdouble i = -100;\tbool flag = false, flag2 = true;\tif (f(-100) 0) flag = true;\twhile (i = 100) if (flag2) if (f(i) * f(-100) 0) check(i - 0.5, i, flag); flag2 = false; else if (f(i) * f(-100) 0) check(i - 0.5, i, !flag); flag2 = true; i += 0.5; return 0; P2678 跳石头 #include iostreamusing namespace std;int l, n, m, nums[50005], res;bool check(int x) int cnt = 0, now = 0;\tfor (int i = 1; i = n+1; i++) if (nums[i] - nums[now] x) cnt++; else now = i; if (cnt m) return false;\treturn true;int main() cin l n m;\tfor (int i = 1; i = n; i++) cin nums[i];\tnums[n+1] = l;\tint i = 1, j = l;\twhile (i j) int mid = i + j + 1 1; if (check(mid)) i = mid; else j = mid - 1; cout i;\treturn 0; P1902 刺杀大使 dfs #include iostream#include cstringusing namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = -1, 1, 0, 0, dy[4] = 0, 0, -1, 1;bool visit[1005][1005], flag;void dfs(int a, int b) if (a == n - 1) flag = true; return; for (int i = 0; i 4; i++) x = a + dx[i], y = b + dy[i]; if (x = 0 x n y = 0 y m !visit[x][y] g[x][y] = mid) visit[x][y] = true; dfs(x, y); visit[x][y] = false; if (flag) return; bool check() flag = false;\tmemset(visit, false, sizeof(visit));\tdfs(0, 0);\treturn flag;int main() cin n m;\tint l = 1000, r = 0;\tfor (int i = 0; i n; i++) for (int j = 0; j m; j++) scanf(%d, g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); while (l r) mid = l + r 1; if (check()) r = mid; else l = mid + 1; cout r;\treturn 0; bfs #include iostream#include cstring#include queueusing namespace std;int g[1005][1005], n, m, mid, x, y;int dx[4] = -1, 1, 0, 0, dy[4] = 0, 0, -1, 1;bool visit[1005][1005];bool bfs() memset(visit, false, sizeof(visit));\tqueuepairint, int q;\tq.push(0, 0);\twhile (!q.empty()) int a = q.front().first, b = q.front().second; q.pop(); for (int i = 0; i 4; i++) x = a + dx[i], y = b + dy[i]; if (x = 0 x n y = 0 y m !visit[x][y] g[x][y] = mid) q.push(x, y); visit[x][y] = true; if (x == n - 1) return true; return false;int main() cin n m;\tint l = 1000, r = 0;\tfor (int i = 0; i n; i++) for (int j = 0; j m; j++) scanf(%d, g[i][j]); l = min(l, g[i][j]); r = max(r, g[i][j]); while (l r) mid = l + r 1; if (bfs()) r = mid; else l = mid + 1; cout r;\treturn 0; P1314 聪明的质监员 #include iostreamusing namespace std;typedef long long LL;LL s, res = 1e12, t;int n, m, w[200005], v[200005], sums[200005], cnts[200005], q[200005][2], mid;bool check() t = 0;\tfor (int i = 1; i = n; i++) if (w[i-1] = mid) sums[i] = sums[i-1] + v[i-1]; cnts[i] = cnts[i-1] + 1; else sums[i] = sums[i-1]; cnts[i] = cnts[i-1]; for (int k = 0; k m; k++) int l = q[k][0], r = q[k][1]; t += (cnts[r] - cnts[l-1]) * (sums[r] - sums[l-1]); res = min(res, abs(t-s));\tif (t s) return true;\treturn false;int main() cin n m s;\tfor (int i = 0; i n; i++) cin w[i] v[i];\tfor (int i = 0; i m; i++) cin q[i][0] q[i][1];\tint l = 1, r = 1e6;\twhile (l r) mid = l + r 1; if (check()) l = mid + 1; else r = mid; cout res endl;\treturn 0; P1083 借教室 #include iostreamusing namespace std;long long n, m, w[1000005], d[1000005], s[1000006], t[1000005], diff[1000005], nums[1000005], mid;bool check() fill(diff, diff + 1000005, 0);\tfor (int i = 1; i = mid; i++) diff[s[i]] += d[i]; diff[t[i] + 1] -= d[i]; for (int i = 1; i = n; i++) nums[i] = nums[i - 1] + diff[i]; if (nums[i] w[i]) return false; return true;int main() cin n m;\tfor (int i = 1; i = n; i++) cin w[i];\tfor (int i = 1; i = m; i++) cin d[i] s[i] t[i];\tint l = 1, r = n + 1;\twhile (l r) mid = l + r 1; if (check()) l = mid + 1; else r = mid; if (r n) cout 0;\telse cout -1 l endl;\treturn 0; P4343 自动刷题机 #include iostreamusing namespace std;typedef long long LL;LL n, m, mid, nums[100005];LL check() LL cnt = 0, t = 0;\tfor (int i = 0; i n; i++) t += nums[i]; t = maxLL(0, t); if (t = mid) t = 0; cnt++; return cnt;int main() cin n m;\tfor (int i = 0; i n; i++) cin nums[i];\tLL l = 1, r = 1e18;\twhile (l r) mid = l + r 1; if (check() m) l = mid + 1; else r = mid; mid = l;\tif (check() != m) cout -1; return 0; cout l ;\tr = 1e18;\twhile (l r) mid = l + r + 1 1; if (check() m) r = mid - 1; else l = mid; cout r;\treturn 0; 分治 分治，即分而治之，将大问题分解为小问题，分别求解，最后合并结果。 P1226 快速幂||取余运算 #include iostreamusing namespace std;typedef long long LL;LL qmi(int a, int b, int p) LL res = 1, t = a;\twhile (b) if (b 1) res = (res * t) % p; t = (t * t) % p; b = 1; res %= p;\treturn res;int main() LL a, b, p; cin a b p; printf(%d^%d mod %d=%d, a, b, p, qmi(a, b, p)); return 0; P1010 幂次方 #include iostreamusing namespace std;void fun(int x) while (x = 1) int t = 1, cnt = 0; do t *= 2; cnt++; while (x = t); int a = cnt - 1; if (a == 0) cout 2(0); else if (a == 1) cout 2; else cout 2(; fun(a); cout ); x -= t / 2; if (x != 0) cout +;\tint main() int n; cin n; fun(n); return 0; P1429 平面最近点对（加强版） #include iostream#include vector#include algorithm#include cmathusing namespace std;typedef long long LL;vectorvectorLL nums;bool cmp(vectorLL a, vectorLL b) return a[2] b[2];int main() int n, a, b; cin n; for (int i = 0; i n; i++) cin a b; nums.push_back(a, b, a + b); sort(nums.begin(), nums.end(), cmp);\tLL res = 1e12;\tfor (int i = 1; i n; i++) for (int k = 1; k 5; k++) int j = i - k; if (j 0) break; res = min((nums[i][0] - nums[j][0]) * (nums[i][0] - nums[j][0]) + (nums[i][1] - nums[j][1]) * (nums[i][1] - nums[j][1]), res); printf(%.4f, sqrt(res)); return 0; P3612 Secret Cow Code #include iostream#include stringusing namespace std;typedef long long LL;int main() string str; LL n, i; cin str n; while (n str.size()) i = str.size(); while (n i) i *= 2; i /= 2; n -= (i + 1); if (n == 0) n = i; cout n endl; cout str[n - 1]; return 0; 贪心 贪心，指的是决策时都采取当前最优解的算法。有的时候，这样做确实可以获得最优解。 P1208 Mixing Milk #include iostream#include vector#include algorithm#include mapusing namespace std;typedef pairint, int PII;PII nums[5005];int main() int n, m, price, cnt; cin n m; for (int i = 0; i m; i++) cin nums[i].first nums[i].second;\tsort(nums, nums + m);\tint res = 0, id = 0;\twhile (n 0) if (n = nums[id].second) res += nums[id].first * nums[id].second; n -= nums[id].second; else res += n * nums[id].first; n = 0; id++; cout res; return 0; P4995 跳跳！ #include iostream#include algorithmusing namespace std;typedef long long LL;int nums[305];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i];\tsort(nums, nums + n);\tLL res = 0;\tint l = 0, r = n - 1, cur = 0;\twhile (l r) res += (nums[r] - cur) * (nums[r] - cur); cur = nums[r--]; if (l == r) res += (nums[r] - cur) * (nums[r] - cur);; break; res += (nums[l] - cur) * (nums[l] - cur); cur = nums[l++]; if (l == r) res += (nums[l] - cur) * (nums[l] - cur);; break; cout res; return 0; P1094 纪念品分组 #include iostream#include algorithmusing namespace std;int nums[30005];int main() int w, n; cin w n; for (int i = 0; i n; i++) cin nums[i];\tsort(nums, nums + n);\tint res = 0, l = 0, r = n - 1;\twhile (l = r) if (nums[r] + nums[l] w) res++; r--; else res++; r--; l++; cout res; return 0; P1199 三国游戏 #include iostream#include algorithmusing namespace std;struct node\tint val, row, col; nums[250005];bool st[505], you[505];int res;bool cmp(node a, node b) return a.val b.val;void dfs(int x) if (nums[x].val res) return;\tif (you[nums[x].row] !st[nums[x].col] || you[nums[x].col] !st[nums[x].row]) res = max(res, nums[x].val); return; if (!st[nums[x].row]) st[nums[x].col] = true; st[nums[x].row] = true; you[nums[x].row] = true; dfs(x - 1); st[nums[x].col] = false; st[nums[x].row] = false; you[nums[x].row] = false; if (!st[nums[x].col]) st[nums[x].row] = true; st[nums[x].col] = true; you[nums[x].col] = true; dfs(x - 1); st[nums[x].row] = false; st[nums[x].col] = false; you[nums[x].col] = false;\tint main() int n, id = 0; cin n; for (int i = 1; i = n; i++) for (int j = i + 1; j = n; j++) cin nums[id].val; nums[id].row = i; nums[id++].col = j; sort(nums, nums + id, cmp); dfs(id - 1); cout 1 res; return 0; P2672 推销员 #include iostream#include algorithmusing namespace std;int n, sum[100005], q[100005], h[100005];struct node int dist, fatigue; v[100005];bool cmp(node a, node b) return a.fatigue b.fatigue;int main() int n; cin n; for (int i = 1; i = n; i++) cin v[i].dist; for (int i = 1; i = n; i++) cin v[i].fatigue; sort(v + 1, v + 1 + n, cmp); for (int i = 1; i = n; i++) sum[i] = sum[i - 1] + v[i].fatigue; for (int i = 1; i = n; i++) q[i] = max(q[i - 1], 2 * v[i].dist); for (int i = n; i = 1; i--) h[i] = max(h[i + 1], 2 * v[i].dist + v[i].fatigue); for (int i = 1; i = n; i++) cout max(sum[i] + q[i], sum[i - 1] + h[i]) endl; return 0; P1080 国王游戏 没有用高精度（60分） #include iostream#include algorithmusing namespace std;typedef long long LL;struct node int l, r;\tdouble t; v[10005];bool cmp(node a, node b) return a.l * a.r b.l * b.r;int main() LL n, a, b; cin n a b; for (int i = 0; i n; i++) cin v[i].l v[i].r; v[i].t = (double)v[i].l / v[i].r; sort(v, v + n, cmp); LL res = 0, cur = a; for (int i = 0; i n; i++) res = max(res, (LL)a / v[i].r); a *= v[i].l; cout res; return 0; 构造 构造题是一种形式灵活多样的题型。正是因为这个特点，使得构造题没有一种通用的方法。 P5595 歌唱比赛 #include iostream#include string#include algorithmusing namespace std;int main() string str, res1 = , res2 = ; cin str; int cnt = 0; for (int i = 0; i str.size(); i++) if (str[i] == Z) for (int j = i + 1; j str.size(); j++) if (str[j] != Z) cout -1; return 0; break; for (int i = str.size() - 1; i = 0; i--) if (str[i] == Z) res1 += 0; res2 += 0; else if (str[i] == Y) res1 += 0; res2 += 1; else if (str[i] == X) res1 += 1; res2 += 0; reverse(res1.begin(), res1.end());\treverse(res2.begin(), res2.end());\tcout res1 res2; return 0; 高精度 在 C++ 中，long long 都无法表示我们需要的整数时怎么办？那就用高精度吧！ P1601 A+B Problem（高精） #include iostream#include string#include algorithmusing namespace std;int main() string a, b, c; cin a b; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); if (a.size() b.size()) swap(a, b); int t = 0, i = 0; for (; i b.size(); i++) c += ((a[i] - 0 + b[i] - 0 + t) % 10) + 0; t = (a[i] - 0 + b[i] - 0 + t) / 10; for (; i a.size(); i++) c += ((a[i] - 0 + t) % 10) + 0; t = (a[i] - 0 + t) / 10; if (t) c += 1;\treverse(c.begin(), c.end());\tcout c; return 0; P2142 高精度减法 #include iostream#include string#include algorithmusing namespace std;int main() string a, b, c; cin a b; if (a == b) cout 0; return 0; if (a.size() b.size()) int e = b.size() - a.size(); for (int i = 0; i e; i++) a = 0 + a; else if (a.size() b.size()) int e = a.size() - b.size(); for (int i = 0; i e; i++) b = 0 + b; for (int i = 0; i a.size(); i++) if (a[i] + 0 b[i] + 0) swap(a, b); cout -; break; else if (a[i] + 0 b[i] + 0) break; reverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i a.size(); i++) int d = a[i] - b[i] - t; if (d 0) c += ((d + 10) % 10) + 0; t = 1; else c += (d % 10) + 0; t = 0; reverse(c.begin(), c.end());\twhile (c[0] == 0) c.erase(c.begin());\tcout c; return 0; P1303 A*B Problem #include iostream#include string#include algorithmusing namespace std;int c[40005];int main() string a, b; cin a b; if (a[0] == 0 || b[0] == 0) cout 0; return 0; reverse(a.begin(), a.end());\treverse(b.begin(), b.end()); int t = 0; for (int i = 0; i b.size(); i++) for (int j = 0; j a.size(); j++) c[i+j] += (a[j] - 0) * (b[i] - 0); for (int i = 0; i a.size() + b.size() - 1; i++) c[i] += t; if (c[i] = 10) t = c[i] / 10; c[i] %= 10; else t = 0; if (t) c[a.size() + b.size() - 1] = t; for (int i = a.size() + b.size() - 1; i = 0; i--) cout c[i]; else for (int i = a.size() + b.size() - 2; i = 0; i--) cout c[i]; return 0; P1480 AB Problem #include iostream#include string#include algorithmusing namespace std;int main() string a, c; int b; cin a b; long long t = 0; for (int i = 0; i a.size(); i++) t = t * 10 + a[i] - 0; c += (t / b) + 0; t -= t / b * b; while (c[0] == 0) c.erase(c.begin()); if (c.size()) cout c; else cout 0; return 0; P1009 阶乘之和 #include iostream#include string#include algorithmusing namespace std;string s[51], fac[51];string mul(string a, int b) string c;\tint t = 0;\treverse(a.begin(), a.end());\tfor (int i = 0; i a.size(); i++) int d = (a[i] - 0) * b + t; c += (d % 10) + 0; if (d = 10) t = d / 10; else t = 0; if (t) string e = to_string(t); reverse(e.begin(), e.end()); c += e; reverse(c.begin(), c.end());\treturn c;string add(string a, string b) string c;\tint t = 0, i = 0;\treverse(a.begin(), a.end());\treverse(b.begin(), b.end());\tfor (; i a.size(); i++) int d = a[i] - 0 + b[i] - 0 + t; c += (d % 10) + 0; if (d = 10) t = 1; else t = 0; for (; i b.size(); i++) int d = b[i] - 0 + t; c += (d % 10) + 0; if (d = 10) t = 1; else t = 0; if (t) c += 1;\treverse(c.begin(), c.end());\treturn c;int main() int n; cin n; s[1] = fac[1] = 1; for (int i = 2; i = n; i++) fac[i] = mul(fac[i - 1], i); s[i] = add(s[i - 1], fac[i]); cout s[n]; return 0; 前缀和 差分 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，而差分则是一种和前缀和相对的策略。 P3131 Subsequences Summing to Sevens 暴力（96分） #include iostreamusing namespace std;typedef long long LL;LL sums[50005];int main() int n, x; cin n; for (int i = 1; i = n; i++) cin x; sums[i] = sums[i - 1] + x; int res = 0;\tfor (int i = 1; i = n - res; i++) for (int j = i + res; j = n; j++) if ((sums[j] - sums[i - 1]) % 7 == 0) res = j - i + 1; cout res; return 0; 技巧 #include iostreamusing namespace std;int sums[50005], l[7], r[7];int main() int n, x; cin n; for (int i = 1; i = n; i++) cin x; sums[i] = (sums[i - 1] + x) % 7; for (int i = n; i = 1; i--) l[sums[i]] = i;\tl[0] = 0;\tfor (int i = 1; i = n; i++) r[sums[i]] = i;\tint res = 0;\tfor (int i = 0; i 7; i++) res = max(res, r[i] - l[i]);\tcout res; return 0; P1387 最大正方形 dp #include iostreamusing namespace std;int g[105][105], dp[105][105];int main() int n, m, res = 0; cin n m; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) cin g[i][j]; if (g[i][j] != 0) dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; res = max(res, dp[i][j]); cout res; return 0; 前缀和+二分 #include iostreamusing namespace std;int g[105][105] = 0, dp[105][105];int main() int n, m, x, res = 0; cin n m; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) cin x; g[i][j] = g[i-1][j] + g[i][j-1] - g[i-1][j-1] + x; for (int i = 1; i = n; i++) for (int j = 1; j = m; j++) int l = 0, r = min(n, m); while (l r) int mid = l + r + 1 1; if (i + mid n || j + mid m || g[i + mid][j+mid] - g[i+mid][j] - g[i][j+mid] + g[i][j] mid * mid) r = mid - 1; else l = mid; if (g[i+r][j+r] - g[i+r][j] - g[i][j+r] + g[i][j] == r*r) res = max(res, r); cout res; return 0; P3397 地毯 #include iostreamusing namespace std;int g[1005][1005], res[1005][1005];int main() int n, m, x1, y1, x2, y2; cin n m; for (int i = 0; i m; i++) cin x1 y1 x2 y2; g[x1][y1] += 1; g[x2+1][y1] -= 1; g[x1][y2+1] -= 1; g[x2+1][y2+1] += 1; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) g[i][j] += g[i-1][j] + g[i][j-1] - g[i-1][j-1]; cout g[i][j]; if (j n) cout ; else cout endl; return 0; P2280 激光炸弹 #include iostreamusing namespace std;int g[5005][5005], res;int main() int n, m, x, y, v; cin n m; for (int i = 0; i n; i++) cin x y v; g[x+1][y+1] += v; for (int i = 1; i 5005; i++) for (int j = 1; j 5005; j++) g[i][j] += g[i][j - 1] + g[i - 1][j] - g[i - 1][j - 1]; for (int i = m; i 5005; i++) for (int j = m; j 5005; j++) res = max(res, g[i][j] - g[i][j - m] - g[i - m][j] + g[i - m][j - m]); cout res; return 0; P4552 IncDec Sequence #include iostreamusing namespace std;typedef long long LL;int a[100005];int main() int n; cin n; for (int i = 1; i = n; i++) cin a[i]; LL p = 0, q = 0;\tfor (int i = 2; i = n; i++) int c = a[i] - a[i - 1]; if (c 0) p += c; else q -= c; LL res1 = max(p, q);\tLL res2 = abs(p - q) + 1;\tcout res1 res2; return 0; 搜索 搜索其实就是高级的枚举，很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。 深度优先搜索 深度优先搜索（DFS），即按照深度优先的顺序搜索的算法。 深度优先搜索一般使用栈来实现。 P1219 八皇后 #include iostream#include vectorusing namespace std;bool col[14], dg[28], udg[28];int n, cnt = 0;vectorint res;void dfs(int u) if (u == n) if (cnt 3) for (int i = 0; i n; i++) cout res[i] ; cout endl; cnt++; return; for (int i = 0; i n; i++) if (!col[i] !dg[u + i] !udg[n - u + i]) col[i] = dg[u + i] = udg[n - u + i] = true; if (cnt 3) res.push_back(i + 1); dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; if (cnt 3) res.pop_back(); int main() cin n;\tdfs(0);\tcout cnt; return 0; P1019 单词接龙 #include iostream#include vector#include string #include mapusing namespace std;int n, res;mapstring, int st;string strs[21], str;void dfs(string t) res = max(res, (int)t.size());\tfor (int i = 0; i n; i++) if (st[strs[i]] 0) int size = min(t.size(), strs[i].size()); for (int k = 1; k size; k++) bool flag = true; for (int p = 1; p = k; p++) if (t[t.size() - p] != strs[i][k - p]) flag = false; break; if (flag) st[strs[i]]--; dfs(t + strs[i].substr(k)); st[strs[i]]++; break; int main() cin n;\tfor (int i = 0; i n; i++) cin str; st[str] = 2; strs[i] = str; cin str;\tfor (int i = 0; i n; i++) if (str[0] == strs[i][0]) st[strs[i]]--; dfs(strs[i]); st[strs[i]]++; cout res; return 0; P5194 USACO05DEC]Scales P5440 【XR-2】奇迹 P1378 油滴扩展 广度优先搜索 广度优先搜索（BFS），即优先扩展浅层节点，逐渐深入的搜索算法。 广度优先搜索一般使用队列来实现。 P1162 填涂颜色 #include iostream#include vector#include queue#include mapusing namespace std;typedef pairint, int PII;bool visit[32][32];int g[32][32], n;int dx[5] = 0, 0, 1, -1, 0;int dy[5] = 1, -1, 0, 0, 0;vectorPII res;bool bfs(int x, int y) queuePII q;\tq.push(x, y);\tbool flag = true;\twhile (!q.empty()) auto u = q.front(); q.pop(); x = u.first, y = u.second; res.push_back(x, y); for (int i = 0; i 5; i++) int a = x + dx[i], b = y + dy[i]; if (a = 1 a = n b = 1 b = n !visit[a][b] g[a][b] == 0) if ((a == 1 || a == n || b == 1 || b == n) g[a][b] == 0) flag = false; visit[a][b] = true; q.push(a, b); return flag;int main() cin n;\tfor (int i = 1; i = n; i++) for (int j = 1; j = n; j++) cin g[i][j]; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) if (!visit[i][j] g[i][j] == 0) res.clear(); if (bfs(i, j)) for (int k = 0; k res.size(); k++) g[res[k].first][res[k].second] = 2; for (int i = 1; i = n; i++) for (int j = 1; j = n; j++) cout g[i][j] ; cout endl; return 0; P1443 马的遍历 P3956 棋盘 P1032 字串变换 P1126 机器人搬重物 记忆化搜索 通过将已经遍历的状态记录下来，从而减少重复的搜索量，这就是记忆化搜索。 动态规划的时候，记忆化搜索也是一种高效简洁的实现方式。 P1514 引水入城 P1535 游荡的奶牛 [P1434 SHOI2002]滑雪 P3953 逛公园 搜索的剪枝 对于一些不必要搜索的部分，我们可以避免访问这些状态，从而提高搜索效率。 P1120 小木棍 ［数据加强版］ P1312 Mayan游戏 P1074 靶形数独 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。 P1216 数字三角形 P1020 导弹拦截 P1091 合唱队形 P1095 守望者的逃离 P1541 乌龟棋 P1868 饥饿的奶牛 P2679 子串 P2501 HAOI2006]数字序列 P3336 ZJOI2013]话旧 P3558 POI2013]BAJ-Bytecomputer P4158 SCOI2009]粉刷匠 P5301 GXOIGZOI2019]宝牌一大堆 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。 P1048 采药 P1060 开心的金明 P1855 榨取kkksc03 P5020 货币系统 P1757 通天之分组背包 P1064 金明的预算方案 P2946 USACO09MAR]Cow Frisbee Team P1156 垃圾陷阱 P5322 BJOI2019]排兵布阵 P5289 十二省联考2019]皮配 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。 P1880 NOI1995]石子合并 P3146 USACO16OPEN]248 P1063 能量项链 P1005 矩阵取数游戏 P4170 CQOI2007]涂色 P4302 SCOI2003]字符串折叠 P2466 SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。 因为树的递归性质，树形动态规划一般都是递归求解的。 P1352 没有上司的舞会 P1040 加分二叉树 P1122 最大子树和 P1273 有线电视网 P2014 选课 P2585 ZJOI2006]三色二叉树 P3047 USACO12FEB]Nearby Cows P3698 CQOI2017]小Q的棋盘 P5658 括号树 P2607 ZJOI2008]骑士 P3177 HAOI2015]树上染色 P4395 BOI2003]Gem P4516 JSOI2018]潜入行动 字符串 字符串问题有很多自己的特点。 字符串哈希 字符串哈希通过牺牲很小的准确率，达到快速进行字符串匹配的效果。 P3370 【模板】字符串哈希 P5270 无论怎样神树大人都会删库跑路 P5537 【XR-3】系统设计 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。 P3375 【模板】KMP字符串匹配 P4391 BOI2009]Radio Transmission P3435 POI2006]OKR-Periods of Words P4824 USACO15FEB]Censoring (Silver) P2375 NOI2014]动物园 P3426 POI2005]SZA-Template P3193 HNOI2008]GT考试 数学 OI 中的数学知识很多，也有些杂乱。 位运算 将十进制整数转换为二进制后，有很多按位运算的运算符。 如果能善于利用位运算的一些性质，往往能达到事半功倍的效果。 P5657 格雷码 P5514 MtOI2019永夜的报应 P5538 【XR-3】NamidAme P5539 【XR-3】Unknown Mother-Goose P5523 yLOI2019珍珠 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。 素数 素数，指的是除 1 和它本身之外没有其他约数的数。 P4718 【模板】Pollard-Rho算法 P1075 质因数分解 P2441 角色属性树 P5535 【XR-3】小道消息 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。 求解两个数的最大公约数，可以采用欧几里得算法解决。 P5435 【模板】快速 GCD P5436 【XR-2】缘分 P1029 最大公约数和最小公倍数问题 P1414 又是毕业季II P2152 SDOI2009]SuperGCD P1072 Hankson 的趣味题 欧拉函数 欧拉函数 表示了小于 的数字中，与 互质的数字个数。 P2158 SDOI2008仪仗队 P2568 GCD P2398 GCD SUM P4139 上帝与集合的正确用法 同余方程 求解同余方程往往可以引出不少话题。 线性同余方程乘法逆元 线性同余方程是同余方程中最基础的内容。 P4549 【模板】裴蜀定理 P2613 【模板】有理数取余 P3811 【模板】乘法逆元 P5431 【模板】乘法逆元2 P1082 同余方程 P3951 小凯的疑惑 P1516 青蛙的约会 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。 P4777 【模板】扩展中国剩余定理（EXCRT） P3868 TJOI2009]猜数字 P2480 SDOI2010]古代猪文 P4774 NOI2018]屠龙勇士 P5345 【XR-1】快乐肥宅 高次同余方程 BSGS 算法可以高效计算离散对数。 而高次剩余的求解更加复杂，其中二次剩余作为高次剩余中比较特殊的情况，可以使用 Cipolla 法求解。 P4195 【模板】exBSGS P5491 【模板】二次剩余 P3306 SDOI2013]随机数生成器 P2485 SDOI2011]计算器 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 P2197 【模板】nim游戏 P1288 取数游戏II P1290 欧几里德的游戏 P1247 取火柴游戏 P2252 取石子游戏 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。 P5104 红包发红包 P1850 换教室 P3830 SHOI2012]随机树 P4564 CTSC2018]假面 P2473 SCOI2008]奖励关 P2221 HAOI2012]高速公路 P3239 HNOI2015]亚瑟王 P3750 六省联考2017]分手是祝愿 P4284 SHOI2014]概率充电器 P5249 LnOI2019]加特林轮盘赌 P2081 NOI2012]迷失游乐园 P3343 ZJOI2015]地震后的幻想乡 P3600 随机数生成器 P5326 ZJOI2019]开关 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。 P1996 约瑟夫问题 P1160 队列安排 栈 栈，是一种后进先出（FILO）的数据结构。 P1449 后缀表达式 P1739 表达式括号匹配 P1981 表达式求值 P1175 表达式的转换 队列 队列，是一种先进先出（FIFO）的数据结构。 P1540 机器翻译 并查集 并查集常用于处理一些不相交集合的合并和查询问题。 P1111 修复公路 P3958 奶酪 P1525 关押罪犯 P4185 USACO18JAN MooTube G P2024 NOI2001食物链 P1197 JSOI2008星球大战 P1196 NOI2002银河英雄传说 P1955 NOI2015程序自动分析 Part 7.5 二叉堆 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。 P3378 【模板】堆 P1090 合并果子 P1168 中位数 P2085 最小函数值 P2827 蚯蚓 P3045 USACO12FEB Cow Coupons Part 7.6 ST表 ST表可以离线查询区间最值。 P3865 【模板】ST表 P2251 质量检测 P1816 忠诚 P1198 JSOI2008最大数 P2880 USACO07JAN Balanced Lineup P5012 水の数列 P5344 【XR-1】逛森林 P2048 NOI2010 超级钢琴 Part 7.7 树状数组 树状数组是一种简洁高效的树形数据结构。 P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 P1908 逆序对 P1966 火柴排队 P3605 USACO17JAN Promotion Counting P1972 SDOI2009 HH的项链 P3586 POI2015 LOG P4054 JSOI2009计数问题 P4113 HEOI2012采花 P3960 列队 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。 P3372 【模板】线段树 1 P3373 【模板】线段树 2 P5490 【模板】扫描线 P4588 TJOI2018数学计算 P1502 窗口的星星 P2471 SCOI2007降雨量 P2824 HEOI2016TJOI2016排序 P3722 AH2017HNOI2017影魔 P4097 HEOI2013Segment P4198 楼房重建 P4513 小白逛公园 P4556 Vani有约会雨天的尾巴 P5324 BJOI2019删数 P5327 ZJOI2019语言 图论 图论是数学的一个分支，它以图为研究的对象。 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。 P2661 信息传递 P2921 USACO08DEC Trick or Treat on the Farm 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。 P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） P5905 【模板】Johnson 全源最短路 P1144 最短路计数 P1462 通往奥格瑞玛的道路 P1522 Cow Tours P1266 速度限制 P4001 ICPC-Beijing 2006狼抓兔子 P4568 JLOI2011 飞行路线 P3238 HNOI2014 道路堵塞 P5304 GXOIGZOI2019 旅行者 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。 P1087 FBI树 P1030 求先序排列 P1305 新二叉树 P1229 遍历问题 P5018 对称二叉树 P5597 【XR-4】复读 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。 计算树的直径，可以通过两遍 DFS 解决。 P2195 HXY造公园 P3629 APIO2010 巡逻 P5536 【XR-3】核心城市 P1099 树网的核 P4408 NOI2003逃学的小孩 公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。 P3379 【模板】最近公共祖先（LCA） P3938 斐波那契 P4281 AHOI2008 紧急集合 聚会 生成树 用 条边将图上的 个点连接起来，形成的树就被称为生成树。 P3366 【模板】最小生成树 [P4180 【模板】严格次小生成树BJWC2010] [P2872 USACO07DEC]Building Roads P1991 无线通讯网 P1967 货车运输 [P4047 JSOI2010]部落划分 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。 P1113 杂务 P1983 车站分级 P1038 神经网络 差分约束 差分约束要解决的问题是：求出一组 元不等式的一组解，使得所有约束关系都能得到满足。 P5960 【模板】差分约束算法 [P3275 SCOI2011]糖果 [P2294 HNOI2005]狡猾的商人 [P4926 1007]倍杀测量者 P5590 赛车游戏 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。 P3387 【模板】缩点 P3388 【模板】割点（割顶） [P2341 HAOI2006]受欢迎的牛 [P2863 USACO06JAN]The Cow Prom [P2746 USACO5.3]Network of Schools [P1407 国家集训队]稳定婚姻 [P2272 ZJOI2007]最大半连通子图 [P3225 HNOI2012]矿场搭建 [P5058 ZJOI2004]嗅探器 [P2515 HAOI2010]软件安装","tags":["算法","C++","洛谷"],"categories":["算法"]},{"title":"力扣Hot100","path":"/2024/09/09/力扣Hot100/","content":"力扣Hot100哈希两数之和class Solution public: vectorint twoSum(vectorint nums, int target) unordered_mapint, int st; for (int i = 0; i nums.size(); i++) if (st.find(target - nums[i]) != st.end()) return i, st[target - nums[i]]; else st[nums[i]] = i; return ; ; 字母异位词分组class Solution public: vectorvectorstring groupAnagrams(vectorstring strs) unordered_mapstring, vectorstring st; for (int i = 0; i strs.size(); i++) string t = strs[i]; sort(strs[i].begin(), strs[i].end()); st[strs[i]].push_back(t); vectorvectorstring res; for (auto it: st) res.push_back(it.second); return res; ; 最长连续序列排序 class Solution public: int longestConsecutive(vectorint nums) sort(nums.begin(), nums.end()); int res = 0; for (int i = 0; i nums.size();) int t = 1; while (i nums.size() - 1) if (nums[i] == nums[i + 1]) i++; else if (nums[i] == nums[i + 1] - 1) t++; i++; else break; if (t == 1) i++; res = max(res, t); return res; ; 哈希 class Solution public: int longestConsecutive(vectorint nums) unordered_setint sets; for (auto num: nums) sets.insert(num); int res = 0; for (auto num: sets) if (!sets.count(num - 1)) int cur = num, t = 1; while (sets.count(cur + 1)) cur++; t++; res = max(res, t); return res; ; 双指针移动零class Solution public: void moveZeroes(vectorint nums) int l = 0, r = 0, n = nums.size(); while (r n) if (nums[r]) swap(nums[l], nums[r]); l++; r++; ; 盛最多水的容器class Solution public: int maxArea(vectorint height) int l = 0, r = height.size()-1; int res = 0; while (l r) int t = min(height[l], height[r]) * (r - l); res = max(res, t); if (height[l] = height[r]) l++; else r--; return res; ; 三数之和暴力 class Solution public: vectorvectorint threeSum(vectorint nums) unordered_mapint, int st; vectorvectorint res; sort(nums.begin(), nums.end()); for (int i = 0; i nums.size(); i++) st[nums[i]] = i; for (int i = 0; i nums.size(); i++) if (i != 0 nums[i] == nums[i-1]) continue; for (int j = i + 1; j nums.size(); j++) if (j != i + 1 nums[j] == nums[j-1]) continue; if (st[-nums[i] - nums[j]] i st[-nums[i] - nums[j]] j) res.push_back(nums[i], nums[j], -nums[i] - nums[j]); return res; ; 双指针 class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint res; int n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i n - 2; i++) if (i != 0 nums[i] == nums[i-1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] 0) continue; int j = i + 1, k = n - 1; while (j k) int s = nums[i] + nums[j] + nums[k]; if (s 0) k--; else if (s 0) j++; else res.push_back(nums[i], nums[j++], nums[k--]); while(j k nums[j] == nums[j - 1]) j++; while(j k nums[k] == nums[k + 1]) k--; return res; ; 滑动窗口无重复字符的最长子串class Solution public: int lengthOfLongestSubstring(string s) int nums[128]; int i = 0, j = 0, res = 0; while (j s.size()) nums[s[j]]++; while (nums[s[j]] 1) nums[s[i++]]--; res = max(res, j - i + 1); j++; return res; ; 找到字符串中所有字母异位词class Solution public: vectorint findAnagrams(string s, string p) int l = 0, r = 0, valid = 0; unordered_mapchar, int need, window; vectorint res; for (char ch: p) need[ch]++; while (r s.size()) char c = s[r++]; if (need.count(c)) window[c]++; if (window[c] == need[c]) valid++; while (r - l = p.size()) if (valid == need.size()) res.push_back(l); char d = s[l++]; if (need.count(d)) if (window[d] == need[d]) valid--; window[d]--; return res; ; 字串和为 K 的子数组class Solution public: int subarraySum(vectorint nums, int k) int res = 0, s[20005]; for (int i = 0; i nums.size(); i++) s[i + 1] = s[i] + nums[i]; unordered_mapint, int cnt; for (int i = 0; i = nums.size(); i++) if (cnt.contains(s[i] - k)) res += cnt[s[i] - k]; cnt[s[i]]++; return res; ; 滑动窗口最大值优先队列 class Solution public: vectorint maxSlidingWindow(vectorint nums, int k) int n = nums.size(); priority_queuepairint, int q; for (int i = 0; i k; i++) q.push(nums[i], i); vectorint res = q.top().first; for (int i = k; i n; i++) q.push(nums[i], i); while (q.top().second = i - k) q.pop(); res.push_back(q.top().first); return res; ; 单调队列 class Solution public: vectorint maxSlidingWindow(vectorint nums, int k) int n = nums.size(); dequeint q; vectorint res; int l = 0; for (int i = 0; i k; i++) while (!q.empty() nums[i] = nums[q.back()]) q.pop_back(); q.push_back(i); res.push_back(nums[q.front()]); for (int i = k; i n; i++) while (!q.empty() nums[i] = nums[q.back()]) q.pop_back(); q.push_back(i); while (q.front() = i - k) q.pop_front(); res.push_back(nums[q.front()]); return res; ; 普通数组最大子数组和动态规划 class Solution public: int maxSubArray(vectorint nums) int dp[100005], res = -0x3f3f3f3f; dp[0] = nums[0]; for (int i = 1; i nums.size(); i++) dp[i] = max(nums[i], dp[i - 1] + nums[i]); for (int i = 0; i nums.size(); i++) res = max(res, dp[i]); return res; ; 合并区间class Solution public: vectorvectorint merge(vectorvectorint intervals) sort(intervals.begin(), intervals.end()); vectorvectorint res; for (int i = 0; i intervals.size();) int t = intervals[i][1]; int j = i + 1; while (j intervals.size() intervals[j][0] = t) t = max(t, intervals[j][1]); j++; res.push_back(intervals[i][0], t); i = j; ; return res; ; 轮转数组class Solution public: void rotate(vectorint nums, int k) int t[100005], size = nums.size(); for (int i = 0; i size; i++) t[(i + k) % size] = nums[i]; for (int i = 0; i size; i++) nums[i] = t[i]; ; 矩阵矩阵置零class Solution public: void setZeroes(vectorvectorint matrix) int row[205], col[205], n = matrix.size(), m = matrix[0].size(); for (int i = 0; i n; i++) for (int j = 0; j m; j++) if (matrix[i][j] == 0) row[i] = 1; col[j] = 1; for (int i = 0; i n; i++) for (int j = 0; j m; j++) if (row[i] || col[j]) matrix[i][j] = 0; ; 螺旋矩阵class Solution public: vectorint spiralOrder(vectorvectorint matrix) int n = matrix.size(), m = matrix[0].size(); int l = 0, r = m - 1, u = 0, d = n - 1; vectorint res; while (true) for (int i = l; i = r; i++) res.push_back(matrix[u][i]); u++; if (u d) break; for (int i = u; i = d; i++) res.push_back(matrix[i][r]); r--; if (l r) break; for (int i = r; i = l; i--) res.push_back(matrix[d][i]); d--; if (u d) break; for (int i = d; i = u; i--) res.push_back(matrix[i][l]); l++; if (l r) break; return res; ; 链表二叉树图论回溯二分查找35. 搜索插入位置class Solution public: int searchInsert(vectorint nums, int target) int l = 0, r = nums.size() - 1; while(l r) int mid = l + r 1; if (nums[mid] target) l = mid + 1; else r = mid; if (l == nums.size() - 1 nums[l] target) return l + 1; else return l; ; 74. 搜索二维矩阵class Solution public: bool searchMatrix(vectorvectorint matrix, int target) int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n - 1; while (l r) int mid = l + r 1; if (matrix[mid].back() target) l = mid + 1; else r = mid; int t = l; l = 0, r = m - 1; while (l r) int mid = l + r 1; if (matrix[t][mid] target) l = mid + 1; else r = mid; return matrix[t][l] == target; ; 34. 在排序数组中查找元素的第一个和最后一个位置class Solution public: vectorint searchRange(vectorint nums, int target) vectorint res; if (nums.empty()) res.push_back(-1); res.push_back(-1); return res; int n = nums.size(); int l = 0, r = n - 1; while (l r) int mid = l + r 1; if (nums[mid] target) l = mid + 1; else r = mid; if (nums[l] == target) res.push_back(l); else res.push_back(-1); l = 0, r = n - 1; while (l r) int mid = l + r + 1 1; if (nums[mid] target) r = mid - 1; else l = mid; if (nums[r] == target) res.push_back(l); else res.push_back(-1); return res; ; 33. 搜索旋转排序数组class Solution public: int search(vectorint nums, int target) int n = nums.size(); int l = 0, r = n - 1; while (l = r) int mid = l + r 1; if (target == nums[mid]) return mid; else if (nums[mid] nums[r]) if (nums[mid] target nums[r] = target) l = mid + 1; else r = mid - 1; else if (nums[mid] target nums[l] = target) r = mid - 1; else l = mid + 1; return -1; ; 栈堆贪心算法121. 买卖股票的最佳时机class Solution public: int maxProfit(vectorint prices) int t = prices[0], res = 0; for (int i = 0; i prices.size(); i++) t = min(t, prices[i]); res = max(res, prices[i] - t); return res; ; 55. 跳跃游戏class Solution public: bool canJump(vectorint nums) int dp[10005] = 0; dp[0] = nums[0]; for (int i = 1; i nums.size(); i++) if (dp[i - 1] = 0) return false; dp[i] = max(dp[i - 1] - 1, nums[i]); return true; ; 45. 跳跃游戏 IIclass Solution public: int jump(vectorint nums) int res = 0, end = 0, maxa = 0; for (int i = 0; i nums.size() - 1; i++) maxa = max(nums[i] + i, maxa); if (i == end) end = maxa; res++; return res; ; 763. 划分字母区间class Solution public: vectorint partitionLabels(string s) int last[26], n = s.size(); for (int i = 0; i n; i++) last[s[i] - a] = i; vectorint res; int start = 0, end = 0; for (int i = 0; i n; i++) end = max(end, last[s[i] - a]); if (i == end) res.push_back(end - start + 1); start = end + 1; return res; ; 动态规划70. 爬楼梯class Solution public: int climbStairs(int n) int dp[50]; dp[1] = 1; dp[2] = 2; for (int i = 3; i = n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; ; 118. 杨辉三角class Solution public: vectorvectorint generate(int numRows) vectorvectorint res; int dp[31][31]; dp[1][1] = 1; for (int i = 2; i = numRows; i++) for (int j = 1; j = i; j++) dp[i][j] = dp[i-1][j - 1] + dp[i-1][j]; for (int i = 1; i = numRows; i++) vectorint t; for (int j = 1; j = i; j++) t.push_back(dp[i][j]); res.push_back(t); return res; ; 198. 打家劫舍class Solution public: int rob(vectorint nums) int dp[105], res; if (nums.size() == 1) res = nums[0]; else if (nums.size() == 2) res = max(nums[0], nums[1]); else dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i nums.size(); i++) dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); res = dp[nums.size() - 1]; return res; ; 279. 完全平方数class Solution public: int numSquares(int n) vectorint f(n + 1); for (int i = 1; i = n; i++) int minn = INT_MAX; for (int j = 1; j * j = i; j++) minn = min(minn, f[i - j * j]); f[i] = minn + 1; return f[n]; ; 322. 零钱兑换class Solution public: int coinChange(vectorint coins, int amount) int dp[10005]; fill(dp, dp + amount + 1, 10005); dp[0] = 0; for (int i = 1; i = amount; i++) for (int j = 0; j coins.size(); j++) if (i - coins[j] = 0) dp[i] = min(dp[i], dp[i - coins[j]] + 1); if (dp[amount] == 10005) return -1; else return dp[amount]; ; 139. 单词拆分class Solution public: bool wordBreak(string s, vectorstring wordDict) vectorbool dp(s.size() + 1); dp[0] = true; for (int i = 1; i = s.size(); i++) for (auto word: wordDict) int sz = word.size(); if (i - sz = 0 s.substr(i - sz, sz) == word) dp[i] = dp[i] || dp[i - sz]; return dp[s.size()]; ; 多维动态规划62. 不同路径class Solution public: int uniquePaths(int m, int n) int dp[m][n]; for (int i = 0; i m; i++) dp[i][0] = 1; for (int i = 0; i n; i++) dp[0][i] = 1; for (int i = 1; i m; i++) for (int j = 1; j n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; ; 64. 最小路径和 class Solution public: int minPathSum(vectorvectorint grid) int dp[205][205], n = grid.size(), m = grid[0].size(); for (int i = 1; i = m; i++) dp[1][i] = dp[1][i - 1] + grid[0][i - 1]; for (int i = 1; i = n; i++) dp[i][1] = dp[i - 1][1] + grid[i - 1][0]; for (int i = 2; i = n; i++) for (int j = 2; j = m; j++) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; return dp[n][m]; ; 技巧","tags":["算法","LeetCode","C++"],"categories":["算法"]},{"title":"PAT 甲级","path":"/2024/08/30/PAT甲级/","content":"1001 A+B Format#include iostream#include stringusing namespace std;int main() int a, b; cin a b; int c = a + b; if (c 0) cout -; c = -c; if (c = 1000) string t = to_string(c); int d = t.size() % 3; if(d) cout t.substr(0, d) ,; for (int i = d; i t.size(); i += 3) cout t.substr(i, 3); if (i + 3 t.size()) cout ,; else cout c; return 0; 柳婼的 #include iostream#include stringusing namespace std;int main() int a, b; cin a b; string s = to_string(a + b); int len = s.length(); for (int i = 0; i len; i++) cout s[i]; if (s[i] == -) continue; if ((i + 1) % 3 == len % 3 i != len - 1) cout ,; return 0; 1002 A+B for Polynomials#include iostreamusing namespace std;const int N = 1001;double nums[N];int main() int n, a; double b; cin n; for (int i = 0; i n; i++) cin a b; nums[a] = b; cin n; for (int i = 0; i n; i++) cin a b; nums[a] += b; int cnt = 0; for (int i = 1000; i = 0; i--) if (nums[i]) cnt++; cout cnt; for (int i = 1000; i = 0; i--) if (nums[i]) printf( %d %.1f, i, nums[i]); return 0; 1003 Emergency#include iostream#include vector#include map#include algorithmusing namespace std;typedef pairint, int PII;const int N = 501;const int INF = 0x3f3f3f3f;int vals[N], d[N], num[N], val[N];bool visit[N];vectorPII g[N];void djkstra(int s, int n) fill(d, d + N, INF); d[s] = 0; val[s] = vals[s]; num[s] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; num[v] = num[u]; val[v] = val[u] + vals[v]; else if (d[u] + dis == d[v]) num[v] = num[v] + num[u]; val[v] = max(val[v], val[u] + vals[v]); int main() int n, m, c1, c2, u, v, w; cin n m c1 c2; for (int i = 0; i n; i++) cin vals[i]; for (int i = 0; i m; i++) cin u v w; g[u].push_back(v, w); g[v].push_back(u, w); djkstra(c1, n); cout num[c2] val[c2]; return 0; 1004 Counting Leavesbfs #include iostream#include queue#include vectorusing namespace std;vectorint trees[101];void bfs(int u) queueint q; q.push(u); while (!q.empty()) int len = q.size(); int t = 0; while (len--) u = q.front(); q.pop(); for (int i = 0; i trees[u].size(); i++) q.push(trees[u][i]); if (trees[u].empty()) t++; cout t; if (!q.empty()) cout ; int main() int n, m, id1, k, id2; cin n m; for (int i = 0; i m; i++) cin id1 k; for (int j = 0; j k; j++) cin id2; trees[id1].push_back(id2); bfs(1); return 0; dfs #include iostream#include queue#include vector#include algorithmusing namespace std;vectorint trees[101];int res[101], maxdepth;void dfs(int u, int depth) if (trees[u].size() == 0) res[depth]++; maxdepth = max(maxdepth, depth); for (int i = 0; i trees[u].size(); i++) dfs(trees[u][i], depth + 1); int main() int n, m, id1, k, id2; cin n m; for (int i = 0; i m; i++) cin id1 k; for (int j = 0; j k; j++) cin id2; trees[id1].push_back(id2); dfs(1, 0); for (int i = 0; i = maxdepth; i++) cout res[i]; if (i maxdepth) cout ; return 0; 1005 Spell It Right#include iostream#include stringusing namespace std;int main() string str; cin str; string words[10] = zero, one, two, three, four, five, six, seven, eight, nine; int res = 0; for (int i = 0; i str.length(); i++) res += str[i] - 0; string res2 = to_string(res); for (int i = 0; i res2.length(); i++) cout words[res2[i] - 0]; if (i res2.length() - 1) cout ; return 0; 1006 Sign In and Sign Out#include iostream#include stringusing namespace std;int main() int n; cin n; string name, start, end, res1_name, res1_start = 23:59:59, res2_name, res2_end = 00:00:00; for (int i = 0; i n; i++) cin name start end; if (start res1_start) res1_name = name; res1_start = start; if (end res2_end) res2_name = name; res2_end = end; cout res1_name res2_name; return 0; 1007 Maximum Subsequence Sum#include iostreamusing namespace std;const int INF = 0x3f3f3f3f;int nums[10001], dp[10001];int main() int n; cin n; fill(dp, dp + n, -INF); for (int i = 0; i n; i++) cin nums[i]; dp[0] = nums[0]; for (int i = 1; i n; i++) dp[i] = max(dp[i - 1] + nums[i], nums[i]); int res = -INF, start = 0, end = n - 1, t = 0; for (int i = 0; i n; i++) if (res dp[i]) res = dp[i]; end = i; if (res == 0) start = end; else if (res 0) for (int i = end; i = 0; i--) if (t res) t += nums[i]; start = i; else res = 0; start = 0; end = n - 1; cout res nums[start] nums[end]; return 0; 柳婼的 #include iostreamusing namespace std;int nums[100001];int main() int n; cin n; int left = 0, right = n - 1, res = -1, temp = 0, tempindex = 0; for (int i = 0; i n; i++) cin nums[i]; temp = temp + nums[i]; if (temp 0) temp = 0; tempindex = i + 1; else if (temp res) res = temp; left = tempindex; right = i; if (res 0) res = 0; cout res nums[left] nums[right]; return 0; 1008 Elevator#include iostreamusing namespace std;int main() int n, pre = 0, now, res = 0; cin n; for (int i = 0; i n; i++) cin now; if (now pre) res += (now - pre) * 6 + 5; else res += (pre - now) * 4 + 5; pre = now; cout res; return 0; 1009 Product of Polynomials#include iostreamusing namespace std;const int N = 1001;double nums[N], res[N * N];int main() int k, a, cnt = 0; double b; cin k; for (int i = 0; i k; i++) cin a b; nums[a] = b; cin k; for (int i = 0; i k; i++) cin a b; for (int j = 0; j N; j++) res[a + j] += b * nums[j]; for (int i = 0; i N * N; i++) if (res[i]) cnt++; cout cnt; for (int i = N * N - 1; i = 0; i--) if (res[i]) printf( %d %.1f, i, res[i]); return 0; 1010 Radix#include iostream#include string#include algorithm#include cmathusing namespace std;typedef long long LL;LL convert(string s, int k) LL sum = 0, idx = 0; for (int i = s.length() - 1; i = 0; i--) int t = isdigit(s[i]) ? s[i] - 0 : s[i] - a + 10; sum += t * pow(k, idx++); return sum;LL find(string s, LL num) char maxt = *max_element(s.begin(), s.end()); LL low = isdigit(maxt) ? maxt - 0 + 1 : maxt - a + 11; LL high = max(low, num); while (low = high) LL mid = low + high 1; LL t = convert(s, mid); if (t 0 | t num) high = mid - 1; else if (t == num) return mid; else low = mid + 1; return -1;int main() string n1, n2; int tag, radix, res; cin n1 n2 tag radix; if (tag == 1) res = find(n2, convert(n1, radix)); else res = find(n1, convert(n2, radix)); if (res == -1) cout Impossible; else cout res; return 0; 1011 World Cup Betting#include iostreamusing namespace std;double fun(double a, double b, double c) double res = 1; if (b = a b = c) cout T ; res *= b; else if (a = b a = c) cout W ; res *= a; else cout L ; res *= c; return res;int main() double a, b, c; double res = 1; for (int i = 0; i 3; i++) cin a b c; res *= fun(a * 0.65, b, c); printf(%.2f, 2 * (res - 1)); return 0; 1012 The Best Rank#include iostream#include algorithmusing namespace std;struct student int num, c, m, e; double a; student(int _num, int _c, int _m, int _e, double _a) num = _num, c = _c, m = _m, e = _e, a = _a; student(); nums[2000];bool cmp_a(student a, student b) return a.a b.a;bool cmp_c(student a, student b) return a.c b.c;bool cmp_m(student a, student b) return a.m b.m;bool cmp_e(student a, student b) return a.e b.e;int A[1000000], C[1000000], M[1000000], E[1000000];bool isin[1000000];int main() int n, m, num, c1, m1, e1; cin n m; for (int i = 0; i n; i++) cin num c1 m1 e1; double a1 = (c1 + m1 + e1) / 3.0; nums[i] = student(num, c1, m1, e1, a1); isin[num] = true; int idx = 1; sort(nums, nums + 2000, cmp_a); A[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].a == nums[i - 1].a) A[nums[i].num] = idx; else A[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_c); C[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].c == nums[i - 1].c) C[nums[i].num] = idx; else C[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_m); M[nums[0].num] = idx; for (int i = 1; i n; i++) if (nums[i].m == nums[i - 1].m) M[nums[i].num] = idx; else M[nums[i].num] = i + 1; idx = i + 1; idx = 1; sort(nums, nums + 2000, cmp_e); E[nums[0].num] = idx; for (int i = 0; i n; i++) if (nums[i].e == nums[i - 1].e) E[nums[i].num] = idx; else E[nums[i].num] = i + 1; idx = i + 1; for (int i = 0; i m; i++) cin num; if (isin[num]) int res_rank = n, res_sub; if (res_rank A[num]) res_rank = A[num]; res_sub = A; if (res_rank C[num]) res_rank = C[num]; res_sub = C; if (res_rank M[num]) res_rank = M[num]; res_sub = M; if (res_rank E[num]) res_rank = E[num]; res_sub = E; printf(%d %c , res_rank, res_sub); else cout N/A endl; return 0; 柳婼的 #include iostream#include algorithmusing namespace std;struct node int id, best; int score[4], rank[4]; stu[2001];int hashtable[1000000], flag;bool cmp(node a, node b) return a.score[flag] b.score[flag];int main() int n, m, id; cin n m; for (int i = 0; i n; i++) cin stu[i].id stu[i].score[1] stu[i].score[2] stu[i].score[3]; stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0 + 0.5; for (flag = 0; flag = 3; flag++) sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int i = 1; i n; i++) stu[i].rank[flag] = i + 1; if (stu[i].score[flag] == stu[i - 1].score[flag]) stu[i].rank[flag] = stu[i - 1].rank[flag]; for (int i = 0; i n; i++) hashtable[stu[i].id] = i + 1; stu[i].best = 0; int minn = stu[i].rank[0]; for (int j = 1; j = 3; j++) if (stu[i].rank[j] minn) minn = stu[i].rank[j]; stu[i].best = j; char c[5] = ACME; for (int i = 0; i m; i++) cin id; if (hashtable[id]) int best = stu[hashtable[id] - 1].best; printf(%d %c , stu[hashtable[id] - 1].rank[best], c[best]); else cout N/A ; return 0; 1013 Battle Over Cities并查集 #include iostream#include setusing namespace std;const int N = 1001;int g[N][N], fa[N];int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];int main() int n, m, k, u, v, x; cin n m k; for (int i = 0; i m; i++) cin u v; g[u][v] = g[v][u] = 1; for (int i = 0; i k; i++) cin x; for (int j = 1; j = n; j++) fa[j] = j; for (int j = 1; j = n; j++) for (int k = j + 1; k = n; k++) if (j == x || k == x) continue; if (g[j][k] == 1 find(j) != find(k)) fa[find(j)] = find(k); setint res; for (int j = 1; j = n; j++) res.insert(find(j)); cout res.size() - 2 endl; return 0; 柳婼的（dfs） #include iostream#include setusing namespace std;const int N = 1001;int g[N][N], n;bool visit[N];void dfs(int x) visit[x] = true; for (int i = 1; i = n; i++) if (g[i][x] !visit[i]) dfs(i); int main() int m, k, u, v, x; cin n m k; for (int i = 0; i m; i++) cin u v; g[u][v] = g[v][u] = 1; for (int i = 0; i k; i++) fill(visit, visit + N, false); cin x; visit[x] = true; int cnt = 0; for (int i = 1; i = n; i++) if (!visit[i]) dfs(i); cnt++; cout cnt - 1 endl; return 0; 1014 Waiting in Line大模拟（queue） #include iostream#include vector#include queueusing namespace std;struct node int poptime, endtime; queueint q;;int main() int n, m, k, q, idx = 1; cin n m k q; vectorint time(k + 1), res(k + 1); for (int i = 1; i = k; i++) cin time[i]; vectornode win(n + 1); vectorbool sorry(k + 1, false); for (int i = 1; i = m; i++) for (int j = 1; j = n; j++) if (idx = k) win[j].q.push(time[idx]); if (win[j].endtime = 540) sorry[idx] = true; win[j].endtime += time[idx]; if (i == 1) win[j].poptime = win[j].endtime; res[idx] = win[j].endtime; idx++; while (idx = k) int tmin = win[1].poptime, twin = 1; for (int i = 2; i = n; i++) if (win[i].poptime tmin) twin = i; tmin = win[i].poptime; win[twin].q.pop(); win[twin].q.push(time[idx]); win[twin].poptime += win[twin].q.front(); if (win[twin].endtime = 540) sorry[idx] = true; win[twin].endtime += time[idx]; res[idx] = win[twin].endtime; idx++; for (int i = 1; i = q; i++) int query, minute; cin query; minute = res[query]; if (sorry[query]) cout Sorry endl; else printf(%02d:%02d , (minute + 480) / 60, minute % 60); return 0; 1015 Reversible Primes#include iostream#include string#include cmathusing namespace std;const int N = 100001;bool st[N];int convert1(string s, int k) int sum = 0, idx = 0; for (int i = s.size() - 1; i = 0; i--) sum += (s[i] - 0) * pow(k, idx++); return sum;string convert2(int n, int k) string res; while (n) res.push_back(n % k + 0); n /= k; return res;int main() for (int i = 2; i N; i++) if (!st[i]) for (int j = i + i; j N; j += i) st[j] = true; st[0] = st[1] = true; int a, b; while (cin a) if (a 0) break; cin b; int t = convert1(convert2(a, b), b); if (!st[t] !st[a]) cout Yes endl; else cout No endl; return 0; 柳婼的 #include iostream#include cmathusing namespace std;bool isprime(int n) if (n = 1) return false; for (int i = 2; i = int(sqrt(n * 1.0)); i++) if (n % i == 0) return false; return true;int main() int a, b; while (cin a) if (a 0) break; cin b; if (!isprime(a)) cout No endl; continue; int len = 0, arr[100]; do arr[len++] = a % b; a /= b; while(a != 0); for (int i = 0; i len; i++) a = a * b + arr[i]; if (isprime(a)) cout Yes endl; else cout No endl; return 0; 1016 Phone Bills大模拟 #include iostream#include map#include vector#include algorithmusing namespace std;struct node string time, tag; node (string _time, string _tag) time = _time, tag = _tag; ;mapstring, vectornode mp;bool cmp(node a, node b) return a.time b.time;int price[25] = 0, n;double count2(string time) int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = price[hour] * min + price[24] * 60 * day; for (int i = 0; i hour; i++) res += price[i] * 60; return res / 100.0;int count1(string time) int res = 0, day = stoi(time.substr(0,2)), hour = stoi(time.substr(3, 2)), min = stoi(time.substr(6, 2)); res = day * 24 * 60 + hour * 60 + min; return res;int main() for (int i = 0; i 24; i++) cin price[i]; price[24] += price[i]; cin n; string name, time, tag, month; for (int i = 0; i n; i++) cin name time tag; month = time.substr(0, 2); mp[name].push_back(node(time.substr(3, 8), tag)); for (auto i = mp.begin(); i != mp.end(); i++) vectornode nodes = i-second; sort(nodes.begin(), nodes.end(), cmp); double money = 0; int idx = 0, minute; string start, end; vectorstring times; for (int i = 0; i nodes.size() - 1; i++) if (nodes[i].tag == on-line nodes[i + 1].tag == off-line) times.push_back(nodes[i].time); times.push_back(nodes[i + 1].time); if (times.size() 0) cout i-first month endl; for (int i = 0; i times.size(); i += 2) string start = times[i], end = times[i + 1]; minute = count1(end) - count1(start); double t = count2(end) - count2(start); money += t; printf(%s %s %d $%.2f , start.c_str(), end.c_str(), minute, t); printf(Total amount: $%.2f , money); return 0; 柳婼的 #include iostream#include map#include vector#include algorithmusing namespace std;struct node string name; int status, month, time, day, hour, minute;;bool cmp(node a, node b) return a.name != b.name ? a.name b.name : a.time b.time;int rate[25], n;double count(node a) double res = rate[a.hour] * a.minute + rate[24] * 60 * a.day; for (int i = 0; i a.hour; i++) res += rate[i] * 60; return res / 100.0;int main() for (int i = 0; i 24; i++) cin rate[i]; rate[24] += rate[i]; cin n; vectornode data(n); for (int i = 0; i n; i++) cin data[i].name; scanf(%d:%d:%d:%d, data[i].month, data[i].day, data[i].hour, data[i].minute); string tmp; cin tmp; data[i].status = (tmp == on-line) ? 1 : 0; data[i].time = data[i].day * 24 * 60 + data[i].hour * 60 + data[i].minute; sort(data.begin(), data.end(), cmp); mapstring, vectornode custom; for (int i = 1; i n; i++) if (data[i].name == data[i - 1].name data[i - 1].status == 1 data[i].status == 0) custom[data[i - 1].name].push_back(data[i - 1]); custom[data[i].name].push_back(data[i]); for (auto it: custom) vectornode tmp = it.second; printf(%s %02d , it.first.c_str(), tmp[0].month); double res = 0; for (int i = 1; i tmp.size(); i += 2) double t = count(tmp[i]) - count(tmp[i - 1]); printf(%02d:%02d:%02d %02d:%02d:%02d %d $%.2f , tmp[i - 1].day, tmp[i - 1].hour, tmp[i - 1].minute, tmp[i].day, tmp[i].hour, tmp[i].minute, tmp[i].time - tmp[i - 1].time, t); res += t; printf(Total amount: $%.2f , res); return 0; 1017 Queueing at Bank#include iostream#include map#include algorithmusing namespace std;typedef pairint, int PII;int main() int n, k, p, hour, minute, second, idx = 0, res = 0; cin n k; vectorPII nums; vectorint v(k); for (int i = 0; i n; i++) scanf(%d:%d:%d %d, hour, minute, second, p); int t = hour * 3600 + minute * 60 + second; if (t 61200) continue; nums.push_back(t, p * 60); sort(nums.begin(), nums.end()); n = nums.size(); for (int j = 0; j min(n, k); j++) if (nums[idx].first 28800) v[j] = 28800; res += 28800 - nums[idx].first; else v[j] = nums[idx].first; v[j] += nums[idx].second; idx++; while (idx n) int tmin = v[0], twin = 0; for (int i = 1; i k; i++) if (tmin v[i]) tmin = v[i]; twin = i; if (v[twin] nums[idx].first) res += v[twin] - nums[idx].first; else v[twin] = nums[idx].first; v[twin] += nums[idx].second; idx++; printf(%.1f, res / 60.0 / n); return 0; 柳婼的 #include iostream#include queue#include algorithmusing namespace std;const int maxn = 10005;struct person int come, time; p[maxn];int cmp(person p1, person p2) return p1.come p2.come;int n, k, cnt, total;int main() cin n k; for (int i = 0; i n; i++) int hh, ss, mm, tt; scanf(%d:%d:%d %d, hh, mm, ss, tt); int sum = hh * 3600 + mm * 60 + ss; if (sum 61200) continue; p[++cnt].time = tt * 60; p[cnt].come = sum; sort(p + 1, p + 1 + cnt, cmp); priority_queueint, vectorint, greaterint q; for (int i = 1; i = k; i++) q.push(28800); for (int i = 1; i = cnt; i++) cout i endl; if (q.top() = p[i].come) q.push(p[i].come + p[i].time); else total += q.top() - p[i].come; q.push(q.top() + p[i].time); q.pop(); if (!cnt) cout 0.0 endl; else printf(%.1f, total / 60.0 / cnt); return 0; 1018 Public Bike Managementdijkstra #include iostream#include vector#include map#include iostreamusing namespace std;typedef pairint, int PII;const int N = 501;const int INF = 0x3f3f3f3f;bool visit[N];int d[N], weight[N], n, minNeed = INF, minBack = INF;vectorPII g[N];vectorint pre[N], path, tmppath;void dijkstra(int x) fill(d, d + N, INF); d[x] = 0; for (int i = 0; i = n; i++) int u = -1, mind = INF; for (int j = 0; j = n; j++) if (!visit[j] mind d[j]) mind = d[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); else if(d[u] + dis == d[v]) pre[v].push_back(u); void dfs(int v) tmppath.push_back(v); if (v == 0) int need = 0, back = 0; for (int i = tmppath.size() - 1; i = 0; i--) int idx = tmppath[i]; if (weight[idx] 0) back += weight[idx]; else if (back -weight[idx]) back += weight[idx]; else need += (-weight[idx] - back); back = 0; if (need minNeed) minNeed = need; minBack = back; path = tmppath; else if (need == minNeed back minBack) minBack = back; path = tmppath; tmppath.pop_back(); return; for (int i = 0; i pre[v].size(); i++) dfs(pre[v][i]); tmppath.pop_back();int main() int c, s, m, u, v, w; cin c n s m; for (int i = 1; i = n; i++) cin weight[i]; weight[i] = weight[i] - c / 2; for (int i = 0; i m; i++) cin u v w; g[u].push_back(v, w); g[v].push_back(u, w); dijkstra(0); dfs(s); cout minNeed 0; for (int i = path.size() - 2; i = 0; i--) cout - path[i]; cout minBack; return 0; 1019 General Palindromic Number#include iostream#include vectorusing namespace std;int main() int n, k; cin n k; vectorint str; while (n) str.push_back(n % k); n /= k; vectorint str2(str.rbegin(), str.rend()); if (str == str2) cout Yes endl; else cout No endl; for (int i = 0; i str2.size(); i++) cout str2[i]; if (i str2.size() - 1) cout ; return 0; 1020 Tree Traversals#include iostream#include queueusing namespace std;const int N = 31;int post[N], in[N];struct node int l, r; trees[N];int build(int postl, int postr, int inl, int inr) if (postl postr) return -1; int root = post[postr], idx; for (int i = inl; i = inr; i++) if (root == in[i]) idx = i; break; int cntl = idx - inl; trees[root].l = build(postl, postl + cntl - 1, inl, idx - 1); trees[root].r = build(postl + cntl, postr - 1, idx + 1, inr); return root;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); q.pop(); cout u; if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (!q.empty()) cout ; int main() int n; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); return 0; 柳婼的 #include iostream#include mapusing namespace std;const int N = 31;int post[N], in[N];mapint, int level;void pre(int root, int start, int end, int idx) if (start end) return; int i = start; while (i end in[i] != post[root]) i++; level[idx] = post[root]; pre(root - 1 - end + i, start, i - 1, 2 * idx + 1); pre(root - 1, i + 1, end, 2 * idx + 2);int main() int n; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; pre(n - 1, 0, n - 1, 0); for (auto i = level.begin(); i != level.end(); i++) cout i-second; if (next(i) != level.end()) cout ; return 0; 1021 Deepest Root#include iostream#include vector#include setusing namespace std;int n, maxh = 0;vectorint g[10010], tmp;bool visit[10010];setint s;void dfs(int node, int height) if (maxh height) maxh = height; tmp.clear(); tmp.push_back(node); else if (maxh == height) tmp.push_back(node); visit[node] = true; for (int i = 0; i g[node].size(); i++) if (!visit[g[node][i]]) dfs(g[node][i], height + 1); int main() int n, u, v, cnt = 0, s1 = 0; cin n; for (int i = 0; i n - 1; i++) cin u v; g[u].push_back(v); g[v].push_back(u); for (int i = 1; i = n; i++) if (!visit[i]) dfs(i, 1); if (i == 1) if (!tmp.empty()) s1 = tmp[0]; for (int j = 0; j tmp.size(); j++) s.insert(tmp[j]); cnt++; if (cnt 1) cout Error: cnt components; else tmp.clear(); fill(visit, visit + 10010, false); maxh = 0; dfs(s1, 1); for (int i = 0; i tmp.size(); i++) s.insert(tmp[i]); for (auto it = s.begin(); it != s.end(); it++) cout *it endl; return 0; 1022 Digital Library#include iostream#include vector#include string#include algorithmusing namespace std;struct book string num, title, auther, publisher, year; vectorstring keys; books[10001];bool cmp(book a, book b) return a.num b.num;int main() int n, m, q; string key, query; scanf(%d , n); for (int i = 0; i n; i++) getline(cin, books[i].num); getline(cin, books[i].title); getline(cin, books[i].auther); while (cin key) books[i].keys.push_back(key); char c = getchar(); if (c == ) break; getline(cin, books[i].publisher); getline(cin, books[i].year); sort(books, books + n, cmp); cin m; for (int i = 0; i m; i++) bool flag = false; scanf(%d: , q); getline(cin, query); cout q : query endl; for (int i = 0; i n; i++) if (q == 1 books[i].title == query) cout books[i].num endl; flag = true; else if (q == 2 books[i].auther == query) cout books[i].num endl; flag = true; else if (q == 3) for (int j = 0; j books[i].keys.size(); j++) if (query == books[i].keys[j]) cout books[i].num endl; flag = true; else if (q == 4 books[i].publisher == query) cout books[i].num endl; flag = true; else if (q == 5 books[i].year == query) cout books[i].num endl; flag = true; if (!flag) cout Not Found endl; return 0; 柳婼的 #include iostream#include map#include setusing namespace std;mapstring, setint title, author, key, pub, year;void query(mapstring, setint m, string str) if(m.find(str) != m.end()) for(auto it = m[str].begin(); it != m[str].end(); it++) printf(%07d , *it); else cout Not Found ;int main() int n, m, id, num; scanf(%d, n); string ttitle, tauthor, tkey, tpub, tyear; for(int i = 0; i n; i++) scanf(%d , id); getline(cin, ttitle); title[ttitle].insert(id); getline(cin, tauthor); author[tauthor].insert(id); while(cin tkey) key[tkey].insert(id); char c = getchar(); if(c == ) break; getline(cin, tpub); pub[tpub].insert(id); getline(cin, tyear); year[tyear].insert(id); scanf(%d, m); for(int i = 0; i m; i++) scanf(%d: , num); string temp; getline(cin, temp); cout num : temp ; if(num == 1) query(title, temp); else if(num == 2) query(author, temp); else if(num == 3) query(key, temp); else if(num == 4) query(pub,temp); else if(num ==5) query(year, temp); return 0; 1023 Have Fun with Numbers#include iostream#include string#include algorithmusing namespace std;int nums[10];int main() string a, b = ; cin a; int t = 0; for (int i = a.size() - 1; i = 0; i--) b += ((a[i] - 0) * 2 + t) % 10 + 0; t = ((a[i] - 0) * 2 + t) / 10; if (t) b += t + 0; reverse(b.begin(), b.end()); for (int i = 0; i a.size(); i++) nums[a[i]]++; bool flag = true; for (int i = 0; i b.size(); i++) nums[b[i]]--; if (nums[b[i]] 0) flag = false; break; if (flag) cout Yes endl; else cout No endl; cout b; return 0; 1024 Palindromic Number#include iostream#include string#include algorithmusing namespace std;string add(string a) string b(a.rbegin(), a.rend()), c = ; int t = 0; for (int i = a.size() - 1; i = 0; i--) int sum = a[i] - 0 + b[i] - 0 + t; c += sum % 10 + 0; t = sum / 10; if (t) c += t + 0; reverse(c.begin(), c.end()); return c;bool ispal(string a) string b(a.rbegin(), a.rend()); return a == b;int main() string n; int k; cin n k; for (int i = 0; i k; i++) if (ispal(n)) cout n endl; cout i; return 0; n = add(n); cout n endl; cout k; return 0; 1025 PAT Ranking#include iostream#include string#include vector#include algorithmusing namespace std;struct node1 string num; int score, locnum, locrank;;bool cmp1(node1 a, node1 b) if (a.score == b.score) return a.num b.num; else return a.score b.score; int main() int n, k, score; string num; vectornode1 nums; cin n; for (int i = 1; i = n; i++) cin k; vectornode1 tmp(k); for (int j = 0; j k; j++) cin tmp[j].num tmp[j].score; tmp[j].locnum = i; sort(tmp.begin(), tmp.end(), cmp1); tmp[0].locrank = 1; nums.push_back(tmp[0]); for (int j = 1; j k; j++) if (tmp[j].score != tmp[j - 1].score) tmp[j].locrank = j + 1; else tmp[j].locrank = tmp[j - 1].locrank; nums.push_back(tmp[j]); sort(nums.begin(), nums.end(), cmp1); int rank = 1; cout nums.size() endl; cout nums[0].num rank nums[0].locnum nums[0].locrank endl; for (int i = 1; i nums.size(); i++) if (nums[i].score != nums[i - 1].score) rank = i + 1; cout nums[i].num rank nums[i].locnum nums[i].locrank endl; return 0; 1026 Table Tennis最恶心的大模拟 #include iostream#include algorithm#include vectorusing namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;struct table int endtime, num; bool vip;;struct play int arrive, use, start; // 到达时间，使用时间，开始时间 bool served, vip; // 是否服务，vip?;int cmp1(play a, play b) return a.arrive b.arrive; // 先对数据进行排序，按到达的时间升序int cmp2(play a, play b) return a.start b.start; // 最后输出的时候为什么是8:12:00在8:10:00的前面呢？就是因为是按开始使用的时间升序的vectorplay p;vectortable t;// 找到personid及之后的，并且到达（arrive）时间不晚于before的，未服务的，且为vip的 person-id. 如果没找到,则返回-1int findvip(int personId, int minendtime) for (int i = personId; i p.size() p[i].arrive = minendtime; i++) if (!p[i].served p[i].vip) return i; return -1;// 更新以personId的玩家对，和tableId的桌子的信息// 1、将该玩家对的开始时间赋值为到达时间和可用桌子结束时间中的较大值// 2、将该玩家对的服务状态赋值为以服务过// 3、将桌子的结束时间信息更新为该玩家对的开始时间加该玩家的使用时间// 4、将该桌子服务的玩家数量加一void update(int personid, int tableid) p[personid].start = max(p[personid].arrive, t[tableid].endtime); p[personid].served = 1; t[tableid].endtime = p[personid].start + p[personid].use; t[tableid].num++;int main() int n, m, k, vipnum; scanf(%d, n); for (int i = 0; i n; i++) int h, m, s, use, vip, arrive; scanf(%d:%d:%d %d %d, h, m, s, use, vip); arrive = h * 3600 + m * 60 + s; use = use 120 ? 7200 : use * 60; p.push_back(arrive, use, 0, 0, vip 0); sort(p.begin(), p.end(), cmp1); scanf(%d %d, k, m); for (int i = 0; i k; i++) t.push_back(28800, 0, 0); for (int i = 0; i m; i++) scanf(%d, vipnum); t[vipnum - 1].vip = 1; for (int i = 0; i p.size();) // 找到最先空闲的桌子,如果多个桌子同时空闲，则返回桌子号最小的那个 int minendtime = INF, minendid; for (int j = 0; j k; j++) if (minendtime t[j].endtime) minendtime = t[j].endtime; minendid = j; // 如果最先空闲的桌子空闲的太晚了，或者当前序列中的第一位玩家对达到的时间太晚了，就退出循环 if (minendtime = 75600 || p[i].arrive = 75600) break; // 声明新的变量，personId为经过调整选择后最终的开始使用桌子的玩家对索引，tableId为为经过调整选择后最终的开始被使用的桌子 int personid = i, tableid = minendid; // 如果当前的最早空闲且号最小的桌子空闲时，存在玩家对已经在等待了 if (minendtime = p[i].arrive) // 并且当前的最早空闲且号最小的桌子是vip，寻找是vip的且未服务过的，玩家对到达时间不晚于minEndTime的玩家对索引 if (t[tableid].vip) int vipid = findvip(personid, minendtime); personid = vipid != -1 ? vipid : personid; else if (p[i].vip) // 虽然当前的最早空闲且号最小的桌子不是vip，但是还可能存在同时空闲，桌号更大的桌子是vip for (int j = 0; j k; j++) if (t[j].vip t[j].endtime = p[personid].arrive) tableid = j; break; // 如果当前的桌子非vip，且当前的序列的第一个玩家对非vip，顺序选择即可，换句话说，personId和tableId无需调整 else /* 如果当前的最早空闲的桌子空闲时，没有玩家在等待序列中，即当一个玩家到达时，应该是至少有一个桌子是空闲的 我们总是希望选择空闲中的桌子中桌子号最小的，如果到达了一个vip玩家对，并且存在空闲的vip桌子，我们选择空闲中的vip桌中号最小的 在这里，我们不管是否是vip，先得到空闲中的桌子中桌子号最小的，如果当前到达的玩家对未vip，并且存在空闲的vip桌子， 我们用空闲中的vip桌中号最小的那个桌子覆盖之前得到的tableId */ for (int j = 0; j k; j++) if (t[j].endtime = p[personid].arrive) tableid = j; break; if (p[personid].vip) for (int j = 0; j k; j++) // 尝试寻找空闲的vip桌子并调整tableId，顺序找到即退出得到的就是号码最小的 if (t[j].vip t[j].endtime = p[personid].arrive) tableid = j; break; update(personid, tableid); while (i p.size() p[i].served) i++; sort(p.begin(), p.end(), cmp2); for (int i = 0; i p.size(); i++) if (p[i].served) int wait = p[i].start - p[i].arrive; printf(%02d:%02d:%02d %02d:%02d:%02d %d , p[i].arrive / 3600, p[i].arrive % 3600 / 60, p[i].arrive % 60, p[i].start / 3600, p[i].start % 3600 / 60, p[i].start % 60, (int)(1.0 * wait / 60 + 0.5)); for (int i = 0; i k; i++) if (i != 0) printf( ); printf(%d, t[i].num); return 0; 柳婼的 #include iostream#include vector#include queue#include mapusing namespace std;int n, m, k, H, M, S, t, table, vtable, cnt, now, nowt, T[100000], V[100000], num[10001], AnsI[10001], AnsO[10001], vip[10001];mapint, int Table;queueint Wait, vWait;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d:%d:%d, H, M, S); t = H * 3600 + M * 60 + S; scanf(%d %d, T[t], V[t]); T[t] = min(T[t], 120) * 60; scanf(%d %d, m, k); for (int i = 0; i k; i++) scanf(%d, t); vip[t] = 1; for (int Time = 28800; Time 75600; Time++, table = vtable = now = 0) if (T[Time] V[Time]) vWait.push(Time); else if (T[Time]) Wait.push(Time); for (int i = 1; i = m; i++) if (Table[i] 0) Table[i]--; if (Table[i] == 0 vip[i] vtable == 0) vtable = i; if (Table [i] == 0 table == 0) table = i; if (!vWait.empty() (table || vtable)) now = vWait.front(); nowt = vtable; if (vtable != 0) vWait.pop(); else nowt = table; if (!Wait.empty() Wait.front() vWait.front()) now = Wait.front(); Wait.pop(); else vWait.pop(); else if (!Wait.empty() (table || vtable)) if (table != 0) nowt = table; else nowt = vtable; now = Wait.front(); Wait.pop(); if (now == 0) continue; Table[nowt] = T[now]; AnsI[cnt] = now; AnsO[cnt++] = Time; num[nowt]++; for (int i = 0; i cnt; i++) printf(%02d:%02d:%02d %02d:%02d:%02d %d , AnsI[i] / 3600, AnsI[i] % 3600 / 60, AnsI[i] % 60, AnsO[i] / 3600, AnsO[i] % 3600 / 60, AnsO[i] % 60, (AnsO[i] - AnsI[i] + 30) / 60); for (int i = 1; i = m; i++) if (i != 1) printf( ); printf(%d, num[i]); return 0; 1027 Colors in Mars#include iostream#include string#include algorithmusing namespace std;string convert(int n) string res = ; while (n) if (n % 13 9) res += n % 13 + A - 10; else res += n % 13 + 0; n /= 13; while (res.size() 2) res += 0; reverse(res.begin(), res.end()); return res;int main() int red, green, blue; cin red green blue; cout # convert(red) convert(green) convert(blue); return 0; 柳婼的 #include iostreamusing namespace std;int main() char c[14] = 0123456789ABC; cout #; for (int i = 0; i 3; i++) int num; cin num; cout c[num / 13] c[num % 13]; return 0; 1028 List Sorting#include iostream#include string#include algorithm#include vectorusing namespace std;struct node string num, name; int score; nums[100001];bool cmp1 (node a, node b) return a.num b.num;bool cmp2 (node a, node b) if (a.name == b.name) return a.num b.num; else return a.name b.name;bool cmp3 (node a, node b) if (a.score == b.score) return a.num b.num; else return a.score b.score;int main() int n, c, score; string num, name; cin n c; for (int i = 0; i n; i++) cin nums[i].num nums[i].name nums[i].score; if (c == 1) sort(nums, nums + n, cmp1); else if (c == 2) sort(nums, nums + n, cmp2); else if (c == 3) sort(nums, nums + n, cmp3); for (int i = 0; i n; i++) cout nums[i].num nums[i].name nums[i].score endl; 1029 Median#include iostream#include vector#include algorithmusing namespace std;typedef long long LL;vectorLL nums;int main() LL n, x; scanf(%lld, n); for (int i = 0; i n; i++) scanf( %lld, x); nums.push_back(x); scanf(%lld, n); for (int i = 0; i n; i++) scanf( %lld, x); nums.push_back(x); sort(nums.begin(), nums.end()); cout nums[(nums.size() - 1) / 2]; return 0; 柳婼的 #include iostreamusing namespace std;const int N = 200005;int n, m, a1[N], a2[N];int main() cin n; for (int i = 1; i = n; i++) scanf(%d, a1[i]); cin m; for (int i = 1; i = m; i++) scanf(%d, a2[i]); int target = (n + m + 1) / 2; int i = 1, j = 1, cnt = 0, res; while (i = n j = m) res = a1[i] = a2[j] ? a1[i++] : a2[j++]; if (++cnt == target) break; if (i = n cnt target) res = a1[i + target - cnt - 1]; else if (j = m cnt target) res = a2[j + target - cnt - 1]; cout res; return 0; 1030 Travel Plandijkstra #include iostream#include vectorusing namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node int v, dis; node (int _v, int _dis) v = _v, dis = _dis; ;vectornode g[N];vectorint pre[N];int n, s, d[N], cost[N][N], mincost = INF;bool visit[N];void dijkstra(int s) fill(d, d + N, INF); d[s] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v; int dis = g[u][j].dis; if (!visit[v]) if (d[u] + dis d[v]) d[v] = d[u] + dis; pre[v].clear(); pre[v].push_back(u); else if (d[u] + dis == d[v]) pre[v].push_back(u); vectorint tmp, res;void dfs(int t) tmp.push_back(t); if (s == t) int minc = 0; for (int i = 0; i tmp.size() - 1; i++) int id = tmp[i], nexti = tmp[i + 1]; minc += cost[id][nexti]; if (minc mincost) mincost = minc; res = tmp; tmp.pop_back(); return; for (int i = 0; i pre[t].size(); i++) dfs(pre[t][i]); tmp.pop_back();int main() int m, t, u, v, w, c; cin n m s t; for (int i = 0; i m; i++) cin u v w c; cost[u][v] = cost[v][u] = c; g[u].push_back(node(v, w)); g[v].push_back(node(u, w)); dijkstra(s); dfs(t); for (int i = res.size() - 1; i = 0; i--) cout res[i] ; cout d[t] mincost; return 0; 1031 Hello World for U#include iostream#include stringusing namespace std;int main() string str; cin str; int len = str.size() + 2; int n = len / 3; int n2 = len - n * 3 + n - 2; for (int i = 0; i n - 1; i++) cout str[i]; for (int j = 0; j n2; j++) cout ; cout str[str.size() - 1 - i] endl; for (int i = n - 1; i n + n2 + 1; i++) cout str[i]; return 0; 1032 Sharing#include iostreamusing namespace std;const int N = 100001;struct node int next; char data; bool flag; nodes[N];int main() int s1, s2, n, add, next; char data; cin s1 s2 n; for (int i = 0; i n; i++) cin add data next; nodes[add] = next, data, false; for (int i = s1; i != -1; i = nodes[i].next) nodes[i].flag = true; for (int i = s2; i != -1; i = nodes[i].next) if (nodes[i].flag) printf(%05d, i); return 0; cout -1; return 0; 1033 To Fill or Not to Fill错误答案（没有考虑到油箱上限） #include iostream#include vector#include map#include queue#include algorithmusing namespace std;typedef pairdouble, double PII;vectorPII sites;int main() double c_max, d_max, d_avg, n,price, dis; cin c_max d_max d_avg n; for (int i = 0; i n; i++) cin price dis; if (dis = d_max) continue; sites.push_back(dis, price); sort(sites.begin(), sites.end()); int cur_site = 0; double res = 0, cur_dis = 0, diff = 0; priority_queuePII, vectorPII, greaterPII q; if (sites[0].first != 0) cout The maximum travel distance = 0.00; return 0; while (cur_dis d_max cur_site sites.size()) if (cur_site == sites.size() - 1) diff = d_max - cur_dis; else diff = sites[cur_site + 1].first - cur_dis; q.push(sites[cur_site++].second, c_max); while (!q.empty()) PII t = q.top(); q.pop(); if (d_avg * t.second = diff) res += t.first * t.second; diff -= d_avg * t.second; cur_dis += d_avg * t.second; else res += diff * t.first / d_avg; cur_dis += diff; q.push(t.first, t.second - diff / d_avg); diff = 0; break; if (diff 0) break; if (cur_dis == d_max) printf(%.2f, res); else printf(The maximum travel distance = %.2f, cur_dis); return 0; 柳婼的（贪心） #include iostream#include vector#include map#include algorithmusing namespace std;const int INF = 0x3f3f3f3f;typedef pairdouble, double PII;int main() double c_max, d_max, d_avg, n; cin c_max d_max d_avg n; vectorPII sta(n + 1); sta[0] = d_max, 0; for (int i = 1; i = n; i++) cin sta[i].second sta[i].first; sort(sta.begin(), sta.end()); double cur_dis = 0, max_dis = 0, cur_price = 0, total_price = 0, left_dis = 0; if (sta[0].first != 0) cout The maximum travel distance = 0.00; return 0; else cur_price = sta[0].second; while (cur_dis d_max) max_dis = cur_dis + c_max * d_avg; double min_price_dis = 0, min_price = INF; int flag = 0; for (int i = 1; i = n sta[i].first = max_dis; i++) if (sta[i].first = cur_dis) continue; if (sta[i].second = cur_price) total_price += (sta[i].first - cur_dis - left_dis) * cur_price / d_avg; left_dis = 0; cur_price = sta[i].second; cur_dis = sta[i].first; flag = 1; break; if (sta[i].second min_price) min_price = sta[i].second; min_price_dis = sta[i].first; if (flag == 0 min_price != INF) total_price += (cur_price * (c_max - left_dis / d_avg)); left_dis = c_max * d_avg - (min_price_dis - cur_dis); cur_price = min_price; cur_dis = min_price_dis; if (flag == 0 min_price == INF) cur_dis += c_max * d_avg; printf(The maximum travel distance = %.2f, cur_dis); return 0; printf(%.2f, total_price); return 0; 1034 Head of a Gang并查集（写复杂了） #include iostream#include set#include vector#include map#include algorithmusing namespace std;typedef pairstring, int PII;const int N = 20000;int fa[N], sum[N], maxs[N];int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];int convert1(string x) return (x[0] - A) * 26 * 26 + (x[1] - A) * 26 + x[2] - A;string convert2(int x) string res = ; res += x / (26 * 26) + A; res += x % (26 * 26) / 26 + A; res += x % 26 + A; return res;setint nums;struct node int a, b, time;;vectornode relations;int main() int n, k, time; cin n k; string a, b; for (int i = 0; i n; i++) cin a b time; nums.insert(convert1(a)); nums.insert(convert1(b)); relations.push_back(convert1(a), convert1(b), time); for (auto i = nums.begin(); i != nums.end(); i++) fa[*i] = *i; for (int i = 0; i relations.size(); i++) int a = relations[i].a, b = relations[i].b, time = relations[i].time; if (fa[a] != fa[b]) sum[find(b)] = max(sum[find(a)], sum[find(b)]); fa[find(a)] = find(b); sum[find(b)] += time; maxs[a] += time; maxs[b] += time; setint bangs; for (auto i = nums.begin(); i != nums.end(); i++) if (sum[find(*i)] k) bangs.insert(find(*i)); vectorPII res; for (auto i = bangs.begin(); i != bangs.end(); i++) setint tmp; int m = 0, r; for (int j = 0; j relations.size(); j++) if (find(*i) == find(relations[j].a)) tmp.insert(relations[j].a); tmp.insert(relations[j].b); if (m maxs[relations[j].a]) m = maxs[relations[j].a]; r = relations[j].a; if (m maxs[relations[j].b]) m = maxs[relations[j].b]; r = relations[j].b; if (tmp.size() 2) res.push_back(convert2(r), tmp.size()); cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; return 0; 柳婼的（dfs） #include iostream#include map#include string#include algorithmusing namespace std;mapstring, int stringToInt;mapint, string intToString;mapstring, int res;int id = 1, k;int stoifun(string s) if (stringToInt[s] == 0) stringToInt[s] = id; intToString[id] = s; return id++; else return stringToInt[s]; int g[2010][2010], weight[2010];bool vis[2010];void dfs(int u, int head, int numMember, int totalweight) vis[u] = true; numMember++; if (weight[u] weight[head]) head = u; for (int v = 1; v id; v++) if (g[u][v] 0) totalweight += g[u][v]; g[u][v] = g[v][u] = 0; if (!vis[v]) dfs(v, head, numMember, totalweight); void dfsTrave() for (int i = 1; i id; i++) if (!vis[i]) int head = i, numMember = 0, totalweight = 0; dfs(i, head, numMember, totalweight); if (numMember 2 totalweight k) res[intToString[head]] = numMember; int main() int n, w; cin n k; string s1, s2; for (int i = 0; i n; i++) cin s1 s2 w; int id1 = stoifun(s1); int id2 = stoifun(s2); weight[id1] += w; weight[id2] += w; g[id1][id2] += w; g[id2][id1] += w; dfsTrave(); cout res.size() endl; for (auto it = res.begin(); it != res.end(); it++) cout it-first it- second endl; return 0; 1035 Password#include iostream#include vector#include map#include stringusing namespace std;string convert(string a) string b = ; for (int i = 0; i a.size(); i++) if (a[i] == 1) b += @; else if (a[i] == 0) b += %; else if (a[i] == l) b += L; else if (a[i] == O) b += o; else b += a[i]; return b;int main() int n; cin n; string name, password; vectorpairstring, string res; for (int i = 0; i n; i++) cin name password; if (password != convert(password)) res.push_back(name, convert(password)); if (res.size() 1) cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; else if (n == 1) cout There is 1 account and no account is modified; else cout There are n accounts and no account is modified; return 0; 1036 Boys vs Girls#include iostream#include string#include algorithmusing namespace std;struct node string name, id; int grade;;bool cmp(node a, node b) return a.grade b.grade;vectornode males, famales;int main() int n; cin n; string name, gender, id; int grade; for (int i = 0; i n; i++) cin name gender id grade; if (gender == M) males.push_back(name, id, grade); else famales.push_back(name, id, grade); bool flag = false; int diff; sort(males.begin(), males.end(), cmp); sort(famales.begin(), famales.end(), cmp); if (famales.size() 0) cout famales[famales.size() - 1].name famales[famales.size() - 1].id endl; diff = famales[famales.size() - 1].grade; else cout Absent endl; flag = true; if (males.size() 0) cout males[0].name males[0].id endl; diff += -males[0].grade; else cout Absent endl; flag = true; if (flag) cout NA; else cout diff; return 0; 柳婼的 #include iostreamusing namespace std;int main() int n; scanf(%d, n); string female, male; int femalescore = -1, malescore = 101; for(int i = 0; i n; i++) string name, sex, num; int score; cin name sex num; scanf(%d, score); if(sex == F) if(femalescore score) femalescore = score; female = name + + num; else if(malescore score) malescore = score; male = name + + num; if(femalescore != -1) cout female endl; else printf(Absent ); if(malescore != 101) cout male endl; else printf(Absent ); if(femalescore != -1 malescore != 101) printf(%d, femalescore - malescore); else printf(NA); return 0; 1037 Magic Coupon#include iostream#include algorithmusing namespace std;const int N = 100001;int a[N], b[N];int main() int n, m; cin n; for (int i = 0; i n; i++) cin a[i]; cin m; for (int i = 0; i m; i++) cin b[i]; sort(a, a + n); sort(b, b + m); int al = 0, bl = 0, ar = n - 1, br = m - 1, res = 0; while(al n bl n a[al] 0 b[bl] 0) res += a[al++] * b[bl++]; while (ar = 0 br = 0 a[ar] 0 b[br] 0) res += a[ar--] * b[br--]; cout res; return 0; 1038 Recover the Smallest Number#include iostream#include string#include vector#include algorithmusing namespace std;bool cmp(string a, string b) return a + b b + a;typedef long long LL;int main() int n; string x; cin n; vectorstring nums(n); for (int i = 0; i n; i++) cin nums[i]; sort(nums.begin(), nums.end(), cmp); bool flag = true, first = true; for (int i = 0; i (LL)nums.size(); i++) if (first) int j = 0; for (; j (LL)nums[i].size(); j++) if (nums[i][j] != 0) break; if (j (LL)nums[i].size()) first = false; for (; j (LL)nums[i].size(); j++) cout nums[i][j]; flag = false; else cout nums[i]; if (flag) cout 0; return 0; 柳婼的 #include iostream#include string#include vector#include algorithmusing namespace std;bool cmp(string a, string b) return a + b b + a;string str[10010];int main() int n; cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n, cmp); string s; for (int i = 0; i n; i++) s += str[i]; while (s.size() != 0 s[0] == 0) s.erase(s.begin()); if (s.size() == 0) cout 0; cout s; return 0; 1039 Course List for Student#include iostream#include string#include map#include vector#include algorithmusing namespace std;mapstring, vectorint students;int main() int n, k, courseId, m; string name; cin n k; for (int i = 0; i k; i++) cin courseId m; for (int j = 0; j m; j++) cin name; students[name].push_back(courseId); for (int i = 0; i n; i++) cin name; cout name students[name].size(); sort(students[name].begin(), students[name].end()); for (int j = 0; j students[name].size(); j++) cout students[name][j]; cout endl; return 0; 柳婼的 #include cstdio#include vector#include algorithmusing namespace std;int getid(char *name) int id = 0; for(int i = 0; i 3; i++) id = 26 * id + (name[i] - A); id = id * 10 + (name[3] - 0); return id;const int maxn = 26 * 26 * 26 * 10 + 10;vectorint v[maxn];int main() int n, k, no, num, id = 0; char name[5]; scanf(%d %d, n, k); for(int i = 0; i k; i++) scanf(%d %d, no, num); for(int j = 0; j num; j++) scanf(%s, name); id = getid(name); v[id].push_back(no); for(int i = 0; i n; i++) scanf(%s, name); id = getid(name); sort(v[id].begin(), v[id].end()); printf(%s %lu, name, v[id].size()); for(int j = 0; j v[id].size(); j++) printf( %d, v[id][j]); printf( ); return 0; 1040 Longest Symmetric String#include iostream#include stringusing namespace std;const int N = 1005;bool dp[N][N];int main() string str; getline(cin, str); int n = str.size(), res = 1; for (int i = 1; i n; i++) dp[i][i] = true; if (i n - 1 str[i] == str[i + 1]) dp[i][i + 1] = true; res = 2; for (int len = 3; len = n; len++) for (int l = 0; l n - len + 1; l++) int r = l + len - 1; if (str[l] == str[r] dp[l + 1][r - 1]) dp[l][r] = true; res = len; cout res; return 0; 1041 Be Unique#include iostreamusing namespace std;const int N = 100005;int nums[N], cnt[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; cnt[nums[i]] ++; for (int i = 0; i n; i++) if (cnt[nums[i]] == 1) cout nums[i]; return 0; cout None; return 0; 1042 Shuffling Machine#include iostream#include stringusing namespace std;string nums[55] = ,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,H1,H2,H3,H4,H5,H6,H7,H8,H9,H10,H11,H12,H13,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13,J1, J2;int shuff[55];int main () int n; cin n; for (int i = 1; i 55; i++) cin shuff[i]; for (int i = 0; i n; i++) string tmps[55]; for (int j = 1; j 55; j++) tmps[shuff[j]] = nums[j]; copy(begin(tmps), end(tmps), begin(nums)); for (int i = 1; i 55; i++) cout nums[i]; if (i 54) cout ; return 0; 柳婼的 #include iostreamusing namespace std;int main () int cnt; cin cnt; int start[55], end[55], scan[55]; for (int i = 1; i 55; i++) cin scan[i]; end[i] = i; for (int i = 0; i cnt; i++) for (int j = 1; j 55; j++) start[j] = end[j]; for (int k = 1; k 55; k++) end[scan[k]] = start[k]; char c[6] = SHCDJ; for (int i = 1; i 55; i++) end[i] = end[i] - 1; cout c[end[i] / 13] end[i] % 13 + 1; if (i != 54) cout ; return 0; 1043 Is It a Binary Search Tree#include iostream#include vectorusing namespace std;bool isMirror;vectorint pre, post;void getpost(int root, int tail) if (root tail) return; int i = root + 1, j = tail; if (!isMirror) while (i = tail pre[root] pre[i]) i++; while (j root pre[root] = pre[j]) j--; else while (i = tail pre[root] = pre[i]) i++; while (j root pre[root] pre[j]) j--; if (i - j != 1) return; getpost(root + 1, j); getpost(i, tail); post.push_back(pre[root]);int main() int n; cin n; pre.resize(n); for (int i = 0; i n; i++) cin pre[i]; getpost(0, n - 1); if (post.size() != n) isMirror = true; post.clear(); getpost(0, n - 1); if (post.size() == n) cout YES endl; for (int i = 0; i n; i++) cout post[i]; if (i n - 1) cout ; else cout NO; return 0; 1044 Shopping in Mars滑动窗口 #include iostream#include vector#include mapusing namespace std;const int N = 100005;vectorpairint, int res;int nums[N];int main() int n, m; cin n m; for (int i = 0; i n; i++) cin nums[i]; int tmp = 0, maxn = 0x3f3f3f3f; int l = 0, r = 0; while (r n) tmp += nums[r]; if (tmp = m tmp maxn) maxn = tmp; if (tmp == maxn) res.push_back(l + 1, r + 1); while (l r tmp = m) if (maxn tmp) maxn = tmp; res.clear(); if (tmp == maxn) res.push_back(l + 1, r + 1); tmp -= nums[l++]; if (tmp == maxn) res.push_back(l + 1, r + 1); r++; for (int i = 0; i res.size(); i++) cout res[i].first - res[i].second endl; return 0; 柳婼的（二分） #include iostream#include vectorusing namespace std;vectorint sum, res;int n, m;void search(int i, int j, int tmp) int l = i, r = n; while (l r) int mid = (l + r) / 2; if (sum[mid] - sum[i - 1] = m) r = mid; else l = mid + 1; j = r; tmp = sum[j] - sum[i - 1];int main() cin n m; sum.resize(n + 1); for (int i = 1; i = n; i++) cin sum[i]; sum[i] += sum[i - 1]; int minres = sum[n]; for (int i = 1; i = n; i++) int j, tmpsum; search(i, j, tmpsum); if (tmpsum minres) continue; if (tmpsum = m) if (tmpsum minres) res.clear(); minres = tmpsum; res.push_back(i); res.push_back(j); for (int i = 0; i res.size(); i += 2) cout res[i] - res[i + 1] endl; return 0; 1045 Favorite Color Stripe动态规划 #include iostream#include algorithmusing namespace std;int dp[10001], b[201], a[10001];int main() int n, m, x, l, num = 0, res = 0; cin n m; for (int i = 1; i = m; i++) cin x; b[x] = i; cin l; for (int i = 0; i l; i++) cin x; if (b[x] = 1) a[num++] = b[x]; for (int i = 0; i num; i++) dp[i] = 1; for (int j = 0; j i; j++) if (a[i] = a[j]) dp[i] = max(dp[i], dp[j] + 1); res = max(dp[i], res); cout res; return 0; 1046 Shortest Distance前缀和 #include iostream#include algorithmusing namespace std;const int N = 200001;int nums[N], sums[N];int main() int n, m, a, b; cin n; for (int i = 1; i = n; i++) cin nums[i]; nums[i + n] = nums[i]; sums[i] = sums[i - 1] + nums[i]; for (int i = n + 1; i n + n; i++) sums[i] = sums[i - 1] + nums[i]; cin m; for (int i = 0; i m; i++) cin a b; if (a b) swap(a, b); cout min(sums[b - 1] - sums[a - 1], sums[a + n - 1] - sums[b - 1]) endl; return 0; 1047 Student List for Course#include iostream#include vector#include string#include algorithmusing namespace std;vectorstring course[2501];int main() int n, k, c, x; string name; cin n k; for (int i = 0; i n; i++) cin name c; for (int j = 0; j c; j++) cin x; course[x].push_back(name); for (int i = 1; i = k; i++) cout i course[i].size() endl; sort(course[i].begin(), course[i].end()); for (int j = 0; j course[i].size(); j++) printf(%s , course[i][j].c_str()); return 0; 1048 Find Coins双指针 #include iostream#include algorithmusing namespace std;const int N = 100005;int nums[N];int main() int n, m, cnt = 0, x; cin n m; for (int i = 0; i n; i++) cin x; if (x m) nums[cnt++] = x; sort(nums, nums + cnt); int l = 0, r = cnt - 1, tmp = nums[l] + nums[r]; while (l r) if (tmp == m) cout nums[l] nums[r]; return 0; else if (tmp m) r--; else l++; tmp = nums[l] + nums[r]; cout No Solution; return 0; 柳婼的 #include iostreamusing namespace std;int nums[1001];int main() int n, m, cnt = 0, x; cin n m; for (int i = 0; i n; i++) cin x; nums[x] ++; for (int i = 0; i 1001; i++) if (nums[i]) nums[i]--; if (m i nums[m - i]) cout i m - i; return 0; cout No Solution; return 0; 1049 Counting Ones暴力（超时） #include iostreamusing namespace std;int main() int n, cnt = 0; cin n; for (int i = 1; i = n; i++) int a = i; while (a) if (a % 10 == 1) cnt++; a /= 10; cout cnt; return 0; 柳婼的 #include iostreamusing namespace std;int main() int n, left = 0, right = 0, a = 1, now = 1, res = 0; cin n; while (n / a) left = n / (a * 10), now = n / a % 10, right = n % a; if (now == 0) res += left * a; else if (now == 1) res += left * a + right + 1; else res += (left + 1) * a; a = a * 10; cout res; return 0; 1050 String Subtraction#include iostream#include string#include setusing namespace std;string s1, s2;bool nums[129];int main() getline(cin, s1); getline(cin, s2); for (auto i: s2) nums[i] = true; for (auto i: s1) if (!nums[i]) cout i; return 0; 1051 Pop Sequence#include iostream#include stackusing namespace std;int main() int m, n, k, x; cin m n k; for (int i = 0; i k; i++) int cnt = 1; stackint st; bool flag = true; for (int j = 0; j n; j++) cin x; while (x = cnt st.size() m cnt = n) st.push(cnt); cnt++; if (st.top() != x) flag = false; while (j++ n - 1) cin x; break; st.pop(); cout (flag ? YES : NO) endl; return 0; 1052 Linked List Sorting#include iostream#include algorithm#include mapusing namespace std;typedef pairint, int PII;struct node int add, key, next;;bool cmp(PII a, PII b) return a.second b.second;const int INF = 0x3f3f3f3f;const int N = 100001;node nums[N];vectorPII nums2;int main() int n, head, add, key, nex; cin n head; if (head == -1) cout 0 -1; return 0; for (int i = 0; i n; i++) cin add key nex; nums[add] = add, key, nex; while (head != -1) nums2.push_back(head, nums[head].key); head = nums[head].next; sort(nums2.begin(), nums2.end(), cmp); printf(%d %05d , nums2.size(), nums2[0].first); for (int i = 0; i nums2.size() - 1; i++) printf(%05d %d %05d , nums2[i].first, nums2[i].second, nums2[i + 1].first); printf(%05d %d -1 , nums2[nums2.size() - 1].first, nums2[nums2.size() - 1].second); return 0; 1053 Path of Equal Weight#include iostream#include vector#include algorithmusing namespace std;const int N = 100;int weight[N], sum, s;vectorint trees[N], tmp;vectorvectorint res;bool cmp(const vectorint a, const vectorint b) for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] b[i]; void dfs(int x) if (sum == s trees[x].empty()) res.push_back(tmp); return; if (sum s) return; for (int i = 0; i trees[x].size(); i++) sum += weight[trees[x][i]]; tmp.push_back(weight[trees[x][i]]); dfs(trees[x][i]); sum -= weight[trees[x][i]]; tmp.pop_back(); int main() int n, m, cur, k, child; cin n m s; for (int i = 0; i n; i++) cin weight[i]; s -= weight[0]; tmp.push_back(weight[0]); for (int i = 0; i m; i++) cin cur k; for (int j = 0; j k; j++) cin child; trees[cur].push_back(child); dfs(0); sort(res.begin(), res.end(), cmp); for (int i = 0; i res.size(); i++) for (int j = 0; j res[i].size(); j++) printf(%d, res[i][j]); if (j res[i].size() - 1) printf( ); else printf( ); return 0; 1054 The Dominant Color#include iostream#include map#include algorithmusing namespace std;mapint, int nums;vectorpairint, int res;bool cmp(pairint, int a, pairint, int b) return a.second b.second;int main() int m, n, x; cin m n; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x]++; for (auto it: nums) res.push_back(it); sort(res.begin(), res.end(), cmp); cout res[0].first; return 0; 柳婼的 #include iostream#include mapusing namespace std;mapint, int nums;int main() int m, n, x; cin m n; int half = m * n / 2; for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin x; nums[x]++; if (nums[x] half) cout x; return 0; return 0; 1055 The World’s Richest#include iostream#include vector#include string#include algorithmusing namespace std;struct node string name; int age, worth;;bool cmp(node a, node b) if (a.worth != b.worth) return a.worth b.worth; else if (a.age != b.age) return a.age b.age; else return a.name b.name;vectornode nums[201];int main() int n, k, age, worth, m, start, end; cin n k; string name; for (int i = 0; i n; i++) cin name age worth; nums[age].push_back(name, age, worth); for (int i = 1; i = k; i++) cin m start end; if (start 1) start = 1; if (end 200) end = 200; vectornode tmp; for (int j = start; j = end; j++) for (auto it: nums[j]) tmp.push_back(it.name, it.age, it.worth); sort(tmp.begin(), tmp.end(), cmp); printf(Case #%d: , i); for (int j = 0; j min((int)tmp.size(), m); j++) printf(%s %d %d , tmp[j].name.c_str(), tmp[j].age, tmp[j].worth); if (tmp.empty()) printf(None); return 0; 柳婼的 #include iostream#include vector#include string#include algorithmusing namespace std;struct node string name; int age, worth; nums[100001];bool cmp(node a, node b) if (a.worth != b.worth) return a.worth b.worth; else if (a.age != b.age) return a.age b.age; else return a.name b.name;int main() int n, k, age, worth, m, start, end; cin n k; string name; for (int i = 0; i n; i++) cin nums[i].name nums[i].age nums[i].worth; sort(nums, nums + n, cmp); for (int i = 1; i = k; i++) printf(Case #%d: , i); cin m start end; int cnt = 0; for (int j = 0; j n; j++) if (nums[j].age = start nums[j].age = end) printf(%s %d %d , nums[j].name.c_str(), nums[j].age, nums[j].worth); cnt++; if (cnt == m) break; if (cnt == 0) printf(None); return 0; 1056 Mice and Rice#include iostream#include vector#include algorithmusing namespace std;int weight[10001], ranks[10001];vectorint tmp, res[300];int main() int np, ng, x; cin np ng; for (int i = 0; i np; i++) cin weight[i]; for (int i = 0; i np; i++) cin x; tmp.push_back(x); int depth = 0, d = np / ng + 1; while (d--) for (int i = 0; i tmp.size(); i += ng) int ma = 0, idx = 0; for (int j = i; j min(ng + i, (int)tmp.size()); j++) if (weight[tmp[j]] ma) ma = weight[tmp[j]]; idx = tmp[j]; res[depth + 1].push_back(idx); for (int j = i; j min(ng + i, (int)tmp.size()); j++) if (tmp[j] != idx) res[depth].push_back(tmp[j]); tmp.clear(); tmp = res[depth + 1]; res[depth + 1].clear(); depth++; int rank = 1; ranks[tmp[0]] = rank++; for (int i = depth - 1; i = 0; i--) for (auto it: res[i]) ranks[it] = rank; rank += res[i].size(); for (int i = 0; i np; i++) cout ranks[i]; if (i np - 1) cout ; return 0; 1057 Stack暴力（超时） #include iostream#include string#include stack#include vector#include algorithmusing namespace std;stackint st;vectorint tmp;int main() int n, x; string op; cin n; for (int i = 0; i n; i++) cin op; if (op == Pop) if (st.empty()) cout Invalid endl; else cout st.top() endl; tmp.erase(find(tmp.begin(), tmp.end(), st.top())); st.pop(); else if (op == Push) cin x; st.push(x); tmp.push_back(x); else if (op == PeekMedian) if (st.empty()) cout Invalid endl; else sort(tmp.begin(), tmp.end()); if (tmp.size() % 2) cout tmp[(tmp.size() - 1) / 2] endl; else cout tmp[tmp.size() / 2 - 1] endl; return 0; 柳婼的（树状数组） #include iostream#include stackusing namespace std;#define lowbit(i) ((i) (-i))const int N = 100010;int c[N];stackint s;void update(int x, int v) for (int i = x; i N; i += lowbit(i)) c[i] += v;int getsum(int x) int sum = 0; for (int i = x; i = 1; i -= lowbit(i)) sum += c[i]; return sum;void PeekMedian() int left = 1, right = N, mid, k = (s.size() + 1) / 2; while (left right) mid = (left + right) / 2; if (getsum(mid) = k) right = mid; else left = mid + 1; printf(%d , left);int main() int n, tmp; scanf(%d, n); char str[15]; for (int i = 0; i n; i++) scanf(%s, str); if (str[1] == u) scanf(%d, tmp); s.push(tmp); update(tmp, 1); else if (str[1] == o) if (!s.empty()) update(s.top(), -1); printf(%d , s.top()); s.pop(); else printf(Invalid ); else if (!s.empty()) PeekMedian(); else printf(Invalid ); return 0; 1058 A+B in Hogwarts - PAT (Advanced Level) Practice (pintia.cn)#include iostreamint main() int a1, a2, a3, b1, b2, b3, c1, c2, c3, t; scanf(%d.%d.%d %d.%d.%d, a1, a2, a3, b1, b2, b3); c3 = (a3 + b3) % 29; t = (a3 + b3) / 29; c2 = (a2 + b2 + t) % 17; t = (a2 + b2 + t) / 17; c1 = a1 + b1 + t; printf(%d.%d.%d, c1, c2, c3); return 0; 1059 Prime Factors#include iostream#include cmathusing namespace std;typedef long long LL;int main() LL n; cin n; cout n =; if (n == 1) cout 1; for (LL i = 2; i = sqrt(n); i++) int cnt = 0; if (n % i == 0) while (n % i == 0) cnt++; n /= i; if (cnt 1) cout i ^ cnt; else if (cnt == 1) cout i; if (cnt != 0 n 1) cout *; if (n 1) cout n; return 0; 1060 Are They Equal#include iostream#include stringusing namespace std;string convert(string str, int n) int idx = 0, len = str.size(), k = 0; string t; while (idx len str[idx] == 0) idx++; if (str[idx] == .) idx++; while (idx len str[idx] == 0) idx++; k--; bool flag = false; while (t.size() n idx len) t.push_back(str[idx++]); flag = true; while (t.size() n) t.push_back(0); if (!flag) k = 0; else for (int j = idx; str[j] != . j len; j++) k++; while (str[idx] != . t.size() n idx len) t.push_back(str[idx++]); if (t.size() n) idx++; while (idx len t.size() n) t.push_back(str[idx++]); while (t.size() n) t.push_back(0); return 0. + t + *10^ + to_string(k);int main() int n; string a, b; cin n a b; a = convert(a, n); b = convert(b, n); if (a == b) cout YES a; else cout NO a b; return 0; 1061 Dating#include iostream#include stringusing namespace std;int main() string a, b, c, d; cin a b c d; int sa = a.size(), sb = b.size(), sc = c.size(), sd = d.size(); int week, hour, minute, cnt = 0; string weeks[7] = MON, TUE, WED, THU, FRI, SAT, SUN; bool is_first = true; for (int i = 0; i min(sa, sb); i++) if (a[i] == b[i] a[i] = A a[i] = G is_first) week = a[i] - A; is_first = false; continue; if (!is_first a[i] == b[i] ((a[i] = A a[i] = N) || isdigit(a[i]))) if (a[i] = A a[i] = N) hour = a[i] - A + 10; else if (isdigit(a[i])) hour = a[i] - 0; break; for (int i = 0; i min(sc, sd); i++) if (c[i] == d[i] isalpha(c[i])) minute = i; break; printf(%s %02d:%02d, weeks[week].c_str(), hour, minute); return 0; 1062 Talent and Virtue#include iostream#include string#include vector#include algorithmusing namespace std;struct node int num, virtue, talent, sum;;bool cmp(node a, node b) if (a.sum != b.sum) return a.sum b.sum; else if (a.virtue != b.virtue) return a.virtue b.virtue; else if (a.talent != b.talent) return a.talent b.talent; else return a.num b.num;vectornode sage, nobleman, fool, small;int main() int n, l, h, num, virtue, talent; cin n l h; for (int i = 0; i n; i++) cin num virtue talent; int sum = virtue + talent; if (virtue = h talent = h) sage.push_back(num, virtue, talent, sum); else if (virtue = h talent = l) nobleman.push_back(num, virtue, talent, sum); else if (virtue = talent talent = l) fool.push_back(num, virtue, talent, sum); else if (virtue = l talent = l) small.push_back(num, virtue, talent, sum); sort(sage.begin(), sage.end(), cmp); sort(nobleman.begin(), nobleman.end(), cmp); sort(fool.begin(), fool.end(), cmp); sort(small.begin(), small.end(), cmp); cout sage.size() + nobleman.size() + fool.size() + small.size() endl; for (auto it: sage) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: nobleman) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: fool) printf(%08d %d %d , it.num, it.virtue, it.talent); for (auto it: small) printf(%08d %d %d , it.num, it.virtue, it.talent); return 0; 1063 Set Similarity#include iostream#include mapusing namespace std;mapint, bool nums[51];int main() int n, m, x, k, a, b; cin n; for (int i = 1; i = n; i++) cin m; for (int j = 0; j m; j++) scanf(%d, x); nums[i][x] = true; cin k; for (int i = 0; i k; i++) cin a b; mapint, bool tmp; tmp = nums[a]; int common = 0, total = 0; for (auto it: nums[b]) if (tmp[it.first]) tmp[it.first] = false; common++; total++; else total++; for (auto it: tmp) if (it.second) total++; printf(%.1f\\% , common * 100.0 / total); return 0; 1064 Complete Binary Search Tree#include iostream#include algorithmusing namespace std;const int N = 1001;int in[N], level[N], n, idx = 0;void dfs(int root) if (root = n) return; dfs(root * 2 + 1); level[root] = in[idx++]; dfs(root * 2 + 2);int main() cin n; for (int i = 0; i n; i++) cin in[i]; sort(in, in + n); dfs(0); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; return 0; 1065 A+B and C (64bit)#include iostreamusing namespace std;typedef long long LL;int main() int n; LL a, b, c; cin n; for (int i = 1; i = n; i++) cin a b c; LL t = a + b; if (a 0 b 0 t 0) cout Case # i : true endl; else if (a 0 b 0 t 0) cout Case # i : false endl; else if (a + b c) cout Case # i : true endl; else cout Case # i : false endl; return 0; 1066 Root of AVL Tree#include iostreamusing namespace std;struct node int val; node *left, *right;;node* rotateLeft(node* root) node *t = root-right; root-right = t-left; t-left = root; return t;node* rotateRight(node* root) node *t = root-left; root-left = t-right; t-right = root; return t;node* rotateLeftRight(node* root) root-left = rotateLeft(root-left); return rotateRight(root);node* rotateRightLeft(node* root) root-right = rotateRight(root-right); return rotateLeft(root);int getHeight(node* root) if (root == NULL) return 0; return max(getHeight(root-left), getHeight(root-right)) + 1;node* insert(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-left = NULL; root-right = NULL; else if (val root-val) root-left = insert(root-left, val); if (getHeight(root-left) - getHeight(root-right) == 2) root = val root-left-val ? rotateRight(root) : rotateLeftRight(root); else root-right = insert(root-right, val); if (getHeight(root-right) - getHeight(root-left) == 2) root = val root-right-val ? rotateLeft(root) : rotateRightLeft(root); return root;int main() int n, val; cin n; node *root = NULL; for (int i = 0; i n; i++) cin val; root = insert(root, val); cout (%d, root-val); return 0; 1067 Sort with Swap(0, i)#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n, x, res = 0; cin n; for (int i = 0; i n; i++) scanf(%d, x); nums[x] = i; for (int i = 1; i n; i++) if (nums[i] != i) while (nums[0] != 0) swap(nums[0], nums[nums[0]]); res++; if (nums[i] != i) swap(nums[0], nums[i]); res++; cout res; return 0; 1068 Find More Coinsdfs #include iostream#include vector#include algorithmusing namespace std;int nums[10001], n, m;vectorint tmp;void dfs(int x, int t) if (t == m) for (int i = 0; i tmp.size(); i++) cout tmp[i]; if (i tmp.size() - 1) cout ; exit(0); if (t m || x == n) return; tmp.push_back(nums[x]); dfs(x + 1, t + nums[x]); tmp.pop_back(); dfs(x + 1, t);int main() int sum = 0; cin n m; for (int i = 0; i n; i++) cin nums[i]; sum += nums[i]; if (sum m) cout No Solution; else sort(nums, nums + n); dfs(0, 0); cout No Solution; return 0; 柳婼的（dp） #include iostream#include vector#include algorithmusing namespace std;int dp[100001], nums[100001];bool choice[100001][110];int main() int n, m; cin n m; for (int i = 1; i = n; i++) cin nums[i]; sort(nums + 1, nums + n + 1, greaterint()); for (int i = 1; i = n; i++) for (int j = m; j = nums[i]; j--) if (dp[j] = dp[j - nums[i]] + nums[i]) choice[i][j] = true; dp[j] = dp[j - nums[i]] + nums[i]; if (dp[m] != m) cout No Solution; else vectorint res; int v = m, idx = n; while(v 0) if (choice[idx][v] == true) res.push_back(nums[idx]); v -= nums[idx]; idx--; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1069 The Black Hole of Numbers#include iostream#include string#include algorithmusing namespace std;int main() string n; cin n; while(n.size() 4) n = 0 + n; do string a = n, b = n; sort(a.begin(), a.end()); sort(b.begin(), b.end(), greaterchar()); int c = stoi(b) - stoi(a); n = to_string(c); while(n.size() 4) n = 0 + n; cout b - a = n endl; while (n != 6174 n!= 0000); return 0; 1070 Mooncake#include iostream#include algorithmusing namespace std;struct node double amount, price, profit; nums[1001];bool cmp(node a, node b) return a.profit b.profit;int main() int n, m; cin n m; for (int i = 0; i n; i++) cin nums[i].amount; for (int i = 0; i n; i++) cin nums[i].price; nums[i].profit = nums[i].price / nums[i].amount; sort(nums, nums + n, cmp); double res; for (int i = 0; i n; i++) if (nums[i].amount = m) res += m * nums[i].profit; break; else res += nums[i].price; m -= nums[i].amount; printf(%.2f, res); return 0; 1071 Speech Patterns#include iostream#include string#include mapusing namespace std;mapstring, int nums;int main() string str; getline(cin, str); str += .; for (int i = 0; i str.size(); i++) for (int j = i; j str.size(); j++) if (isalpha(str[j])) str[j] = tolower(str[j]); if (!isalnum(str[j])) if (j != i) nums[str.substr(i, j - i)]++; i = j; break; string res = nums.begin()-first; int m = nums.begin()-second; for (auto it: nums) if (m it.second) m = it.second; res = it.first; cout res m; return 0; 1072 Gas Stationdijkstra #include iostream#include string#include vector#include mapusing namespace std;const int N = 1012;const int INF = 0x3f3f3f3f;vectorpairint, int g[N];int dist[N], n, m, sums[11], mins[11];bool visit[N];void dijkstra(int x) fill(dist, dist + N, INF); fill(visit, visit + N, false); dist[x] = 0; for (int i = 0; i n + m; i++) int u = -1, mind = INF; for (int j = 1; j = n + m; j++) if (!visit[j] mind dist[j]) mind = dist[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first; int dis = g[u][j].second; if (!visit[v] dist[v] dist[u] + dis) dist[v] = dist[u] + dis; int main() int k, d, dis, t1, t2; string p1, p2; cin n m k d; for (int i = 0; i k; i++) cin p1 p2 dis; if (p1[0] == G) t1 = n + stoi(p1.substr(1)); else t1 = stoi(p1); if (p2[0] == G) t2 = n + stoi(p2.substr(1)); else t2 = stoi(p2); g[t1].push_back(t2, dis); g[t2].push_back(t1, dis); int real_sum = INF, real_min = 0, real_id = 0; for (int i = 1; i = m; i++) dijkstra(n + i); int res = INF, sum = 0; bool flag = true; for (int j = 1; j = n; j++) if (dist[j] d) flag = false; break; sum += dist[j]; res = min(res, dist[j]); if (flag) if (real_min res) real_sum = sum; real_id = i; real_min = res; else if (real_min == res) if (real_sum sum) real_sum = sum; real_id = i; if (real_min == 0) cout No Solution; else printf(G%d %.1f %.1f, real_id, (double)real_min, (double)real_sum / n); return 0; 1073 Scientific Notation#include iostream#include stringusing namespace std;int main() string str; cin str; if (str[0] == -) cout -; int exp, i; for (i = 3; i str.size(); i++) if (str[i] == E) break; if (str[i + 1] == -) exp = stoi(str.substr(i + 2)); cout 0.; for (int j = 0; j exp - 1; j++) cout 0; cout str[1] str.substr(3, i - 3); else exp = stoi(str.substr(i + 1)); if (str[1] != 0) cout str[1]; if (exp i - 3) for (int j = 0; j exp; j++) cout str[j + 3]; cout .; for (int j = exp; j i - 3; j++) cout str[j + 3]; else for (int j = 0; j exp; j++) if (j i - 3) cout str[j + 3]; else cout 0; return 0; 柳婼的 #include iostream#include stringusing namespace std;int main() string s; cin s; int i = 0; while (s[i] != E) i++; string t = s.substr(1, i - 1); int n = stoi(s.substr(i + 1)); if (s[0] == -) cout -; if (n 0) cout 0.; for (int j = 0; j abs(n) - 1; j++) cout 0; for (int j = 0; j t.length(); j++) if (t[j] != .) cout t[j]; else cout t[0]; int cnt, j; for (j = 2, cnt = 0; j t.length() cnt n; j++, cnt++) cout t[j]; if (j == t.length()) for (int k = 0; k n - cnt; k++) cout 0; else cout .; for (int k = j; k t.length(); k++) cout t[k]; return 0; 1074 Reversing Linked List数组模拟 #include iostream#include string#include vector#include mapusing namespace std;struct node string addr, nex; int val; ;mapstring, node nums1;vectornode nums2;int main() int n, k, val; string start, addr, nex; cin start n k; for (int i = 0; i n; i++) cin addr val nex; nums1[addr] = addr, nex, val; while (start != -1) nums2.push_back(nums1[start].addr, nums1[start].nex, nums1[start].val); start = nums1[start].nex; for (i = 0; i = nums2.size() - k; i += k) for (int j = i + k - 1; j i; j--) cout nums2[j].addr nums2[j].val nums2[j - 1].addr endl; cout nums2[i].addr nums2[i].val ; if (i + 2 * k = nums2.size()) cout nums2[i + 2 * k - 1].addr endl; else if (i + k nums2.size()) cout nums2[i + k].addr endl; else cout -1 ; for (int j = i; j nums2.size(); j++) cout nums2[j].addr nums2[j].val nums2[j].nex endl; return 0; 柳婼的 #include iostreamusing namespace std;const int N = 100005;int datas[N], nexts[N], list[N], res[N];int main() int first, k, n, sum = 0, tmp; cin first n k; for (int i = 0; i n; i++) cin tmp; cin datas[tmp] nexts[tmp]; while (first != -1) list[sum++] = first; first = nexts[first]; for (int i = 0; i sum; i++) res[i] = list[i]; for (int i = 0; i (sum - sum % k); i++) res[i] = list[i / k * k + k - 1 - i % k]; for (int i = 0; i sum - 1; i++) printf(%05d %d %05d , res[i], datas[res[i]], res[i + 1]); printf(%05d %d -1, res[sum - 1], datas[res[sum - 1]]); return 0; 1075 PAT Judge#include iostream#include algorithmusing namespace std;struct node int userId = 99999, totle, s[6] = -1, -1, -1, -1, -1, -1, perfect; bool isShow; nums[10001];bool cmp(node a, node b) if (a.totle != b.totle) return a.totle b.totle; else if (a.perfect != b.perfect) return a.perfect b.perfect; return a.userId b.userId;int w[6];int main() int n, k, m; cin n k m; for (int i = 1; i = k; i++) cin w[i]; int userId, problemId, score; for (int i = 0; i m; i++) cin userId problemId score; nums[userId].userId = userId; if (score 1) nums[userId].s[problemId] = max(0, nums[userId].s[problemId]); if (score = 0) nums[userId].isShow = true; if (score nums[userId].s[problemId]) if (score == w[problemId]) nums[userId].perfect++; nums[userId].totle += score - max(0, nums[userId].s[problemId]); nums[userId].s[problemId] = score; sort(nums, nums + 10001, cmp); int rank = 1; for (int i = 0; i 10000; i++) if (!nums[i].isShow) break; if (i != 0 nums[i].totle != nums[i - 1].totle) rank = i + 1; printf(%d %05d %d , rank, nums[i].userId, nums[i].totle); for (int j = 1; j = k; j++) if (nums[i].s[j] 0) cout -; else cout nums[i].s[j]; if (j k) cout ; else cout endl; return 0; 1076 Forwards on Weibo#include iostream#include vector#include queueusing namespace std;vectorint g[1001];bool visit[1001];int bfs(int u, int l) queueint q; q.push(u); fill(visit, visit + 1001, false); visit[u] = true; int res = 0, cnt = 0; while (!q.empty()) if (cnt = l) break; int len = q.size(); for (int i = 0; i len; i++) u = q.front(); q.pop(); for (int j = 0; j g[u].size(); j++) if (!visit[g[u][j]]) visit[g[u][j]] = true; res++; q.push(g[u][j]); cnt++; return res;int main() int n, l, m, x, k, query; cin n l; for (int i = 1; i = n; i++) cin m; for (int j = 0; j m; j++) cin x; g[x].push_back(i); cin k; for (int i = 0; i k; i++) cin query; int res = bfs(query, l); cout res endl; return 0; 1077 Kuchiguse#include iostream#include string#include algorithmusing namespace std;string strs[101];int main() int n, len = 257; cin n; getchar(); for (int i = 0; i n; i++) getline(cin, strs[i]); len = min((int)strs[i].size(), len); string res = ; for (int i = 1; i = len; i++) char ch = strs[0][strs[0].size() - i]; for (int j = 0; j n; j++) if (strs[j][strs[j].size() - i] != ch) if (res.empty()) cout nai; else cout res; return 0; res = ch + res; cout res; return 0; 1078 Hashing#include iostream#include algorithm#include vectorusing namespace std;const int N = 20001;vectorint primes;bool st[N];bool res[N];int main() int m, n, x; cin m n; for (int i = 2; i N; i++) if (!st[i]) primes.push_back(i); if (i = m) m = i; break; for (int j = i * 2; j N; j += i) st[j] = true; for (int i = 0; i n; i++) cin x; bool flag = false; for (int j = 0; j m; j++) if (!res[(x + j * j) % m]) cout (x + j * j) % m; res[(x + j * j) % m] = true; flag = true; break; if (!flag) cout -; if (i n - 1) cout ; return 0; 1079 Total Sales of Supply Chain#include iostream#include vectorusing namespace std;struct node int val; vectorint child; trees[100001];double r, res;void dfs(int u, double p) if (trees[u].child.empty()) res += trees[u].val * p; return; for (int i = 0; i trees[u].child.size(); i++) dfs(trees[u].child[i], p + p * r); int main() int n, k, x; double p; cin n p r; r /= 100; for (int i = 0; i n; i++) cin k; if (k == 0) cin x; trees[i].val = x; else for (int j = 0; j k; j++) cin x; trees[i].child.push_back(x); dfs(0, p); printf(%.1f, res); return 0; 1080 Graduate Admission#include iostream#include algorithm#include vectorusing namespace std;struct student int num, ge, gi, total, apps[6], rank; students[40001];int limits[101];vectorint schools[101];bool cmp(student a, student b) if (a.total != b.total) return a.total b.total; else if (a.ge != b.ge) return a.ge b.ge; else return a.num b.num;int main() int n, m, k, ge, gi, total, rank = 1; cin n m k; for (int i = 0; i m; i++) cin limits[i]; for (int i = 0; i n; i++) cin students[i].ge students[i].gi; students[i].total = students[i].ge + students[i].gi; for (int j = 0; j k; j++) cin students[i].apps[j]; students[i].num = i; sort(students, students + n, cmp); for (int i = 0; i n; i++) if (i != 0 (students[i].total != students[i - 1].total || students[i].ge != students[i - 1].ge)) rank++; students[i].rank = rank; for (int i = 0; i n; i++) for (int j = 0; j k; j++) int t = students[i].apps[j]; if (limits[t]) schools[t].push_back(students[i].num); limits[t]--; while (limits[t] == 0 i n - 1 students[i].rank == students[i + 1].rank) schools[t].push_back(students[i + 1].num); i++; break; for (int i = 0; i m; i++) sort(schools[i].begin(), schools[i].end()); for (int j = 0; j schools[i].size(); j++) cout schools[i][j]; if (j schools[i].size() - 1) cout ; cout endl; return 0; 1081 Rational Sum#include iostreamusing namespace std;typedef long long LL;LL gcd(LL a, LL b) if (b == 0) return a; else return gcd(b, a % b);void convert(LL a, LL b) if (a * b 0) cout -; a = abs(a); b = abs(b); LL t = a / b; if (t) cout t; a -= b * t; if (a == 0) if (t == 0) cout 0; return; if (t != 0) cout ; cout a / b;int main() LL n, numerator, denominator, a, b; cin n; for (int i = 0; i n; i++) scanf(%lld/%lld, a, b); if (i != 0) LL c = numerator * b + denominator * a; LL d = denominator * b; LL t = gcd(c, d); numerator = c / t; denominator = d / t; else numerator = a, denominator = b; convert(numerator, denominator); return 0; 1082 Read Number in Chinese大模拟 #include iostream#include vector#include stringusing namespace std;int main() string dicts[10] = ling, yi, er, san, si, wu, liu, qi, ba, jiu; int n; vectorstring res; cin n; if (n == 0) cout ling; return 0; if (n 0) res.push_back(Fu); n = -n; int raw = n; if (n = 100000000) res.push_back(dicts[n / 100000000]); res.push_back(Yi); n = n % 100000000; bool zero = false; if (n = 10000) if (n / 10000000) res.push_back(dicts[n / 10000000]); res.push_back(Qian); n %= 10000000; else if (raw 10000000) zero = true; if (n / 1000000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 1000000]); res.push_back(Bai); n %= 1000000; else if (raw 1000000) zero = true; if (n / 100000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 100000]); res.push_back(Shi); n %= 100000; else if (raw 100000) zero = true; if (n / 10000) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 10000]); n %= 10000; res.push_back(Wan); zero = false; if (n / 1000) res.push_back(dicts[n / 1000]); res.push_back(Qian); n %= 1000; else if (raw 1000) zero = true; if (n / 100) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 100]); res.push_back(Bai); n %= 100; else if (raw 100) zero = true; if (n / 10) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n / 10]); res.push_back(Shi); n %= 10; else if (raw 10) zero = true; if (n % 10) if (zero) res.push_back(ling); zero = false; res.push_back(dicts[n % 10]); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 优化 #include iostream#include vector#include stringusing namespace std;int main() string nums[10] = ling, yi, er, san, si, wu, liu, qi, ba, jiu; string wei[5] = Shi, Bai, Qian, Wan, Yi; string str; cin str; int len = str.length(); int left = 0, right = len - 1; if (str[0] == -) cout Fu; left++; while (left + 4 = right) right -= 4; while (left len) bool flag = false, isPrint = false; while (left = right) if (left 0 str[left] == 0) flag = true; else if (flag == true) cout ling; flag = false; if (left 0) cout ; cout nums[str[left] - 0]; isPrint = true; if (left != right) cout wei[right - left - 1]; left++; if (isPrint == true right != len - 1) cout wei[(len - 1 - right) / 4 + 2]; right += 4; return 0; 1083 List Grades#include iostream#include string#include algorithmusing namespace std;struct node string name, num; int grade; nums[100001];bool cmp(node a, node b) return a.grade b.grade;int main() int n, left, right; cin n; for (int i = 0; i n; i++) cin nums[i].name nums[i].num nums[i].grade; cin left right; sort(nums, nums + n, cmp); bool flag = true; for (int i = 0; i n; i++) if (nums[i].grade = left nums[i].grade = right) cout nums[i].name nums[i].num endl; flag = false; if (flag) cout NONE; return 0; 1084 Broken Keyboard#include iostream#include stringusing namespace std;bool st[256];int main() string a, b; cin a b; for (int i = 0; i a.size(); i++) if (isalpha(a[i])) a[i] = tolower(a[i]); st[a[i]] = true; for (int i = 0; i b.size(); i++) if (isalpha(b[i])) b[i] = tolower(b[i]); st[b[i]] = false; for (int i = 0; i a.size(); i++) if (st[a[i]]) char t = a[i]; if (isalpha(t)) t = toupper(t); cout t; st[a[i]] = false; return 0; 柳婼的 #include iostreamusing namespace std;int main() string s1, s2, res; cin s1 s2; for (int i = 0; i s1.size(); i++) if (s2.find(s1[i]) == string::npos res.find(toupper(s1[i])) == string::npos) res += toupper(s1[i]); cout res; return 0; 1085 Perfect Sequence暴力（超时） #include iostream#include algorithmusing namespace std;typedef long long LL;LL nums[100001], res = 1, p;void dfs(LL l, LL r) if (res r - l + 1) return; if (nums[l] * p nums[r]) dfs(l + 1, r); dfs(l, r - 1); else res = max(res, r - l + 1); int main() int n; cin n p; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); dfs(0, n - 1); cout res; return 0; 柳婼的 #include iostream#include algorithmusing namespace std;typedef long long LL;LL nums[100001];int main() int n, p, res = 1; cin n p; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); for (int i = 0; i n; i++) // res = max((int)(upper_bound(nums, nums + n, nums[i] * p) - (nums + i)), res); for (int j = i + res; j n; j++) if (nums[i] * p = nums[j]) res = max(res, j - i + 1); else break; cout res; return 0; 1086 Tree Traversals Again#include iostream#include stack#include string#include vectorusing namespace std;struct node int l, r; trees[31];stackint st;vectorint in, pre, post;int build(int preL, int preR, int inL, int inR) if (preL preR) return -1; int root = in[inL], idx = preL; for (int i = preL; i = preR; i++) if (root == pre[i]) idx = i; break; int cntL = idx - preL; trees[root].l = build(preL, preL + cntL - 1, inL + 1, inL + cntL); trees[root].r = build(idx + 1, preR, inL + cntL + 1, inR); return root;void dfs(int root) if (root == -1) return; dfs(trees[root].l); dfs(trees[root].r); post.push_back(root);int main() int n, x; string ops; cin n; for (int i = 0; i 2 * n; i++) cin ops; if (ops == Push) cin x; st.push(x); in.push_back(x); else pre.push_back(st.top()); st.pop(); int root = build(0, n - 1, 0, n - 1); dfs(root); for (int i = 0; i post.size(); i++) cout post[i]; if (i post.size() - 1) cout ; return 0; 柳婼的 #include iostream#include stack#include string#include vectorusing namespace std;stackint st;vectorint pre, in, post, value;void postorder(int root, int start, int end) if (start end) return; int i = start; while (i end in[i] != pre[root]) i++; postorder(root + 1, start, i - 1); postorder(root + 1 + i - start, i + 1, end); post.push_back(pre[root]);int main() int n, x, key = 0; string ops; cin n; for (int i = 0; i 2 * n; i++) cin ops; if (ops == Push) cin x; value.push_back(x); pre.push_back(key); st.push(key++); else in.push_back(st.top()); st.pop(); postorder(0, 0, n - 1); for (int i = 0; i n; i++) cout value[post[i]]; if (i n - 1) cout ; return 0; 1087 All Roads Lead to Rome#include iostream#include vector#include map#include stringusing namespace std;typedef pairint, int PII;const int N = 201;const int INF = 0x3f3f3f3f;mapstring, int strToInt;string intToStr[N], start;vectorPII g[N];int d[N], haps[N], pre[N], cnt[N], happys[N], cnt2[N], n;bool visit[N];void dijkstra(int a) fill(d, d + n, INF); d[a] = 0; cnt2[a] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] d[j] mind) u = j; mind = d[j]; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].first, dis = g[u][j].second; if (!visit[v]) if (d[v] d[u] + dis) d[v] = d[u] + dis; happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; cnt2[v] = cnt2[u]; pre[v] = u; else if (d[v] == d[u] + dis) if (happys[v] happys[u] + haps[v]) happys[v] = happys[u] + haps[v]; cnt[v] = cnt[u] + 1; pre[v] = u; else if (happys[v] == happys[u] + haps[v]) if (cnt[v] cnt[u] + 1) cnt[v] = cnt[u] + 1; pre[v] = u; cnt2[v] += cnt2[u]; vectorint res;void dfs(int u) res.push_back(u); if (u == strToInt[start]) for (int i = res.size() - 1; i = 0; i--) cout intToStr[res[i]]; if (i 0) cout -; else dfs(pre[u]); int main() string city1, city2; int k, hap, cost; cin n k start; for (int i = 0; i n - 1; i++) cin city1 hap; strToInt[city1] = i; intToStr[i] = city1; haps[i] = hap; strToInt[start] = n - 1; intToStr[n - 1] = start; for (int i = 0; i k; i++) cin city1 city2 cost; g[strToInt[city1]].push_back(strToInt[city2], cost); g[strToInt[city2]].push_back(strToInt[city1], cost); dijkstra(strToInt[start]); cout cnt2[strToInt[ROM]] d[strToInt[ROM]] happys[strToInt[ROM]] happys[strToInt[ROM]] / cnt[strToInt[ROM]] endl; dfs(strToInt[ROM]); return 0; 1088 Rational Arithmetic#include iostream#include stringusing namespace std;typedef long long LL;LL gcd(LL a, LL b) if (b == 0) return a; return gcd(b, a % b);string convert(LL a, LL b) string res; if (b == 0) return Inf; LL tt = a; if (tt 0) res += (-; a = abs(a), b = abs(b); LL d = gcd(a, b); a /= d; b /= d; LL t = a / b; a -= t * b; if (t a) res += to_string(t) + + to_string(a) + / + to_string(b); else if(t a == 0) res += to_string(t); else if(t == 0 a) res += to_string(a) + / + to_string(b); else res += 0; if (tt 0) res += ); return res;string add(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2 + a2 * b1; b = b1 * b2; return convert(a, b);string sub(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2 - a2 * b1; b = b1 * b2; return convert(a, b);string mul(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * a2; b = b1 * b2; return convert(a, b);string div(LL a1, LL b1, LL a2, LL b2) LL a, b; a = a1 * b2; b = b1 * a2; if (b 0) a = -a, b = -b; return convert(a, b);int main() LL a1, b1, a2, b2; scanf(%lld/%lld %lld/%lld, a1, b1, a2, b2); cout convert(a1, b1) + convert(a2, b2) = add(a1, b1, a2, b2) endl; cout convert(a1, b1) - convert(a2, b2) = sub(a1, b1, a2, b2) endl; cout convert(a1, b1) * convert(a2, b2) = mul(a1, b1, a2, b2) endl; cout convert(a1, b1) / convert(a2, b2) = div(a1, b1, a2, b2) endl; return 0; 1089 Insert or Merge#include iostream#include algorithmusing namespace std;const int N = 101;int nums[N], now[N], tmp[N], tmp2[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) cin now[i]; int id = 0; for (int i = 0; i n - 1; i++) if (now[i + 1] now[i]) id = i; break; bool isInsert = true; for (int j = id + 1; j n; j++) if (nums[j] != now[j]) isInsert = false; break; if (isInsert) cout Insertion Sort endl; sort(nums, nums + id + 2); else cout Merge Sort endl; bool flag = true; int k = 1; while (flag) flag = false; for (int i = 0; i n; i++) if (nums[i] != now[i]) flag = true; k *= 2; for (int i = 0; i n / k; i++) sort(nums + i * k, nums + (i + 1) * k); sort(nums + n / k * k, nums + n); for (int i = 0; i n; i++) cout nums[i]; if (i n - 1) cout ; return 0; 1090 Highest Price in Supply Chain#include iostream#include vectorusing namespace std;vectorint g[100001];int cnt[100001], res = 0;void dfs(int n, int t) if (res t) res = t; cnt[t] = 1; else cnt[t]++; for (int i = 0; i g[n].size(); i++) dfs(g[n][i], t + 1); int main() int n, x; double p, r; cin n p r; for (int i = 0; i n; i++) cin x; if (x == -1) g[n].push_back(i); else g[x].push_back(i); dfs(n, 0); for (int i = 0; i res - 1; i++) p *= (100 + r) / 100.0; printf(%.2f %d, p, cnt[res]); return 0; 1091 Acute Stroke#include iostream#include queueusing namespace std;int g[61][1287][129], m, n, l, t;bool v[61][1287][129];struct node int i, j, k;;int x[6] = 1, -1, 0, 0, 0, 0;int y[8] = 0, 0, 1, -1, 0, 0;int z[8] = 0, 0, 0, 0, 1, -1;int bfs(int i, int j, int k) v[i][j][k] = true; int cnt = 1; queuenode q; q.push(i, j, k); while (!q.empty()) node u = q.front(); q.pop(); i = u.i, j = u.j, k = u.k; for (int id = 0; id 6; id++) int a = i + x[id], b = j + y[id], c = k + z[id]; if (a = 0 a l b = 0 b m c = 0 c n !v[a][b][c] g[a][b][c] == 1) cnt++; v[a][b][c] = true; q.push(a, b, c); if (cnt t) return 0; else return cnt;int main() cin m n l t; for (int i = 0; i l; i++) for (int j = 0; j m; j++) for (int k = 0; k n; k++) scanf(%d, g[i][j][k]); int res = 0; for (int i = 0; i l; i++) for (int j = 0; j m; j++) for (int k = 0; k n; k++) if (!v[i][j][k] g[i][j][k]) res += bfs(i, j, k); cout res; return 0; 1092 To Buy or Not to Buy#include iostream#include stringusing namespace std;int nums[256];int main() string a, b; cin a b; for (int i = 0; i a.size(); i++) nums[a[i]]++; bool flag = true; int cnt = 0; for (int i = 0; i b.size(); i++) if (nums[b[i]] = 0) flag = false; cnt++; nums[b[i]]--; if (flag) cout Yes a.size() - b.size(); else cout No cnt; return 0; 1093 Count PAT’s#include iostream#include stringusing namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() string str; cin str; int res = 0; for (int i = 1; i str.size(); i++) p[i] = p[i - 1]; if (str[i - 1] == P) p[i]++; for (int i = str.size() - 1; i = 0; i--) t[i] = t[i + 1]; if (str[i + 1] == T) t[i]++; for (int i = 1; i str.size() - 1; i++) if (str[i] == A) res = (res + p[i] * t[i] % MOD) % MOD; cout res; return 0; 柳婼的 #include iostream#include stringusing namespace std;const int N = 100001;const int MOD = 1000000007;int p[N], t[N];int main() string s; cin s; int res = 0, len = s.size(), p = 0, t = 0; for (int i = 0; i len; i++) if (s[i] == T) t++; for (int i = 0; i len; i++) if (s[i] == P) p++; if (s[i] == T) t--; if (s[i] == A) res = (res + p * t % MOD) % MOD; cout res; return 0; 1094 The Largest Generation#include iostream#include vector#include queueusing namespace std;vectorint trees[101];int res, cntn;void bfs(int u) queueint q; q.push(u); int depth = 1; while (!q.empty()) int cnt = q.size(); for (int i = 0; i cnt; i++) u = q.front(); q.pop(); for (int j = 0; j trees[u].size(); j++) q.push(trees[u][j]); if (cntn cnt) res = depth; cntn = cnt; depth++; return;int main() int n, m, id, k, x; cin n m; for (int i = 0; i m; i++) cin id k; for (int j = 0; j k; j++) cin x; trees[id].push_back(x); bfs(1); cout cntn res; return 0; 1095 Cars on Campus#include iostream#include string#include vector#include map#include algorithmusing namespace std;struct node int time; string op;;bool cmp(node a, node b) return a.time b.time;mapstring, int strToInt;mapint, string intToStr;vectornode nums[10001], finall;int times[86401];int main() string a, op; int n, k, h, m, s, id = 1; cin n k; for (int i = 0; i n; i++) cin a; if (!strToInt[a]) strToInt[a] = id; intToStr[id++] = a; scanf(%d:%d:%d, h, m, s); cin op; int time = h * 60 * 60 + m * 60 + s; nums[strToInt[a]].push_back(time, op); int total[id + 1]; for (int i = 1; i id; i++) sort(nums[i].begin(), nums[i].end(), cmp); for (int j = 0; j nums[i].size() - 1; j++) if (nums[i][j].op == in nums[i][j + 1].op == out) finall.push_back(nums[i][j]); finall.push_back(nums[i][j + 1]); total[i] += nums[i][j + 1].time - nums[i][j].time; sort(finall.begin(), finall.end(), cmp); int t = 0; for (int i = 0; i = 86400; i++) if (i != 0) times[i] = times[i - 1]; while (finall[t].time == i) if (finall[t].op == in) times[i]++; else times[i]--; t++; if (t == finall.size()) break; for (int i = 0; i k; i++) scanf(%d:%d:%d, h, m, s); int time = h * 60 * 60 + m * 60 + s; cout times[time] endl; int maxTime = 0; vectorstring res; for (int i = 0; i id; i++) if (maxTime total[i]) maxTime = total[i]; res.clear(); res.push_back(intToStr[i]); else if (maxTime == total[i]) res.push_back(intToStr[i]); for (auto it: res) cout it ; h = maxTime / 3600, m = maxTime % 3600 / 60, s = maxTime % 60; printf(%02d:%02d:%02d, h, m, s); return 0; 1096 Consecutive Factors#include iostream#include cmathusing namespace std;typedef long long LL;int main() LL n, t; cin n; int l = 0, j = 0, res = 0; for (int i = 2; i sqrt(n) + 1; i++) t = 1; for (j = i; j sqrt(n) + 1; j++) t *= j; if (n % t != 0) break; if (j - i l) l = j - i; res = i; if (l == 0) cout 1 n; else cout l endl; for (int k = res; k l + res; k++) cout k; if (k l + res - 1) cout *; return 0; 1097 Deduplication on a Linked List#include iostream#include vectorusing namespace std;const int N = 100001;struct node int add, key, nex; nums[N];bool st[N];int main() int start, n, add, key, nex; cin start n; for (int i = 0; i n; i++) cin add key nex; nums[add] = add, key, nex; vectornode list, red; while (start != -1) if (!st[abs(nums[start].key)]) list.push_back(nums[start]); st[abs(nums[start].key)] = true; else red.push_back(nums[start]); start = nums[start].nex; if (!list.empty()) for (int i = 0; i list.size() - 1; i++) printf(%05d %d %05d , list[i].add, list[i].key, list[i + 1].add); printf(%05d %d -1 , list[list.size() - 1].add, list[list.size() - 1].key); if (!red.empty()) for (int i = 0; i red.size() - 1; i++) printf(%05d %d %05d , red[i].add, red[i].key, red[i + 1].add); printf(%05d %d -1 , red[red.size() - 1].add, red[red.size() - 1].key); return 0; 1098 Insertion or Heap Sort错误答案 #include iostream#include algorithmusing namespace std;const int N = 101;int a[N], b[N];int main() int n; cin n; for (int i = 0; i n; i++) cin a[i]; for (int i = 0; i n; i++) cin b[i]; int id = 0; for (int i = 1; i n; i++) if (b[i] = b[i - 1]) id = i; else break; bool isInsert = true; for (int j = id + 1; j n; j++) if (a[j] != b[j]) isInsert = false; break; if (isInsert) cout Insertion Sort endl; sort(b, b + id + 2); else cout Heap Sort endl; int i = 0, t = b[0]; while(2 * i + 1 n) if (b[2 * i + 1] b[2 * i + 2]) swap(b[2 * i + 1], b[2 * i + 2]); if (b[i] b[2 * i + 2]) swap(b[i], b[2 * i + 2]); i = 2 * i + 2; else if (b[i] b[2 * i + 1]) swap(b[i], b[2 * i + 1]); i = 2 * i + 1; else break; for (int i = 0; i n; i++) cout b[i]; if (i n - 1) cout ; return 0; 柳婼的 #include iostream#include vector#include algorithmusing namespace std;void down(vectorint b, int low, int high) int i = 1, j = i * 2; while (j = high) if (j + 1 = high b[j] b[j + 1]) j = j + 1; if (b[i] = b[j]) break; swap(b[i], b[j]); i = j; j = i * 2; int main() int n, p = 2; cin n; vectorint a(n + 1), b(n + 1); for (int i = 1; i = n; i++) cin a[i]; for (int i = 1; i = n; i++) cin b[i]; while (p = n b[p - 1] = b[p]) p++; int idx = p; while (p = n a[p] == b[p]) p++; if (p == n + 1) cout Insertion Sort ; sort(b.begin() + 1, b.begin() + idx + 1); else cout Heap Sort ; p = n; while(p 2 b[p] = b[1]) p--; swap(b[1], b[p]); down(b, 1, p - 1); for (int i = 1; i = n; i++) cout b[i]; if (i n) cout ; return 0; 1099 Build A Binary Search Tree#include iostream#include vector#include queue#include algorithmusing namespace std;const int N = 101;struct node int data, l, r; a[N];int b[N], cnt;vectorint res;void dfs(int root) if (root == -1) return; dfs(a[root].l); a[root].data = b[cnt++]; dfs(a[root].r);void bfs(int root) queueint q; q.push(root); while (!q.empty()) root = q.front(); q.pop(); res.push_back(a[root].data); if (a[root].l != -1) q.push(a[root].l); if (a[root].r != -1) q.push(a[root].r); int main() int n; cin n; for (int i = 0; i n; i++) cin a[i].l a[i].r; for (int i = 0; i n; i++) cin b[i]; sort(b, b + n); dfs(0); bfs(0); for (int i = 0; i n; i++) cout res[i]; if (i n - 1) cout ; return 0; 1100 Mars Numbers#include iostream#include stringusing namespace std;int main() int n; string x; string shi[12] = tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou; string ge[12] = jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec; cin n; getchar(); for (int i = 0; i n; i++) getline(cin, x); if (x == 0) cout tret endl; else if (isdigit(x[0])) int t = stoi(x); int a = t / 13; int b = t % 13; if (a b) cout shi[a - 1] ge[b - 1] endl; else if (a) cout shi[a - 1] endl; else if (b) cout ge[b - 1] endl; else if (x == tret) cout 0 endl; else if (x.size() 3) int a = 0; for (int i = 0; i 12; i++) if (x.substr(0, 3) == shi[i]) a += (i + 1) * 13; if (x.substr(4, 3) == ge[i]) a += i + 1; cout a endl; else for (int i = 0; i 12; i++) if (x == shi[i]) cout (i + 1) * 13 endl; if (x == ge[i]) cout i + 1 endl; return 0; 1101 Quick Sort#include iostream#include vector#include algorithmusing namespace std;const int N = 100001;const int INF = 0x3f3f3f3f;int nums[N], minr[N], maxl[N];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; fill(minr, minr + n, INF); for (int i = 1; i n; i++) maxl[i] = max(maxl[i - 1], nums[i - 1]); for (int i = n - 2; i = 0; i--) minr[i] = min(minr[i + 1], nums[i + 1]); vectorint res; for (int i = 0; i n; i++) if (nums[i] = maxl[i] nums[i] = minr[i]) res.push_back(nums[i]); cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; cout endl; return 0; 柳婼的 #include iostream#include vector#include algorithmusing namespace std;int v[100001];int main() int n, max = 0, cnt = 0; cin n; vectorint a(n), b(n); for (int i = 0; i n; i++) cin a[i]; b[i] = a[i]; sort(a.begin(), a.end()); for (int i = 0; i n; i++) if (a[i] == b[i] b[i] max) v[cnt++] = b[i]; if (b[i] max) max = b[i]; cout cnt endl; for (int i = 0; i cnt; i++) cout v[i]; if (i cnt - 1) cout ; cout endl; return 0; 1102 Invert a Binary Tree#include iostream#include vector#include queueusing namespace std;struct node int l, r; trees[11];bool st[11];vectorint level, in;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); level.push_back(u); q.pop(); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); void dfs(int u) if (u == -1) return; dfs(trees[u].l); in.push_back(u); dfs(trees[u].r);int main() int n, root; char a, b; cin n; for (int i = 0; i n; i++) cin a b; if (isdigit(a)) trees[i].r = a - 0; st[a - 0] = true; else trees[i].r = -1; if (isdigit(b)) trees[i].l = b - 0; st[b - 0] = true; else trees[i].l = -1; for (int i = 0; i n; i++) if (!st[i]) root = i; bfs(root); dfs(root); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; else cout endl; for (int i = 0; i n; i++) cout in[i]; if (i n - 1) cout ; return 0; 1103 Integer Factorizationdfs #include iostream#include vector#include cmathusing namespace std;vectorint res, tmp, v;int n, k, p, t, m, sumt, mint = -1;void dfs(int idx, int a) if (a == k t == n) if (sumt mint) mint = sumt; res = tmp; return; if (a = k || t = n) return; for (int i = idx; i = 0; i--) t += v[i]; sumt += i; tmp.push_back(i + 1); dfs(i, a + 1); tmp.pop_back(); sumt -= i; t -= v[i]; int main() cin n k p; for (int i = 1; i = n; i++) int b = pow(i, p); v.push_back(b); if (b n) break; dfs(v.size() - 1, 0); if (mint == -1) cout Impossible; else cout n = ; for (int i = 0; i res.size(); i++) cout res[i] ^ p; if (i res.size() - 1) cout + ; return 0; 1104 Sum of Number Segments精度问题（坑） #include iostreamusing namespace std;const int N = 100001;double nums[N];int n;int main() cin n; for (int i = 0; i n; i++) cin nums[i]; long long res = 0; for (int i = 0; i n; i++) res += (long long)(nums[i] * 1000) * i * (n - i + 1); printf(%.2f, res / 1000.0); return 0; 柳婼的 #include iostreamusing namespace std;int main() int n; double tmp; long long res; cin n; for (int i = 1; i = n; i++) cin tmp; res += (long long)(tmp * 1000) * i * (n - i + 1); printf(%.2f, res / 1000.0); return 0; 1105 Spiral Matrix#include iostream#include algorithm#include cmathusing namespace std;int nums[10001], id, res[100][100];int main() int t, n, m, mi = 10001; cin t; for (int i = 0; i t; i++) cin nums[i]; sort(nums, nums + t, greaterint()); for (int i = 1; i * i = t; i++) if (t % i == 0) n = i; m = t / n; int l = 0, r = n - 1, u = 0, d = m - 1; while (l = r u = d) for (int i = l; i = r; i++) res[u][i] = nums[id++]; u++; if (u d) break; for (int i = u; i = d; i++) res[i][r] = nums[id++]; r--; if (r l) break; for (int i = r; i = l; i--) res[d][i] = nums[id++]; d--; if (u d) break; for (int i = d; i = u; i--) res[i][l] = nums[id++]; l++; if (l r) break; for (int i = 0; i m; i++) for (int j = 0; j n; j++) cout res[i][j]; if (j n - 1) cout ; cout endl; return 0; 1106 Lowest Price in Supply Chain#include iostream#include vector#include queue#include cmathusing namespace std;vectorint trees[100001];int depth = 1, cnt = 0;void bfs(int u) queueint q; q.push(u); bool flag = false; while (!q.empty()) int size = q.size(); cnt = 0; for (int i = 0; i size; i++) u = q.front(); q.pop(); if (trees[u].empty()) flag = true; cnt++; for (int i = 0; i trees[u].size(); i++) q.push(trees[u][i]); if (flag) return; depth++; int main() int n, k, x; double p, r; cin n p r; for (int i = 0; i n; i++) cin k; for (int j = 0; j k; j++) cin x; trees[i].push_back(x); bfs(0); printf(%.4f %d, p * pow(1 + r / 100, depth - 1), cnt); return 0; 1107 Social Clusters#include iostream#include stringusing namespace std;int main() int n, cnt = 0; string x; double sum, t; cin n; for (int i = 0; i n; i++) cin x; try t = stod(x); if (t 1000 || t -1000) cout ERROR: x is not a legal number endl; continue; int j = 0; bool flag = true; while (j x.size() x[j] != .) j++; if (j != x.size() j + 3 x.size()) cout ERROR: x is not a legal number endl; continue; if (flag) cnt++; sum += t; catch(exception) cout ERROR: x is not a legal number endl; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; 1108 Finding Average#include iostream#include stringusing namespace std;int main() int n, cnt = 0; string x; double sum, t; cin n; for (int i = 0; i n; i++) cin x; try t = stod(x); if (t 1000 || t -1000) cout ERROR: x is not a legal number endl; continue; int j = 0; bool flag = true; while (j x.size() x[j] != .) j++; if (j != x.size() j + 3 x.size()) cout ERROR: x is not a legal number endl; continue; if (flag) cnt++; sum += t; // cout t sum cnt endl; catch(exception) cout ERROR: x is not a legal number endl; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; 柳婼的 #include iostream#include cstringusing namespace std;int main() int n, cnt = 0; char a[50], b[50]; double t, sum; cin n; for (int i = 0; i n; i++) cin a; sscanf(a, %lf, t); sprintf(b, %.2f, t); bool flag = false; for (int j = 0; j strlen(a); j++) if (a[j] != b[j]) flag = true; if (flag || t -1000 || t 1000) cout ERROR: a is not a legal number endl; continue; else sum += t; cnt++; if (cnt == 0) cout The average of 0 numbers is Undefined endl; else if (cnt == 1) printf(The average of 1 number is %.2f, sum); else printf(The average of %d numbers is %.2f, cnt, sum / cnt); return 0; 1109 Group Photo#include iostream#include string#include map#include algorithmusing namespace std;typedef pairstring, int PII;PII nums[10001];bool cmp(PII a, PII b) if (a.second != b.second) return a.second b.second; return a.first b.first;void fun(int start, int n) if (n % 2 == 0) for (int i = n - 1; i = 1; i-=2) cout nums[start + i].first ; for (int i = 0; i n; i+=2) cout nums[start + i].first; if (i + 2 == n) cout endl; else cout ; else for (int i = n - 2; i = 1; i-=2) cout nums[start + i].first ; for (int i = 0; i n; i+=2) cout nums[start + i].first; if (i + 1 == n) cout endl; else cout ; int main() int n, k, height; string name; cin n k; for (int i = 0; i n; i++) cin name height; nums[i] = name, height; sort(nums, nums + n, cmp); int num = n / k; int last = n - num * k + num; fun(0, last); for (int j = 1; j k; j++) fun(last + (j - 1) * num, num); return 0; 1110 Complete Binary Treebfs #include iostream#include string#include queueusing namespace std;struct node int l = -1, r = -1; nums[100];bool st[100], isCBT = true, flag;int bfs(int u) queueint q; q.push(u); int cnt = 1, a = 0; while(!q.empty()) u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (flag) isCBT = false; else flag = true; if (nums[u].r != -1) q.push(nums[u].r); if (flag) isCBT = false; else flag = true; return u;int main() int n, root = 0; string l, r; cin n; for (int i = 0; i n; i++) cin l r; if (l != -) nums[i].l = stoi(l); st[stoi(l)] = true; if (r != -) nums[i].r = stoi(r); st[stoi(r)] = true; for (int i = 0; i n; i++) if (!st[i]) root = i; int last = bfs(root); if (!isCBT) cout NO root; else cout YES last; return 0; dfs #include iostream#include string#include queueusing namespace std;struct node int l = -1, r = -1; nums[100];bool st[100];int maxn = -1, last;void dfs(int root, int index) if (maxn index) maxn = index; last = root; if (nums[root].l != -1) dfs(nums[root].l, index * 2); if (nums[root].r != -1) dfs(nums[root].r, index * 2 + 1);int main() int n, root = 0; string l, r; cin n; for (int i = 0; i n; i++) cin l r; if (l != -) nums[i].l = stoi(l); st[stoi(l)] = true; if (r != -) nums[i].r = stoi(r); st[stoi(r)] = true; for (int i = 0; i n; i++) if (!st[i]) root = i; dfs(root, 1); if (maxn != n) cout NO root; else cout YES last; return 0; 1111 Online Mapdijkstra #include iostream#include vectorusing namespace std;const int N = 501;const int INF = 0x3f3f3f3f;struct node int v, dist, time;;vectornode g[N];int d[N], cost1[N], cost2[N], cnt[N], pre[N], start, dest, n;bool visit[N];void dijkstra1(int a) fill(d, d + N, INF); d[a] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind d[j]) mind = d[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (d[u] + dist d[v]) d[v] = d[u] + dist; cost1[v] = cost1[u] + time; pre[v] = u; else if (d[u] + dist == d[v]) if (cost1[v] cost1[u] + time) pre[v] = u; cost1[v] = cost1[u] + time; vectorint res1;void dfs1(int x) if (x != start) res1.push_back(x); dfs1(pre[x]); else res1.push_back(start);void dijkstra2(int a) fill(cost2, cost2 + N, INF); fill(visit, visit + N, false); cost2[a] = 0; cnt[a] = 1; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 0; j n; j++) if (!visit[j] mind cost2[j]) mind = cost2[j]; u = j; if (u == -1) return; visit[u] = true; for (int j = 0; j g[u].size(); j++) int v = g[u][j].v, dist = g[u][j].dist, time = g[u][j].time; if (cost2[u] + time cost2[v]) cost2[v] = cost2[u] + time; cnt[v] = cnt[u] + 1; pre[v] = u; else if (cost2[u] + time == cost2[v]) if (cnt[v] cnt[u] + 1) pre[v] = u; cnt[v] = cnt[u] + 1; vectorint res2;void dfs2(int x) if (x != start) res2.push_back(x); dfs2(pre[x]); else res2.push_back(start);int main() int m, v1, v2, one, len, time; cin n m; for (int i = 0; i m; i++) cin v1 v2 one len time; g[v1].push_back(v2, len, time); if (!one) g[v2].push_back(v1, len, time); cin start dest; dijkstra1(start); dfs1(dest); dijkstra2(start); dfs2(dest); if (res1 == res2) cout Distance = d[dest] ; Time = cost2[dest] : ; for (int i = res1.size() - 1; i = 0; i--) cout res1[i]; if (i 0) cout - ; else cout Distance = d[dest] : ; for (int i = res1.size() - 1; i = 0; i--) cout res1[i]; if (i 0) cout - ; else cout endl; cout Time = cost2[dest] : ; for (int i = res2.size() - 1; i = 0; i--) cout res2[i]; if (i 0) cout - ; return 0; 1112 Stucked Keyboard#include iostream#include stringusing namespace std;int st[257];int main() int k, i = 0; string a; cin k a; for (; i = a.size() - k; i++) char t = a[i]; bool flag = false; for (int j = i + 1; j i + k; j++) if (a[j] != t) flag = true; break; if (flag) st[t] = 1; else i += k - 1; for (; i a.size(); i++) st[a[i]] = 1; for (int i = 0; i a.size(); i++) if (!st[a[i]]) cout a[i]; st[a[i]] = 2; cout endl; for (int i = 0; i a.size(); i++) if (st[a[i]] == 1) cout a[i]; else if (st[a[i]] == 2) cout a[i]; i += k - 1; return 0; 1113 Integer Set Partition#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); long long res = 0; for (int i = 0; i n / 2; i++) res += nums[n - i - 1] - nums[i]; if (n % 2 == 0) cout 0 res; else res += nums[n / 2]; cout 1 res; return 0; 1114 Family Property#include iostream#include vector#include set#include algorithmusing namespace std;const int N = 10001;struct node int fa, mo, set, area; vectorint childs; nums[N];struct family int id, cnt; double set, area;;bool cmp(family a, family b) if (a.area != b.area) return a.area b.area; return a.id b.id;bool visit[N];int fa[N], cnt[N];setint ids, ids2, resid;int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];void union1(int a, int b) ids.insert(b); int fa1 = find(a); int fb = find(b); if (fa1 != fb) if (fa1 fb) fa[fb] = fa1; else fa[fa1] = fb; int main() int n, id, k, child; for (int i = 1; i N; i++) fa[i] = i; cin n; for (int i = 0; i n; i++) cin id; ids.insert(id); ids2.insert(id); cin nums[id].fa nums[id].mo k; if (nums[id].fa != -1) union1(id, nums[id].fa); if (nums[id].mo != -1) union1(id, nums[id].mo); for (int i = 0; i k; i++) cin child; nums[id].childs.push_back(child); union1(id, child); cin nums[id].set nums[id].area; for (auto id: ids) cnt[find(id)]++; resid.insert(find(id)); family tmp[N]; for (int i = 0; i N; i++) if (cnt[i]) tmp[i] = i, cnt[i], 0, 0; for (auto id: ids2) tmp[find(id)].set += nums[id].set; tmp[find(id)].area += nums[id].area; vectorfamily res; for (auto id: resid) tmp[id].set /= tmp[id].cnt; tmp[id].area /= tmp[id].cnt; res.push_back(tmp[id]); sort(res.begin(), res.end(), cmp); cout res.size() endl; for (int i = 0; i res.size(); i++) printf(%04d %d %.3f %.3f , res[i].id, res[i].cnt, res[i].set, res[i].area); return 0; 1115 Counting Nodes in a Binary Search Tree#include iostream#include queueusing namespace std;struct node int data, l = -1, r = -1; nums[1001];int idx = 0, last = 0, llast = 0;void insert(int x, int root) if (x = nums[root].data) if (nums[root].l == -1) nums[root].l = idx; nums[idx++].data = x; else insert(x, nums[root].l); else if (nums[root].r == -1) nums[root].r = idx; nums[idx++].data = x; else insert(x, nums[root].r); void bfs(int u) queueint q; q.push(u); while (!q.empty()) int size = q.size(); llast = last; last = size; for (int i = 0; i size; i++) u = q.front(); q.pop(); if (nums[u].l != -1) q.push(nums[u].l); if (nums[u].r != -1) q.push(nums[u].r); int main() int n, root, x; cin n root; nums[idx++].data = root; for (int i = 1; i n; i++) cin x; insert(x, 0); bfs(0); cout last + llast = last + llast; return 0; 1116 Come on! Let’s C#include iostream#include mapusing namespace std;const int N = 10001;bool st[N], visit[N];mapint, int nums;int main() for (int i = 2; i N; i++) if (!st[i]) for (int j = i * 2; j N; j += i) st[j] = true; int n, x; cin n; for (int i = 1; i = n; i++) cin x; nums[x] = i; cin n; for (int i = 0; i n; i++) cin x; if (nums[x] == 0) printf(%04d: Are you kidding? , x); else if (visit[x]) printf(%04d: Checked , x); else if (nums[x] == 1) printf(%04d: Mystery Award , x); visit[x] = true; else if (!st[nums[x]]) printf(%04d: Minion , x); visit[x] = true; else printf(%04d: Chocolate , x); visit[x] = true; return 0; 1117 Eddington Number#include iostream#include algorithmusing namespace std;int nums[100001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n, greaterint()); int res = 0; for (int i = 1; i = n; i++) if (i = nums[i - 1]) break; else res = i; cout res; return 0; 1118 Birds in Forest#include iostream#include setusing namespace std;const int N = 10001;int fa[N], cnt[N], maxb;setint birds;int find(int x) if (fa[x] != x) fa[x] = find(fa[x]); return fa[x];void union1(int a, int b) int faa = find(a); int fbb = find(b); if (faa != fbb) fa[fbb] = faa; int main() for (int i = 1; i N; i++) fa[i] = i; int n, k, x, y; cin n; for (int i = 0; i n; i++) cin k x; maxb = max(maxb, x); for (int j = 1; j k; j++) cin y; maxb = max(maxb, y); union1(x, y); int mtree = 0; for (int i = 1; i = maxb; i++) if (find(i) == i) mtree++; cout mtree maxb endl; cin k; for (int i = 0; i k; i++) cin x y; if (fa[x] != fa[y]) cout No endl; else cout Yes endl; return 0; 1119 Pre- and Post-order Traversals#include iostream#include vectorusing namespace std;const int N = 31;int pre[N], post[N];vectorint in;bool flag = true;void getIn(int preleft, int preright, int postleft, int postright) if (preleft == preright) in.push_back(pre[preleft]); return; if (pre[preleft] == post[postright]) int i = preleft + 1; while (i = preright pre[i] != post[postright - 1]) i++; if (i - preleft 1) getIn(preleft + 1, i - 1, postleft, postleft + (i - preleft - 1) - 1); else flag = false; in.push_back(post[postright]); getIn(i, preright, postleft + (i - preleft - 1), postright - 1); int main() int n; cin n; for (int i = 0; i n; i++) cin pre[i]; for (int i = 0; i n; i++) cin post[i]; getIn(0, n - 1, 0, n - 1); if (flag) cout Yes endl; else cout No endl; for (int i = 0; i in.size(); i++) cout in[i]; if (i in.size() - 1) cout ; else cout endl; return 0; 1120 Friend Numbers#include iostream#include vectorusing namespace std;int nums[40];int main() int n, x; cin n; for (int i = 0; i n; i++) cin x; int t = 0; while (x 0) t += x % 10; x /= 10; nums[t]++; vectorint res; for (int i = 0; i 40; i++) if (nums[i]) res.push_back(i); cout res.size() endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1121 Damn Single#include iostream#include vector#include algorithmusing namespace std;const int N = 100001;int g[N], tmp[N];int main() fill(g, g + N, -1); fill(tmp, tmp + N, -1); int n, a, b, m, c; cin n; for (int i = 0; i n; i++) cin a b; g[a] = b; g[b] = a; cin m; vectorint tmp1, res; for (int i = 0; i m; i++) cin c; if (g[c] == -1) res.push_back(c); else if (tmp[g[c]] == -1) tmp[g[c]] = 1; tmp1.push_back(c); for (auto i: tmp1) if (tmp[i] == -1) res.push_back(i); sort(res.begin(), res.end()); cout res.size() endl; for (int i = 0; i res.size(); i++) printf(%05d, res[i]); if (i res.size() - 1) cout ; return 0; 1122 Hamiltonian Cycle#include iostream#include vectorusing namespace std;int n, g[201][201];bool visit[201];bool check(int q) bool flag = true; if (q != n + 1) flag = false; fill(visit, visit + 201, false); int x, last, start; cin last; start = last; visit[start] = true; for (int i = 1; i q; i++) cin x; if (!g[last][x]) flag = false; visit[x] = true; last = x; if (start != last) flag = false; for (int i = 1; i = n; i++) if (!visit[i]) flag = false; return flag;int main() int m, a, b, k, q; cin n m; for (int i = 0; i m; i++) cin a b; g[a][b] = 1; g[b][a] = 1; cin k; for (int i = 0; i k; i++) cin q; if (check(q)) cout YES endl; else cout NO endl; return 0; 柳婼的 #include iostream#include vector#include setusing namespace std;int main() int n, m, cnt, k, a[201][201] = 0; cin n m; for (int i = 0; i m; i++) int t1, t2; cin t1 t2; a[t1][t2] = a[t2][t1] = 1; cin cnt; while (cnt--) cin k; vectorint v(k); setint s; int flag1 = 1, flag2 = 1; for (int i = 0; i k; i++) cin v[i]; s.insert(v[i]); if (s.size() != n || k - 1 != n || v[0] != v[k - 1]) flag1 = 0; for (int i = 0; i k - 1; i++) if (a[v[i]][v[i+1]] == 0) flag2 = 0; printf(%s, flag1 flag2 ? YES : NO ); return 0; 1123 Is It a Complete AVL Tree#include iostream#include queueusing namespace std;struct node int val; node *left, *right;;node* rotateLeft(node* root) node *t = root-right; root-right = t-left; t-left = root; return t;node* rotateRight(node* root) node *t = root-left; root-left = t-right; t-right = root; return t;node* rotateLeftRight(node* root) root-left = rotateLeft(root-left); return rotateRight(root);node* rotateRightLeft(node* root) root-right = rotateRight(root-right); return rotateLeft(root);int getHeight(node* root) if (root == NULL) return 0; return max(getHeight(root-left), getHeight(root-right)) + 1;node* insert(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-left = NULL; root-right = NULL; else if (val root-val) root-left = insert(root-left, val); if (getHeight(root-left) - getHeight(root-right) == 2) root = val root-left-val ? rotateRight(root) : rotateLeftRight(root); else root-right = insert(root-right, val); if (getHeight(root-right) - getHeight(root-left) == 2) root = val root-right-val ? rotateLeft(root) : rotateRightLeft(root); return root;vectorint res;bool bfs(node* u) queuenode* q; q.push(u); int t = 1; bool flag1 = true, flag2 = true; while (!q.empty()) u = q.front(); q.pop(); if (u == NULL) flag1 = false; else if (!flag1) flag2 = false; res.push_back(u-val); q.push(u-left); q.push(u-right); return flag2;int main() int n, val; cin n; node * root = NULL; for (int i = 0; i n; i++) cin val; root = insert(root, val); int flag = bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; if (flag) cout YES; else cout NO; return 0; 1124 Raffle for Weibo Followers#include iostream#include string#include map#include vectorusing namespace std;string nums[1001];mapstring, bool st;int main() int m, n, s; cin m n s; for (int i = 1; i = m; i++) cin nums[i]; bool flag = false; for (int i = s; i = m;) if (!st[nums[i]]) flag = true; st[nums[i]] = true; cout nums[i] endl; i += n; else i++; if (!flag) cout Keep going...; return 0; 1125 Chain the Ropes#include iostream#include algorithmusing namespace std;int nums[10001];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; sort(nums, nums + n); double res = nums[0]; for (int i = 1; i n; i++) res = (res + nums[i]) / 2; cout (int)res; return 0; 1126 Eulerian Path#include iostreamusing namespace std;const int N = 501;int degree[N], g[N][N], n;bool visit[N];void dfs(int u) visit[u] = true; for (int i = 1; i = n; i++) if (!visit[i] g[u][i]) dfs(i); int main() int m, a, b; cin n m; for (int i = 0; i m; i++) cin a b; degree[a]++; degree[b]++; g[a][b] = g[b][a] = 1; int odd = 0; for (int i = 1; i = n; i++) if (degree[i] % 2) odd++; cout degree[i]; if (i n) cout ; else cout endl; dfs(a); for (int i = 1; i = n; i++) if (!visit[i]) cout Non-Eulerian; return 0; if (odd == 0) cout Eulerian; else if (odd == 2) cout Semi-Eulerian; else cout Non-Eulerian; return 0; 1127 ZigZagging on a Tree#include iostream#include vector#include queueusing namespace std;const int N = 31;struct node int l, r; trees[N];int in[N], post[N], n;int build(int leftIn, int rightIn, int leftPost, int rightPost) if (leftIn rightIn) return -1; int root = post[rightPost], id = leftIn; for (int i = leftIn; i = rightIn; i++) if (in[i] == root) id = i; int leftCnt = id - leftIn; trees[root].l = build(leftIn, id - 1,leftPost, leftPost + leftCnt - 1); trees[root].r = build(id + 1, rightIn, leftPost + leftCnt, rightPost - 1); return root;vectorint res;void bfs(int u) queueint q; q.push(u); int depth = 1; while (!q.empty()) int size = q.size(); vectorint tmp; for (int i = 0; i size; i++) u = q.front(); q.pop(); tmp.push_back(u); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); if (depth % 2) for (int i = tmp.size() - 1; i = 0; i--) res.push_back(tmp[i]); else for (int i = 0; i tmp.size(); i++) res.push_back(tmp[i]); depth += 1; int main() cin n; for (int i = 0; i n; i++) cin in[i]; for (int i = 0; i n; i++) cin post[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1128 N Queens Puzzle#include iostream#include cstringusing namespace std;const int N = 1001;bool de[2*N], inde[2*N], row[N];int main() int n, k, x; cin n; for (int i = 0; i n; i++) cin k; bool flag = true; memset(de, false, sizeof(de)); memset(inde, false, sizeof(inde)); memset(row, false, sizeof(row)); for (int j = 1; j = k; j++) cin x; if (de[x+j] || inde[-x+j+k] || row[x])flag = false; else de[x+j] = inde[-x+j+k] = row[x] = true; if (flag) cout YES endl; else cout NO endl; 1129 Recommendation System暴力（超时） #include iostream#include map#include algorithmusing namespace std;mapint, int nums;bool cmp(pairint, int a, pairint, int b) if (a.second != b.second) return a.second b.second; return a.first b.first;int main() int n, k, x; cin n k x; nums[x]++; for (int i = 1; i n; i++) cin x; vectorpairint, int t(nums.begin(), nums.end()); sort(t.begin(), t.end(), cmp); cout x :; for (int i = 0; i min(k, (int)t.size()); i++) cout t[i].first; cout endl; nums[x]++; return 0; 柳婼的 #include iostream#include setusing namespace std;int nums[50001];struct node int num, val; bool operator (const node a) const if (val != a.val) return val a.val; return num a.num; ;int main() int n, k, x; cin n k x; nums[x]++; setnode st; st.insert(x, nums[x]); for (int i = 1; i n; i++) cin x; cout x :; int j = 0; for (auto it = st.begin(); j k it != st.end(); it++) cout it-num; j++; cout endl; auto t = st.find(x, nums[x]); if (t != st.end()) st.erase(t); nums[x]++; st.insert(x, nums[x]); return 0; 1130 Infix Expression#include iostream#include stringusing namespace std;struct node string x; int l, r; trees[21];bool st[21];string dfs(int u) if (trees[u].l == -1 trees[u].r == -1) return trees[u].x; if (trees[u].l == -1 trees[u].r != -1) return ( + trees[u].x + dfs(trees[u].r) + ); if (trees[u].l != -1 trees[u].r != -1) return ( + dfs(trees[u].l) + trees[u].x + dfs(trees[u].r) + );int main() int n, l, r, root; string x; cin n; for (int i = 1; i = n; i++) cin x l r; trees[i] = x, l, r; st[l] = st[r] = true; for (int i = 1; i = n; i++) if (!st[i]) root = i; string res = dfs(root); if (res[0] == () res = res.substr(1, res.size() - 2); cout res; return 0; 1131 Subway Map#include iostream#include vector#include unordered_mapusing namespace std;const int N = 10001;unordered_mapint, int line;vectorint g[N], tmp, res;int dest, mind, mint, pre, pret;bool visit[N];int cnt() int cnt = -1, pre = 0; for (int i = 1; i tmp.size(); i++) if (line[tmp[i - 1] * 10000 + tmp[i]] != pre) cnt++; pre = line[tmp[i - 1] * 10000 + tmp[i]]; return cnt;void dfs(int u, int d) if (u == dest (mind d || mind == d mint cnt())) mind = d; mint = cnt(); res = tmp; if (u == dest) return; for (int i = 0; i g[u].size(); i++) if (!visit[g[u][i]]) visit[g[u][i]] = true; tmp.push_back(g[u][i]); dfs(g[u][i], d + 1); tmp.pop_back(); visit[g[u][i]] = false; int main() int n, k, x, y; cin n; for (int i = 1; i = n; i++) cin k x; for (int j = 1; j k; j++) cin y; g[x].push_back(y); g[y].push_back(x); line[x * 10000 + y] = line[y * 10000 + x] = i; x = y; cin n; for (int i = 0; i n; i++) cin x dest; mind = 0x3f3f3f3f, mint = 0x3f3f3f3f, pre = 0, pret = x; tmp.clear(); tmp.push_back(x); visit[x] = true; dfs(x, 0); visit[x] = false; cout mind endl; for (int j = 1; j res.size(); j++) if (line[res[j - 1] * 10000 + res[j]] != pre) if (pre != 0) printf(Take Line#%d from %04d to %04d. , pre, pret, res[j - 1]); pre = line[res[j - 1] * 10000 + res[j]]; pret = res[j - 1]; printf(Take Line#%d from %04d to %04d. , pre, pret, dest); return 0; 1132 Cut Integer#include iostream#include stringusing namespace std;int main() int n; cin n; for (int i = 0; i n; i++) string z; cin z; int c = stoi(z); int a = stoi(z.substr(0, z.size() / 2)); int b = stoi(z.substr(z.size() / 2)); if (a * b == 0 || c % (a * b)) cout No endl; else cout Yes endl; return 0; 1133 Splitting A Linked List#include iostream#include vectorusing namespace std;struct node int add, val, nex; nums[100001];vectorint res1, res2, res3, res;int main() int start, n, k, add, val, nex; cin start n k; for (int i = 0; i n; i++) cin add val nex; nums[add] = add, val, nex; int t = start; while (t != -1) if (nums[t].val 0) res1.push_back(t); else if (nums[t].val = k) res2.push_back(t); else res3.push_back(t); t = nums[t].nex; for (auto it: res1) res.push_back(it); for (auto it: res2) res.push_back(it); for (auto it: res3) res.push_back(it); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); printf(%05d %d -1, nums[res[res.size() - 1]].add, nums[res[res.size() - 1]].val); return 0; 1134 Vertex Cover#include iostream#include vector#include setusing namespace std;const int N = 10001;vectorint g[N];setint res;int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a].push_back(b); g[b].push_back(a); cin k; for (int i = 0; i k; i++) cin n; res.clear(); for (int j = 0; j n; j++) cin a; for (int i = 0; i g[a].size(); i++) if (a g[a][i]) res.insert(a * 10000 + g[a][i]); else res.insert(g[a][i] * 10000 + a); if (res.size() == m) cout Yes endl; else cout No endl; return 0; 柳婼的 #include iostream#include vectorusing namespace std;const int N = 10001;vectorint g[N];bool st[N];int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a].push_back(i); g[b].push_back(i); cin k; for (int i = 0; i k; i++) cin n; fill(st, st + N, false); for (int j = 0; j n; j++) cin a; for (int i = 0; i g[a].size(); i++) st[g[a][i]] = true; bool flag = true; for (int j = 0; j m; j++) if (!st[j]) flag = false; break; if (flag) cout Yes endl; else cout No endl; return 0; 1135 Is It A Red-Black Tree#include iostreamusing namespace std;struct node int val; node *l, *r;;node* build(node* root, int val) if (root == NULL) root = new node(); root-val = val; root-l = root-r = NULL; else if (abs(val) = abs(root-val)) root-l = build(root-l, val); else root-r = build(root-r, val); return root;bool judge1(node* root) if (root == NULL) return true; if (root-val 0) if (root-l != NULL root-l-val 0) return false; if (root-r != NULL root-r-val 0) return false; return judge1(root-l) judge1(root-r);int getnum(node* root) if (root == NULL) return 0; int l = getnum(root-l); int r = getnum(root-r); if (root-val 0) return max(l, r) + 1; else return max(l, r);bool judge2(node* root) if (root == NULL) return true; int l = getnum(root-l); int r = getnum(root-r); if (l != r) return false; return judge2(root-l) judge2(root-r);int main() int k, n, x, start; cin k; for (int i = 0; i k; i++) cin n; node* root = NULL; for (int j = 0; j n; j++) cin x; if (j == 0) start = x; root = build(root, x); if (start 0 || !judge1(root) || !judge2(root)) cout No endl; else cout Yes endl; return 0; 1136 A Delayed Palindrome#include iostream#include string#include algorithmusing namespace std;bool check(string s) for (int i = 0; i s.size() / 2; i++) if (s[i] != s[s.size() - i - 1]) return false; return true;string add(string a, string b) if (a.size() b.size()) swap(a, b); string res = ; int i, t = 0; for (i = 0; i b.size(); i++) t = a[a.size() - i - 1] - 0 + b[b.size() - i - 1] - 0 + t; res += (t % 10) + 0; t /= 10; for (; i a.size(); i++) t = a[a.size() - i - 1] - 0 + t; res += (t % 10) + 0; t /= 10; if (t) res += 1; reverse(res.begin(), res.end()); return res;int main() string a; int cnt = 0; cin a; while(!check(a) cnt 10) string b = a; reverse(a.begin(), a.end()); string c = add(a, b); cout b + a = c endl; a = c; cnt++; if (check(a)) cout a is a palindromic number.; else cout Not found in 10 iterations.; return 0; 1137 Final Grading#include iostream#include string#include algorithm#include vector#include map#include setusing namespace std;struct node string id; int gp, gm, gf, g;;vectornode nums;mapstring, int mgp;mapstring, int mgm;mapstring, int mgf;setstring ids;bool cmp(node a, node b) if (a.g != b.g) return a.g b.g; else return a.id b.id;int main() int p, m, n, g; string id; cin p m n; for (int i = 0; i p; i++) cin id g; mgp[id] = g; ids.insert(id); for (int i = 0; i m; i++) cin id g; mgm[id] = g; ids.insert(id); for (int i = 0; i n; i++) cin id g; mgf[id] = g; ids.insert(id); for (auto id: ids) if (mgp[id] = 200) if(mgm.find(id) == mgm.end()) mgm[id] = -1; if (mgm[id] mgf[id]) g = mgm[id] * 0.4 + mgf[id] * 0.6 + 0.5; else g = mgf[id]; if (g = 60) nums.push_back(id, mgp[id], mgm[id], mgf[id], g); sort(nums.begin(), nums.end(), cmp); for (auto it: nums) cout it.id it.gp it.gm it.gf it.g endl; return 0; 1138 Postorder Traversal#include iostreamusing namespace std;const int N = 50001;int pre[N], in[N];bool flag;void build(int preL, int preR, int inL, int inR) if (preL preR || flag) return; int root = pre[preL], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; build(preL + 1, preL + cntL, inL, id - 1); build(preL + cntL + 1, preR, id + 1, inR); if (!flag) cout root endl; flag = true; int main() int n; cin n; for (int i = 0; i n; i++) cin pre[i]; for (int i = 0; i n; i++) cin in[i]; build(0, n - 1, 0, n - 1); return 0; 1139 First Contact没考虑-0000 #include iostream#include vector#include algorithmusing namespace std;vectorint g[20001];bool visit[20001];int main() int n, m, k, a, b; cin n m; for (int i = 0; i m; i++) cin a b; if (a 0) a += 20000; if (b 0) b += 20000; g[a].push_back(b); g[b].push_back(a); cin k; for (int i = 0; i k; i++) cin a b; fill(visit, visit + 20001, false); if (a 0) a += 20000; if (b 0) b += 20000; visit[a] = visit[b] = true; vectorpairint, int res; if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(g[a][j], g[g[a][j]][p]); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(-g[a][j] + 20000, g[g[a][j]][p]); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(g[a][j], -g[g[a][j]][p] + 20000); break; visit[g[a][j]] = false; else if (a 10000 b 10000) for (int j = 0; j g[a].size(); j++) if (!visit[g[a][j]] g[a][j] 10000) visit[g[a][j]] = true; for (int p = 0; p g[g[a][j]].size(); p++) if (!visit[g[g[a][j]][p]] g[g[a][j]][p] 10000) for (int q = 0; q g[g[g[a][j]][p]].size(); q++) if (g[g[g[a][j]][p]][q] == b) res.push_back(-g[a][j] + 20000, -g[g[a][j]][p] + 20000); break; visit[g[a][j]] = false; cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) printf(%04d %04d , res[i].first, res[i].second); return 0; 柳婼的 #include iostream#include vector#include string#include algorithm#include unordered_mapusing namespace std;unordered_mapint, bool arr;vectorint v[10000];int main() int n, m, k; cin n m; for (int i = 0; i m; i++) string a, b; cin a b; if (a.length() == b.length()) v[abs(stoi(a))].push_back(abs(stoi(b))); v[abs(stoi(b))].push_back(abs(stoi(a))); arr[abs(stoi(a)) * 10000 + abs(stoi(b))] = arr[abs(stoi(b)) * 10000 + abs(stoi(a))] = true; cin k; for (int i = 0; i k; i++) int c, d; cin c d; vectorpairint, int res; for (int j = 0; j v[abs(c)].size(); j++) for (int k = 0; k v[abs(d)].size(); k++) if (v[abs(c)][j] == abs(d) || abs(c) == v[abs(d)][k]) continue; if (arr[v[abs(c)][j] * 10000 + v[abs(d)][k]] == true) res.push_back(v[abs(c)][j], v[abs(d)][k]); cout res.size() endl; sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) printf(%04d %04d , res[i].first, res[i].second); return 0; 1140 Look-and-say Sequence#include iostreamusing namespace std;int main() string s; int n, j; cin s n; for (int cnt = 1; cnt n; cnt++) string t; for (int i = 0; i s.length(); i = j) for (j = i; j s.length() s[j] == s[i]; j++); t += s[i] + to_string(j - i); s = t; cout s; return 0; 1141 PAT Ranking of Institutions#include iostream#include string#include vector#include unordered_map#include algorithmusing namespace std;struct node string name; int tws, ns;;bool cmp(node a, node b) if (a.tws != b.tws) return a.tws b.tws; else if(a.ns != b.ns) return a.ns b.ns; else return a.name b.name;unordered_mapstring, vectordouble schools;vectornode res;int main() int n; double score; string id, school; cin n; for (int i = 0; i n; i++) cin id score school; for (int j = 0; j school.size(); j++) school[j] = tolower(school[j]); if (id[0] == B) score /= 1.5; else if (id[0] == T) score *= 1.5; schools[school].push_back(score); for (auto it: schools) double s = 0; for (double i: it.second) s += i; res.push_back(it.first, (int)s, it.second.size()); sort(res.begin(), res.end(), cmp); cout res.size() endl; int rank = 1; for (int i = 0; i res.size(); i++) if (i != 0 res[i].tws != res[i - 1].tws) rank = i + 1; cout rank res[i].name res[i].tws res[i].ns endl; return 0; 1142 Maximal Clique#include iostream#include vector#include mapusing namespace std;mapint, bool mp;int pre[10001];int main() int m, n, u, v, a; cin m n; for (int i = 0; i n; i++) cin pre[i]; mp[pre[i]] = true; for (int i = 0; i m; i++) cin u v; for (int j = 0; j n; j++) a = pre[j]; if (a = u a = v || a = v a = u) break; if (mp[u] == false mp[v] == false) printf(ERROR: %d and %d are not found. , u, v); else if (mp[u] == false || mp[v] == false) printf(ERROR: %d is not found. , mp[u] == false ? u : v); else if (a == u || a == v) printf(%d is an ancestor of %d. , a, a == u ? v : u); else printf(LCA of %d and %d is %d. , u, v, a); return 0; 1143 Lowest Common Ancestor#include iostream#include vector#include mapusing namespace std;mapint, bool mp;int pre[10001];int main() int m, n, u, v, a; cin m n; for (int i = 0; i n; i++) cin pre[i]; mp[pre[i]] = true; for (int i = 0; i m; i++) cin u v; for (int j = 0; j n; j++) a = pre[j]; if (a = u a = v || a = v a = u) break; if (mp[u] == false mp[v] == false) printf(ERROR: %d and %d are not found. , u, v); else if (mp[u] == false || mp[v] == false) printf(ERROR: %d is not found. , mp[u] == false ? u : v); else if (a == u || a == v) printf(%d is an ancestor of %d. , a, a == u ? v : u); else printf(LCA of %d and %d is %d. , u, v, a); return 0; 1144 The Missing Number#include iostream#include mapusing namespace std;int main() int n, a, num = 1; cin n; mapint, int m; for (int i = 0; i n; i++) cin a; m[a]++; while (true) if (m[num++] == 0) break; cout num - 1; return 0; 1145 Hashing - Average Search Time#include iostream#include cmathusing namespace std;int nums[10001];bool isprime(int x) if (x = 1) return false; for (int i = 2; i * i = x; i++) if (x % i == 0) return false; return true;int main() int ms, n, m, x; cin ms n m; while (!isprime(ms)) ms++; for (int i = 0; i n; i++) cin x; bool flag = false; for (int j = 0; j ms; j++) if (nums[(x + j * j) % ms] == 0) nums[(x + j * j) % ms] = x; flag = true; break; if (!flag) cout x cannot be inserted. endl; int times = m; for (int i = 0; i m; i++) cin x; bool flag = false; for (int j = 0; j ms; j++) if (nums[(x + j * j) % ms] == x || nums[(x + j * j) % ms] == 0) times += j; flag = true; break; if (!flag) times += ms; printf(%.1f, (double)times / m); return 0; 1146 Topological Order#include iostream#include vectorusing namespace std;vectorint v[1010], res;int main() int n, m, a, b, k, in[1010], tin[1010]; cin n m; for (int i = 0; i m; i++) cin a b; v[a].push_back(b); in[b]++; cin k; for (int i = 0; i k; i++) bool flag = true; for (int i = 1; i = n; i++) tin[i] = in[i]; for (int i = 0; i n; i++) cin a; if (tin[a] != 0) flag = false; for (int it :v[a]) tin[it]--; if (flag) continue; res.push_back(i); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; return 0; 1147 Heaps#include iostream#include vectorusing namespace std;int nums[2001], n;struct node int val, l, r;trees[1001];vectorint res;void post(int root) if (root = n) return; post(trees[root].l); post(trees[root].r); res.push_back(trees[root].val);int main() int m; cin m n; for (int i = 0; i m; i++) int flag = 0; fill(nums, nums + 2 * n, -1); for (int j = 0; j n; j++) cin nums[j]; if (nums[0] nums[1] nums[0] nums[2]) flag = 1; if (nums[0] nums[1] nums[0] nums[2]) flag = 2; for (int j = 0; j n; j++) trees[j].val = nums[j]; if (flag == 1 (2*j+1 n nums[j] nums[2*j+1] || 2*j+2 n nums[j] nums[2*j+2])) flag = 0; if (flag == 2 (2*j+1 n nums[j] nums[2*j+1] || 2*j+2 n nums[j] nums[2*j+2])) flag = 0; trees[j].l = 2 * j + 1; trees[j].r = 2 * j + 2; post(0); if (flag == 0) cout Not Heap endl; else if (flag == 1) cout Max Heap endl; else if (flag == 2) cout Min Heap endl; for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; res.clear(); return 0; 柳婼的 #include iostreamusing namespace std;int a[1005], m, n;void post(int root) if (root n) return; post(root * 2); post(root * 2 + 1); printf(%d%s, a[root], root == 1 ? : );int main() cin m n; for (int j = 0; j m; j++) int minn = 1, maxn = 1; for (int i = 1; i = n; i++) cin a[i]; for (int i = 2; i = n; i++) if (a[i] a[i / 2]) maxn = 0; if (a[i] a[i / 2]) minn = 0; if (maxn == 1) cout Max Heap endl; else if (minn == 1) cout Min Heap endl; else cout Not Heap endl; post(1); return 0; 1148 Werewolf - Simple Version#include iostreamusing namespace std;int nums[101];int main() int n; cin n; for (int i = 0; i n; i++) cin nums[i]; for (int i = 1; i n; i++) for (int j = i + 1; j = n; j++) int t = 0, flag = 0; for (int k = 0; k n; k++) if (nums[k] 0 -nums[k] != i -nums[k] != j) t++; if ((k + 1) == i || (k + 1) == j) flag++; if (nums[k] 0 (nums[k] == i || nums[k] == j)) t++; if ((k + 1) == i || (k + 1) == j) flag++; if (t == 2 flag == 1) cout i j endl; return 0; cout No Solution endl; return 0; 1149 Dangerous Goods Packaging#include iostream#include vectorusing namespace std;const int N = 100001;bool st[N];int nums[N];vectorint g[N];int main() int n, m, a, b, k; cin n m; for (int i = 0; i n; i++) cin a b; g[a].push_back(b); g[b].push_back(a); for (int i = 0; i m; i++) cin k; bool flag = true; fill(st, st + N, false); for (int j = 0; j k; j++) cin nums[j]; st[nums[j]] = true; for (int j = 0; j k; j++) for (int r = 0; r g[nums[j]].size(); r++) if (st[g[nums[j]][r]]) flag = false; break; if (!flag) break; if (flag) cout Yes endl; else cout No endl; return 0; 1150 Travelling Salesman Problem#include iostreamusing namespace std;bool visit[205];int g[205][205], nums[205];int main() int n, m, k, t, city1, city2, d, res = 0x3f3f3f3f, id = 0; cin n m; for (int i = 0; i m; i++) cin city1 city2 d; g[city1][city2] = g[city2][city1] = d; cin k; for (int i = 1; i = k; i++) cin t; bool isCycle = true, isSimple = true, isNA = false; int dist = 0; for (int j = 0; j t; j++) cin nums[j]; fill(visit, visit + 205, false); for (int j = 1; j t; j++) if (g[nums[j]][nums[j-1]]) dist += g[nums[j]][nums[j-1]]; if (!visit[nums[j]]) visit[nums[j]] = true; else isSimple = false; else isCycle = false; isNA = true; for (int i = 1; i = n; i++) if (!visit[i]) isCycle = false; if (isCycle dist res) res = dist; id = i; if (isCycle isSimple) cout Path i : dist (TS simple cycle) endl; else if (isCycle !isSimple) cout Path i : dist (TS cycle) endl; else if (!isCycle isNA) cout Path i : NA (Not a TS cycle) endl; else if (!isCycle !isNA) cout Path i : dist (Not a TS cycle) endl; cout Shortest Dist( id ) = res; return 0; 1151 LCA in a Binary Tree#include iostream#include vector#include mapusing namespace std;mapint, int pos;vectorint in, pre;void lca(int inl, int inr, int preRoot, int a, int b) if (inl inr) return; int inRoot = pos[pre[preRoot]], aIn = pos[a], bIn = pos[b]; if (aIn inRoot bIn inRoot) lca(inl, inRoot - 1, preRoot + 1, a, b); else if ((aIn inRoot bIn inRoot) || (aIn inRoot bIn inRoot)) printf(LCA of %d and %d is %d. , a, b, in[inRoot]); else if (aIn inRoot bIn inRoot) lca(inRoot + 1, inr, preRoot + 1 + (inRoot - inl), a, b); else if (aIn == inRoot) printf(%d is an ancestor of %d. , a, b); else if (bIn == inRoot) printf(%d is an ancestor of %d. , b, a);int main() int m, n, a, b; cin m n; in.resize(n + 1); pre.resize(n + 1); for (int i = 1; i = n; i++) cin in[i]; pos[in[i]] = i; for (int i = 1; i = n; i++) cin pre[i]; for (int i = 0; i m; i++) cin a b; if (pos[a] == 0 pos[b] == 0) printf(ERROR: %d and %d are not found. , a, b); else if (pos[a] == 0 || pos[b] == 0) printf(ERROR: %d is not found. , pos[a] == 0 ? a : b); else lca(1, n, 1, a, b); return 0; 1152 Google Recruitment#include iostream#include stringusing namespace std;typedef long long LL;bool check(LL n) if (n 2) return false; for (int i = 2; i * i n; i++) if (n % i == 0) return false; return true;int main() int l, k; string str; cin l k; cin str; for (int i = 0; i = l - k; i++) if (check(stol(str.substr(i, k)))) cout str.substr(i, k); return 0; cout 404 endl; return 0; 1153 Decode Registration Card of PAT)#include iostream#include string#include vector#include map#include algorithmusing namespace std;typedef pairint, int PII;struct node string num; char ch; int site, date, score;nums[10005];bool cmp1(node a, node b) if (a.score != b.score) return a.score b.score; return a.num b.num;bool cmp2(PII a, PII b) if (a.second != b.second) return a.second b.second; return a.first b.first;int main() int n, m, flag, site, date, score, x; char ch; string num; cin n m; for (int i = 0; i n; i++) cin num score; nums[i] = num, num[0], stoi(num.substr(1, 3)), stoi(num.substr(4, 6)), score; for (int i = 1; i = m; i++) cin flag; if (flag == 1) vectornode t; cin ch; cout Case i : 1 ch endl; for (int j = 0; j n; j++) if (ch == nums[j].ch) t.push_back(nums[j]); sort(t.begin(), t.end(), cmp1); for (auto it: t) cout it.num it.score endl; if (t.empty()) cout NA endl; else if (flag == 2) cin site; cout Case i : 2 site endl; int nt = 0, ns = 0; for (int j = 0; j n; j++) if (site == nums[j].site) nt++; ns += nums[j].score; if (nt == 0) cout NA endl; else cout nt ns endl; else if (flag == 3) cin date; printf(Case %d: 3 %06d , i, date); mapint, int t; vectorpairint, int t2; for (int j = 0; j n; j++) if (date == nums[j].date) t[nums[j].site] ++; for (auto it: t) t2.push_back(it.first, it.second); sort(t2.begin(), t2.end(), cmp2); for (auto it: t2) cout it.first it.second endl; if (t2.empty()) cout NA endl; return 0; 1154 Vertex Coloring#include iostream#include vectorusing namespace std;int level[1005];struct node int val, l, r; nums[1005];int n;int build(int root) if (root = n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;vectorint t;void dfs(int root) if (root == -1) for (int i = 0; i t.size(); i++) cout t[i]; if (i t.size() - 1) cout ; else cout endl; return; t.push_back(nums[root].val); if (nums[root].l == -1 nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) dfs(nums[root].r); else if (nums[root].r == -1) dfs(nums[root].l); else dfs(nums[root].r); dfs(nums[root].l); t.pop_back();int main() cin n; for (int i = 0; i n; i++) cin level[i]; build(0); dfs(0); bool ismin = true, ismax = true; for (int i = 2; i = n; i++) if (level[i/2-1] level[i-1]) ismin = false; if (level[i/2-1] level[i-1]) ismax = false; if (ismin) cout Min Heap endl; else printf(%s, ismax ? Max Heap : Not Heap); return 0; 1155 Heap Paths#include iostream#include vectorusing namespace std;int level[1005];struct node int val, l, r; nums[1005];int n;bool ismax, ismin;int build(int root) if (root = n) return -1; nums[root].val = level[root]; nums[root].l = build(root * 2 + 1); nums[root].r = build(root * 2 + 2); return root;vectorint t;void dfs(int root) if (root == -1) for (int i = 0; i t.size(); i++) cout t[i]; if (i t.size() - 1) cout ; else cout endl; return; t.push_back(nums[root].val); if (nums[root].l == -1 nums[root].r == -1) dfs(nums[root].l); else if (nums[root].l == -1) if (nums[root].val nums[nums[root].r].val) ismax = true; else if (nums[root].val nums[nums[root].r].val) ismin = true; dfs(nums[root].r); else if (nums[root].r == -1) if (nums[root].val nums[nums[root].l].val) ismax = true; else if (nums[root].val nums[nums[root].l].val) ismin = true; dfs(nums[root].l); else if (nums[root].val nums[nums[root].r].val nums[root].val nums[nums[root].l].val) ismax = true; else if (nums[root].val nums[nums[root].r].val nums[root].val nums[nums[root].l].val) ismin = true; dfs(nums[root].r); dfs(nums[root].l); t.pop_back();int main() cin n; for (int i = 0; i n; i++) cin level[i]; build(0); dfs(0); if (ismax ismin) cout Not Heap endl; else if (ismax) cout Max Heap endl; else if (ismin) cout Min Heap endl; return 0; 1156 Sexy Primes#include iostreamusing namespace std;bool check(int n) if (n 2) return false; for (int i = 2; i * i = n; i++) if (n % i == 0) return false; return true;int main() int n; cin n; if (check(n) check(n - 6)) cout Yes n - 6; else if (check(n) check(n + 6)) cout Yes n + 6; else for (int i = n + 1; ; i++) if (check(i) check(i - 6) || check(i) check(i + 6)) cout No i; break; return 0; 1157 Anniversary#include iostream#include string#include vector#include mapusing namespace std;mapstring, bool isAlumni;vectorstring alumnu, guest;int main() int n; string num; cin n; for (int i = 0; i n; i++) cin num; isAlumni[num] = true; cin n; for (int i = 0; i n; i++) cin num; if (isAlumni[num]) alumnu.push_back(num); else guest.push_back(num); cout alumnu.size() endl; if (!alumnu.empty()) string mind = alumnu[0].substr(6, 8), res = alumnu[0]; for (int i = 1; i alumnu.size(); i++) if (mind alumnu[i].substr(6, 8)) mind = alumnu[i].substr(6, 8); res = alumnu[i]; cout res; else string mind = guest[0].substr(6, 8), res = guest[0]; for (int i = 1; i guest.size(); i++) if (mind guest[i].substr(6, 8)) mind = guest[i].substr(6, 8); res = guest[i]; cout res; 1158 Telefraud Detection#include iostream#include vector#include map#include algorithmusing namespace std;int g[1005][1005] , father[1005];vectorint suspects;int find(int x) if (father[x] != x) father[x] = find(father[x]); return father[x];void union1(int a, int b) int fa = find(a); int fb = find(b); if (fa != fb) if (fa fb) father[fb] = fa; else father[fa] = fb; int main() int k, n, m, caller, receiver, duration; cin k n m; for (int i = 0; i m; i++) cin caller receiver duration; g[caller][receiver] += duration; for (int i = 1; i = n; i++) int to = 0, back = 0; for (int j = 1; j = n; j++) if (g[i][j] g[i][j] = 5) to++; if (g[i][j] g[i][j] = 5 g[j][i]) back++; if (to k back = to * 0.2) suspects.push_back(i); break; if (suspects.empty()) cout None endl; for (int i = 0; i suspects.size(); i++) father[suspects[i]] = suspects[i]; for (int i = 0; i suspects.size(); i++) for (int j = i + 1; j suspects.size(); j++) if (g[suspects[i]][suspects[j]] g[suspects[j]][suspects[i]]) union1(suspects[i], suspects[j]); mapint, vectorint res; for (int i = 0; i suspects.size(); i++) int t = find(suspects[i]); res[t].push_back(suspects[i]); for (auto it: res) sort(it.second.begin(), it.second.end()); for (int i = 0; i it.second.size(); i++) cout it.second[i]; if (i it.second.size() - 1) cout ; else cout endl; return 0; 1159 Structure of a Binary Tree#include iostream#include vector#include string#include queueusing namespace std;int post[31], in[31];struct node int l, r, parent, level; trees[1005];bool isFull = true;int build(int postL, int postR, int inL, int inR, int parent, int level) if (postL postR) return -1; int root = post[postR], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; trees[root].parent = parent; trees[root].level = level; trees[root].l = build(postL, postL + cntL - 1, inL, id - 1, root, level + 1); trees[root].r = build(postL + cntL, postR - 1, id + 1, inR, root, level + 1); if (trees[root].l * trees[root].r 0) isFull = false; return root;int main() int n, m, a, b; cin n; for (int i = 0; i n; i++) cin post[i]; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1, 0, n - 1, -1, 0); cin m; string ops; for (int i = 0; i m; i++) cin ops; if (ops == It) cin ops ops ops ops; if (isFull) cout Yes endl; else cout No endl; continue; a = stoi(ops); cin ops; if (ops == is) cin ops ops; if (ops == root) if (a == root) cout Yes endl; else cout No endl; else if (ops == parent) cin ops b; if (trees[a].l == b || trees[a].r == b) cout Yes endl; else cout No endl; else if (ops == left) cin ops ops b; if (trees[b].l == a) cout Yes endl; else cout No endl; else if (ops == right) cin ops ops b; if (trees[b].r == a) cout Yes endl; else cout No endl; else if (ops == and) cin b ops ops; if (ops == siblings) if (trees[a].parent == trees[b].parent) cout Yes endl; else cout No endl; else if (ops == on) cin ops ops ops; if (trees[a].level == trees[b].level) cout Yes endl; else cout No endl; return 0; 1160 Forever#include iostream#include vector#include map#include algorithmusing namespace std;typedef long long LL;typedef pairint, LL PII;int k, m;vectorPII res;int gcd(int a, int b) if (b) return gcd(b, a % b); else return a;bool isprime(int x) if (x 2) return false; for (int i = 2; i * i = x; i++) if (x % i == 0) return false; return true;void dfs(int cnt, int sum, LL x) if (cnt k || sum m || m sum + 9*(k-cnt)) return; if (cnt == k sum == m) LL y = x + 1; int n = 0; while (y) n += y % 10; y /= 10; if (gcd(n, m) 2 isprime(gcd(n, m))) res.push_back(n, x); return; for (int i = 0; i = 9; i++) if (sum == 0 i == 0) continue; else dfs(cnt + 1, sum + i, x * 10 + i); int main() int n; cin n; for (int i = 1; i = n; i++) cout Case i endl; cin k m; res.clear(); dfs(0, 0, 0); if (res.empty()) cout No Solution endl; else sort(res.begin(), res.end()); for (int i = 0; i res.size(); i++) cout res[i].first res[i].second endl; return 0; 1161 Merging Linked Lists#include iostream#include vectorusing namespace std;struct node int add, val, nxt; nums[100005];vectornode l1, l2, res;int main() int s1, s2, n, id; cin s2 s1 n; for (int i = 0; i n; i++) cin id; cin nums[id].val nums[id].nxt; nums[id].add = id; while (s1 != -1) l1.push_back(nums[s1]); s1 = nums[s1].nxt; while (s2 != -1) l2.push_back(nums[s2]); s2 = nums[s2].nxt; if (l1.size() l2.size()) swap(l1, l2); id = 0; for (int i = l2.size() - 1; i = 0; i--) res.push_back(l1[id++]); res.push_back(l1[id++]); res.push_back(l2[i]); for (int i = id; i l1.size(); i++) res.push_back(l1[i]); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , res[i].add, res[i].val, res[i + 1].add); printf(%05d %d -1, res.back().add, res.back().val); return 0; 1162 Postfix Expression#include iostream#include stringusing namespace std;struct node string ch; int l, r; trees[21];bool st[21];void postorder(int x) if (x == -1) return; if (trees[x].l == -1) cout ( trees[x].ch; postorder(trees[x].r); cout ); else cout (; postorder(trees[x].l); postorder(trees[x].r); cout trees[x].ch ); int main() int n, root = 1; cin n; for (int i = 1; i = n; i++) cin trees[i].ch trees[i].l trees[i].r; st[trees[i].l] = st[trees[i].r] = true; for (int i = 1; i = n; i++) if (!st[i]) root = i; postorder(root); return 0; 柳婼的 #include iostream#include stringusing namespace std;int n, root = 1, lc[31], rc[31], mark[32];string d[32];void deal(int x) cout (; if (lc[x] * rc[x] 1) deal(lc[x]); deal(rc[x]); cout d[x]; if (lc[x] * rc[x] 0) deal(rc[x]); cout );int main() cin n; for (int i = 1; i = n; i++) cin d[i] lc[i] rc[i]; mark[lc[i]] = mark[rc[i]] = 1; while (mark[root]) root++; deal(root); return 0; 1163 Dijkstra Sequence#include iostreamusing namespace std;const int INF = 0x3f3f3f3f;int n, m, g[1005][1005], nums[1005], d[1005];bool visit[1005];bool dijkstra(int x) fill(visit, visit + 1005, false); fill(d, d + 1005, INF); d[x] = 0; for (int i = 0; i n; i++) int u = -1, mind = INF; for (int j = 1; j = n; j++) if (!visit[j]) if (mind d[j]) mind = d[j]; u = j; else if (mind == d[j]) if (j == nums[i]) u = j; if (u != nums[i]) return false; visit[u] = true; for (int j = 1; j = n; j++) if (g[u][j] !visit[j] d[u] + g[u][j] d[j]) d[j] = d[u] + g[u][j]; return true;int main() int a, b, c, k; cin n m; for (int i = 0; i m; i++) cin a b c; g[a][b] = g[b][a] = c; cin k; for (int j = 0; j k; j++) for (int i = 0; i n; i++) cin nums[i]; if (dijkstra(nums[0])) cout Yes endl; else cout No endl; return 0; 1164 Good in C#include iostream#include stringusing namespace std;string alp[27][8];int main() for (int i = 0; i 26; i++) for (int j = 0; j 7; j++) cin alp[i][j]; string strs[1000], t, str; char ch; int id2 = 0; getchar(); getline(cin, t); for (int i = 0; i t.size(); i++) ch = t[i]; if (ch = A ch = Z) str.push_back(ch); else if (!str.empty()) strs[id2++] = str; str.clear(); if (!str.empty()) strs[id2++] = str; str.clear(); for (int i = 0; i id2; i++) for (int j = 0; j 7; j++) for (int k = 0; k strs[i].size(); k++) cout alp[strs[i][k] - A][j]; if (k strs[i].size() - 1) cout ; else cout endl; if (i id2 - 1) cout endl; return 0; 1165 Block Reversing#include iostream#include vectorusing namespace std;struct node int add, val, nxt; nums[100005];int main() int start, n, k, add, val, nxt; cin start n k; for (int i = 0; i n; i++) cin add; nums[add].add = add; cin nums[add].val nums[add].nxt; vectorint tmps, res; while (start != -1) tmps.push_back(start); start = nums[start].nxt; int t = tmps.size() / k; for (int i = t * k; i tmps.size(); i++) res.push_back(tmps[i]); for (int i = t * k - k; i = 0; i -= k) for (int j = 0; j k; j++) res.push_back(tmps[i + j]); for (int i = 0; i res.size() - 1; i++) printf(%05d %d %05d , nums[res[i]].add, nums[res[i]].val, nums[res[i + 1]].add); printf(%05d %d -1, nums[res.back()].add, nums[res.back()].val); return 0; 1166 Summit#include iostream#include vectorusing namespace std;int g[205][205], nums[205];bool st[205];int main() int n, m, a, b, k; cin n m; for (int i = 0; i m; i++) cin a b; g[a][b] = g[b][a] = 1; cin k; for (int i = 1; i = k; i++) cout Area i; cin m; fill (st, st + 205, false); for (int j = 0; j m; j++) cin nums[j]; st[nums[j]] = true; bool flag1 = false, flag2 = false, flag3 = false; for (int p = 0; p m; p++) for (int q = p + 1; q m; q++) if (g[nums[p]][nums[q]] == 0) flag1 = true; break; if (flag1) cout needs help. endl; break; if (!flag1) for (int p = 1; p = n; p++) if (!st[p]) flag2 = false; for (int q = 0; q m; q++) if (g[p][nums[q]] == 0) flag2 = true; if (!flag2) cout may invite more people, such as p . endl; flag3 = true; break; if (!flag3) cout is OK. endl; return 0; 1167 Cartesian Tree#include iostream#include vector#include queueusing namespace std;struct node int val, l, r; trees[32];int in[32];vectorint level;int build(int l, int r) if (l r) return -1; int mind = 0x3f3f3f3f, root = l; for (int i = l; i = r; i++) if (mind in[i]) mind = in[i]; root = i; trees[root].val = mind; trees[root].l = build(l, root - 1); trees[root].r = build(root + 1, r); return root;void bfs(int u) queueint q; q.push(u); while (!q.empty()) u = q.front(); q.pop(); level.push_back(trees[u].val); if (trees[u].l != -1) q.push(trees[u].l); if (trees[u].r != -1) q.push(trees[u].r); int main() int n; cin n; for (int i = 0; i n; i++) cin in[i]; int root = build(0, n - 1); bfs(root); for (int i = 0; i n; i++) cout level[i]; if (i n - 1) cout ; return 0; 1168 Prime Day#include iostream#include stringusing namespace std;bool isPrime(int n) if (n 2) return false; for (int i = 2; i * i = n; i++) if (n % i == 0) return false; return true;int main() string n; cin n; bool flag = true; for (int i = 0; i 8; i++) if (isPrime(stoi(n))) cout n Yes endl; else cout n No endl; flag = false; n = n.substr(1); if (flag) cout All Prime!; return 0; 1169 The Judger#includeiostream#include vectorusing namespace std;bool st[100005], out[11];int g[12][1005];vectorint nums;bool check(int x) for (int i = 0; i nums.size(); i++) for (int j = i + 1; j nums.size(); j++) if (x == abs(nums[i] - nums[j])) return true; return false;int main() int a, b, n, m; cin a b n m; st[a] = st[b] = true; nums.push_back(a); nums.push_back(b); for (int i = 0; i n; i++) for (int j = 0; j m; j++) cin g[i][j]; for (int i = 0; i m; i++) vectorint tmp; for (int j = 0; j n; j++) if (!out[j]) if (!st[g[j][i]] check(g[j][i])) nums.push_back(g[j][i]); st[g[j][i]] = true; else tmp.push_back(j + 1); out[j] = true; if (!tmp.empty()) for (int j = 0; j tmp.size(); j++) cout Round # i + 1 : tmp[j] is out. endl; vectorint res; for (int i = 0; i n; i++) if (!out[i]) res.push_back(i + 1); if (!res.empty()) cout Winner(s):; for (int i = 0; i res.size(); i++) cout res[i]; else cout No winner.; return 0; 1170 Safari Park#include iostream#include vector#include mapusing namespace std;int g[505][505];int main() int n, r, k, a, b; cin n r k; for (int i = 0; i r; i++) cin a b; g[a][b] = g[b][a] = 1; cin r; for (int i = 0; i r; i++) mapint, vectorint nums; for (int j = 1; j = n; j++) cin a; nums[a].push_back(j); if (nums.size() == k) bool flag = true; for (auto it: nums) for (int p = 0; p it.second.size(); p++) for (int q = p + 1; q it.second.size(); q++) if (g[it.second[p]][it.second[q]]) flag= false; if (flag) cout Yes endl; else cout No endl; else if (nums.size() k) cout Error: Too few species. endl; else if (nums.size() k) cout Error: Too many species. endl; return 0; 1171 Replacement Selection#include iostream#include queueusing namespace std;int nums[100005];int main() int n, m; cin n m; priority_queueint, vectorint, greaterint q1, q2; for (int i = 0; i n; i++) cin nums[i]; if (i m) q1.push(nums[i]); int id = m; while (q1.size()) int now = q1.top(); cout now; q1.pop(); if (id n) if (nums[id] now) q2.push(nums[id]); else q1.push(nums[id]); id++; if (q1.size()) cout ; else swap(q1, q2); cout endl; return 0; 1172 Panda and PP Milk#include iostreamusing namespace std;int nums[10005], tmps[10005];int main() int n, res = 0; cin n; fill(tmps, tmps + n, 200); for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) int t = nums[i], id = 0; for (int j = i - 1; j = 0; j--) if (t nums[j]) id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; else if (t == nums[j]) tmps[j] = max(tmps[j], 200 + id * 100); else break; t = nums[i], id = 0; for (int j = i + 1; j n; j++) if (t nums[j]) id++; tmps[j] = max(tmps[j], 200 + id * 100); t = nums[j]; else if (t == nums[j]) tmps[j] = max(tmps[j], 200 + id * 100); else break; for (int i = 0; i n; i++) res += tmps[i]; cout res; return 0; 1173 How Many Ways to Buy a Piece of Land#include iostreamusing namespace std;int nums[10005];int main() int n, m, res = 0; cin n m; for (int i = 0; i n; i++) cin nums[i]; for (int i = 0; i n; i++) int t = 0; for (int j = i; j n; j++) t += nums[j]; if (t = m) res++; else break; cout res; return 0; 1174 Left-View of Binary Tree#include iostream#include vector#include queueusing namespace std;int in[25], pre[25];vectorint res;struct node int l, r; trees[200005];int build(int preL, int preR, int inL, int inR) if (preL preR) return -1; int root = pre[preL], id = inL; for (int i = inL; i = inR; i++) if (root == in[i]) id = i; break; int cntL = id - inL; trees[root].l = build(preL + 1, preL + cntL, inL, id - 1); trees[root].r = build(preL + cntL + 1, preR, id + 1, inR); return root;void bfs(int root) queueint q; q.push(root); while (!q.empty()) int size = q.size(); for (int i = 0; i size; i++) root = q.front(); q.pop(); if (i == 0) res.push_back(root); if (trees[root].l != -1) q.push(trees[root].l); if (trees[root].r != -1) q.push(trees[root].r); int main() int n; cin n; for (int i = 0; i n; i++) cin in[i]; for (int i = 0; i n; i++) cin pre[i]; int root = build(0, n - 1, 0, n - 1); bfs(root); for (int i = 0; i res.size(); i++) cout res[i]; if (i res.size() - 1) cout ; else cout endl; return 0; 1175 Professional Ability Test - PAT (Advanced Level) Practice (pintia.cn)柳婼的 #include iostream#include vector#include queueusing namespace std;struct node int v, score, voucher; bool operator (const node x) const if(score != x.score) return score x.score; else return voucher x.voucher; ;struct bian int next, S, D;;vectorbian E[1005];vectorpairint,int Dis(1005, 2e9, -1);int N, M, T1, T2, S, D, f, T, in[1005], in2[1005], Last[1005];queueint DAG;int huan() vectorint S; while(DAG.size()) int now = DAG.front(); DAG.pop(); S.push_back(now); for(auto it : E[now]) in2[it.next]--; if(!in2[it.next]) DAG.push(it.next); return S.size() == N;void dijkstra() vectorint vis(1005); priority_queuenode Q; Q.push(1002, 0, 0); Dis[1002].first = Dis[1002].second = 0; while(Q.size()) node now = Q.top(); Q.pop(); if(vis[now.v]) continue; vis[now.v] = 1; Dis[now.v].first = now.score; Dis[now.v].second = now.voucher; for (auto it : E[now.v]) if(vis[it.next]) continue; if((Dis[it.next].first Dis[now.v].first + it.S) || ((Dis[it.next].first == Dis[now.v].first + it.S) (Dis[it.next].second Dis[now.v].second + it.D))) Dis[it.next].first = Dis[now.v].first + it.S; Dis[it.next].second = Dis[now.v].second + it.D; Last[it.next] = now.v; Q.push(it.next, Dis[it.next].first, Dis[it.next].second); return;int main() cin N M; for (int i = 0; i M; i++) cin T1 T2 S D; E[T1].push_back(T2, S, D); in[T2]++, in2[T2]++; for (int i = 0; i N; i++) if (in[i] == 0) E[1002].push_back(i, 0, 0); DAG.push(i); f = huan(); dijkstra(); cin T; if(f) cout Okay. ; else cout Impossible. ; for (int i = 1, q; i = T; i++) cin q; if(!in[q]) cout You may take test q directly. ; else if(!f) cout Error. ; else vectorint path; int now = q; while(q != 1002) path.push_back(q); q = Last[q]; for (int j = path.size() - 1; j = 0; j--) cout path[j]; if(j) cout -; cout ; return 0; 1176 The Closest Fibonacci Number#include iostream#include algorithmusing namespace std;int dp[43];int main() int n, res = 0, m = 0x3f3f3f3f; cin n; dp[0] = dp[1] = 1; if (n == 1) cout n; return 0; for (int i = 2; i 43; i++) dp[i] = dp[i - 1] + dp[i - 2]; if (m abs(dp[i] - n)) m = abs(dp[i] - n); res = dp[i]; cout res; return 0; 1177 Subsequence in Substring#include iostream#include stringusing namespace std;int main() string s, p; cin s p; int m = 0x3f3f3f3f, idx, l = 0, r = 0; for (int i = 0; i s.size(); i++) if (s[i] == p[0]) idx = 1; for (int j = i + 1; j s.size(); j++) if (j - i = m) break; if (s[j] == p[idx]) idx++; if (idx == p.size()) l = i, r = j; m = r - l; for (int i = l; i = r; i++) cout s[i]; return 0; 1178 File Path#include iostream#include string#include mapusing namespace std;mapstring, string superior;mapint, string last;int main() int n, k; string root, str, res; cin n root; last[1] = root; superior[root] = root; getchar(); for (int i = 1; i n; i++) getline(cin, str); int depth = 0; while (str[depth] == ) depth++; superior[str.substr(depth)] = last[depth]; last[depth + 1] = str.substr(depth); cin k; for (int i = 0; i k; i++) cin str; if (!superior.count(str)) cout Error: str is not found. endl; else res = ; while (str != root) res = - + str + res; str = superior[str]; cout root res; return 0; 1179 Chemical Equation#include iostream#include string#include vector#include algorithmusing namespace std;int n, m, k, num, used[101], res[101];string s;vectorint product, tmp;vectorvectorint equa[101];bool cmp(const vectorint a, const vectorint b) for (int i = 0; ; i++) if (a[i] != b[i]) return a[i] b[i];void dfs(int x) if (x == m) for (int i = 0; i m; i++) for (int j = 0; j equa[product[i]][res[i]].size(); j++) if (j != 0) cout + ; printf(%02d, equa[product[i]][res[i]][j]); printf( - %02d , product[i]); exit(0); for (int i = 0; i equa[product[x]].size(); i++) int flag = 1; vectorint A = equa[product[x]][i]; for (auto it: A) if (used[it] != 1) flag = 0; break; if (flag == 0) continue; for (auto it: A) used[it] = 2; res[x] = i; dfs(x + 1); for (auto it: A) used[it] = 1; int main() cin n; for (int i = 0; i n; i++) cin num; used[num] = 1; cin m; for (int i = 0; i m; i++) cin num; if (used[num] == 1) equa[num].push_back(num); product.push_back(num); cin k; for (int i = 0; i k; i++) tmp.clear(); while (cin num s) tmp.push_back(num); if (s == -) cin num; equa[num].push_back(tmp); break; for (int i = 0; i m; i++) sort(equa[product[i]].begin(), equa[product[i]].end(), cmp); dfs(0); return 0;","tags":["算法","PAT","C++"],"categories":["算法"]},{"title":"算法笔记","path":"/2024/07/29/算法笔记(c++)/","content":"刷题地址：晴问算法 (sunnywhy.com) 入门模拟简单模拟3N+1猜想 #include cstdioint main() int n, res = 0; scanf(%d, n); while (n != 1) if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; res ++; printf(%d, res); return 0; 判断三角形 #include cstdioint main() int a, b, c; scanf(%d%d%d, a, b, c); if (a + b c a + c b b + c a) printf(YES); else printf(NO); return 0; 单调递增序列 #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); bool flag = true; for (int i = 1; i n; i++) if (nums[i] nums[i - 1]) flag = false; break; printf(flag ? YES : NO); return 0; 数列奇数和 #include cstdioint main() int n, x, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, x); if (x % 2 == 1) res += x; printf(%d, res); return 0; 三位数 #include cstdioint main() int n, bai = 0, shi = 0, ge = 0; scanf(%d, n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; printf(%d %d %d, bai, shi, ge); return 0; 水仙花数 #include cstdio#include cmathint main() int n, bai, shi, ge; scanf(%d, n); bai = n / 100; shi = n % 100 / 10; ge = n % 10; if (pow(bai, 3) + pow(shi, 3) + pow(ge, 3) == n) printf(YES); else printf(NO); return 0; 水仙花数II #include cstdiobool check(int x) int a = x / 100; int b = x % 100 / 10; int c = x % 10; return a * a * a + b * b * b + c * c * c == x;const int MAXN = 100;int nums[MAXN];int main() int a, b, idx = 0; scanf(%d%d, a, b); for (int i = a; i = b; i++) if (check(i)) nums[idx++] = i; for (int i = 0; i idx; i++) printf(%d, nums[i]); if (i idx - 1) printf( ); if (idx == 0) printf(NO); return 0; 2的幂 #include cstdioint main() int n, res = 1; scanf(%d, n); for (int i = 0; i n; i++) res = (res * 2) % 1007; printf(%d, res); return 0; 查找元素查找元素 #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, x, res = -1; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, x); for (int i = 0; i n; i++) if (x == nums[i]) res = i + 1; break; if (res == -1) printf(NO); else printf(%d, res); return 0; 统计元素个数 #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, x, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, x); for (int i = 0; i n; i++) if (x == nums[i]) res ++; printf(%d, res); return 0; 寻找元素对 #include cstdioconst int MAXN = 1001;int nums[MAXN];int main() int n, k, res = 0; scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); scanf(%d, k); for (int i = 0; i n; i++) for (int j = i + 1; j n; j++) if (nums[i] + nums[j] == k) res ++; printf(%d, res); return 0; 图形输出等腰直角三角形 #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j = i; j++) printf(*); printf( ); return 0; 等腰直角三角形II #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j i + 1; j++) if (j == 0 || j == i || i == n - 1) printf(*); else printf( ); printf( ); return 0; 画X #include cstdioint main() int n; scanf(%d, n); for (int i = 0; i n; i++) for (int j = 0; j n; j++) if (j == i || j == n - i - 1) printf(*); else if (j i j n - i - 1) continue; else printf( ); printf( ); return 0; 日期处理判断闰年 #include cstdioint main() int n; scanf(%d, n); if (n % 400 == 0 || n % 100 != 0 and n % 4 == 0) printf(YES); else printf(NO); return 0; 日期加法 #include cstdioint dayOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return year % 400 == 0 || (year % 4 == 0 year % 100 != 0);void addOneDay(int year, int month, int day) day++; if (day dayOfMonth[isLeapYear(year)][month]) month ++; day = 1; if (month 12) year++; month = 1; int main() int year, month, day, n; scanf(%d-%d-%d, year, month, day); scanf(%d, n); for (int i = 0; i n; i++) addOneDay(year, month, day); printf(%04d-%02d-%02d, year, month, day); return 0; 日期减法 #include cstdioint daOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return (year % 400 == 0 || year % 4 == 0 and year % 100 != 0);void subDay(int year, int month, int day) day--; if (day == 0) month--; if (month == 0) year --; month = 12; day = daOfMonth[isLeapYear(year)][month]; int main() int year, month, day, n; scanf(%d-%d-%d, year, month, day); scanf(%d, n); for (int i = 0; i n; i++) subDay(year, month, day); printf(%04d-%02d-%02d, year, month,day); return 0; 一年中的第几天 #include cstdioint dayOfMonth[2][13] = 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31;bool isLeapYear(int year) return (year % 400 == 0 || year % 4 == 0 year % 100 != 0);int main() int year, month, day; scanf(%d-%d-%d, year, month, day); int res = day; for (int i = 1; i month; i++) res += dayOfMonth[isLeapYear(year)][i]; printf(%d, res); return 0; 日期先后 #include cstdiobool isBefore(int year1, int month1, int day1, int year2, int month2, int day2) if (year1 != year2) return year1 year2; if (month1 != month2) return month1 month2; return day1 day2;int main() int year1, year2, month1, month2, day1, day2; scanf(%d-%d-%d, year1, month1, day1); scanf(%d-%d-%d, year2, month2, day2); printf(isBefore(year1, month1, day1, year2, month2, day2) ? YES : NO); return 0; 进制转换十进制转二进制 #include cstdioconst int MAXN = 11;int nums[MAXN];int main() int n, idx = 0; scanf(%d, n); while (n != 0) nums[idx++] = n % 2; n /= 2; for (int i = idx - 1; i = 0; i--) printf(%d, nums[i]); return 0; 二进制转十进制 #include cstdioint main() int s, res = 0, p = 1; scanf(%d, s); while (s != 0) res += p * (s % 10); p *= 2; s /= 10; printf(%d, res); return 0; 十进制转K进制 #include cstdioconst int MAXN = 101;int nums[MAXN];int main() int n, k, idx = 0; scanf(%d %d, n, k); while (n != 0) nums[idx++] = n % k; n /= k; for (int i = idx - 1; i = 0; i--) if (nums[i] 9) printf(%c, nums[i] - 10 + A); else printf(%d, nums[i]); return 0; K进制转十进制 #include cstdio#include cstringconst int MAXN = 10;char nums[MAXN];int main() int k, res = 0, p = 1; scanf(%s %d, nums, k); for (int i = strlen(nums) - 1; i = 0 ; i--) int t = (nums[i] = 0 nums[i] = 9) ? (nums[i] - 0) : (nums[i] - A + 10); res += p * t; p *= k; printf(%d, res); return 0; 字符串处理回文字符串 #include iostream#include cstringusing namespace std;int main() string str; cin str; bool flag = true; int n = str.length(); for (int i = 0; i n / 2; i++) if (str[i] != str[str.length() - i - 1]) flag = false; printf(flag ? YES : NO); return 0; 单词倒序 #include cstdioconst int MAXN = 500;const int MAXL = 11;char str[MAXN][MAXL], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = num - 1; i = 0; i--) printf(%s, str[i]); if (i 0) printf( ); return 0; 单词倒序II #include cstdio#include cstringconst int MAXN = 1000;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = 0; i num; i++) for (int j = strlen(str[i]) - 1; j = 0; j--) printf(%c, str[i][j]); if (i num - 1) printf( ); return 0; 单词数 #include cstdioconst int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM], num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; printf(%d, num); return 0; 首字母大写 #include cstdio#include cstringconst int MAXN = 500;const int MAXM = 11;char str[MAXN][MAXM];int num = 0;int main() while (scanf(%s, str[num]) != EOF) num++; for (int i = 0; i num; i++) for (int j = 0; j strlen(str[i]); j++) if (j == 0) printf(%c, str[i][j] - 32); else printf(%c, str[i][j]); if (i num - 1) printf( ); return 0; 公共前缀 #include cstdio#include cstring#include algorithmusing namespace std;const int MAXN = 20;const int MAXM = 51;char str[MAXN][MAXM];int main() int n, minl = 51; scanf(%d, n); for (int i = 0; i n; i++) scanf(%s, str[i]); minl = min(minl, (int)strlen(str[i])); for (int j = 0; j minl; j++) char a = str[0][j]; bool flag = true; for (int i = 1; i n; i++) if (a != str[i][j]) flag = false; break; if (flag) printf(%c, a); else break; return 0; 连续相同字符统计 #include cstdio#include cstringconst int MAXL = 101;char str[MAXL];int main() scanf(%s, str); int idx = 0, len = strlen(str); while (idx len) printf(%c , str[idx++]); int cnt = 1; while (idx len str[idx] == str[idx - 1]) cnt ++; idx ++; printf(%d , cnt); return 0; C语言合法变量名 #include cstdio#include cstringconst int MAXL = 21;char str[MAXL];int main() scanf(%s, str); bool result = true; int len = strlen(str); if (!((str[0] = A str[0] = Z) || (str[0] = a str[0] = z) || str[0] == _)) result = false; for (int i = 1; i len; i++) if (!((str[i] = A str[i] = Z) || (str[i] = a str[i] = z) || (str[i] = 0 str[i] = 9) || str[i] == _)) result = false; break; printf(result ? YES : NO); return 0; 算法初步排序简单选择排序 #include cstdio#include algorithmusing namespace std;const int MAXN = 51;int a[MAXN], n;void selectSort() for (int i = 0; i n; i++) int k = i; for (int j = i; j n; j++) if (a[j] a[k]) k = j; swap(a[i], a[k]); int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, a[i]); selectSort(); for (int i = 0; i n; i++) printf(%d, a[i]); printf(i n - 1 ? : ); return 0; 直接插入排序 #include cstdio#include algorithmconst int MAXN = 51;int nums[MAXN], n;void insertSort() for (int i = 1; i n; i++) int t = nums[i]; int j = i; while (j - 1 = 0 nums[j - 1] t) nums[j] = nums[j - 1]; j --; nums[j] = t; int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); insertSort(); for (int i = 0; i n; i++) printf(%d, nums[i]); printf(i n - 1 ? : ); return 0; 整数升序排序 #include cstdio#include algorithmusing namespace std;const int MAXN = 50;int a[MAXN], n;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, a[i]); sort(a, a + n); for (int i = 0; i n; i++) printf(%d, a[i]); printf(i n - 1 ? : ); return 0; 整数降序排序 #include cstdio#include algorithmusing namespace std;const int MAXN = 51;int nums[MAXN], n;bool cmp(int a, int b) return a b;int main() scanf(%d, n); for (int i = 0; i n; i++) scanf(%d, nums[i]); sort(nums, nums + n, cmp); for (int i = 0; i n; i++) printf(%d, nums[i]); printf(i n - 1 ? : ); return 0; 字符串升序排序 #include iostream#include string#include algorithmusing namespace std;const int MAXN = 51;int n;string str[MAXN];int main() cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n); for (int i = 0; i n; i++) cout str[i] endl; return 0; 字符串降序排序 #include iostream#include string#include algorithmusing namespace std;const int MAXN = 51;string str[MAXN];int n;bool cmp(string a, string b) return a b;int main() cin n; for (int i = 0; i n; i++) cin str[i]; sort(str, str + n, cmp); for (int i = 0; i n; i++) cout str[i] endl; return 0; 考生排序 散列递归贪心二分双指针其他高效技巧与算法数学问题简单数学最大公约数与最小公倍数分数的四则运算素数质因子分解大整数运算扩展欧几里得算法组合数数据结构I栈队列链表搜索深度优先搜索广度优先搜索数据结构II树与二叉树二叉树的遍历树的遍历二叉查找树BST平衡二叉树AVL并查集堆哈夫曼树图图的定义图的存储图的遍历最短路径最小生成树拓扑排序关键路径动态规划动态规划的递归与递推最大连续子序列和最长不下降子序列LIS最长公共子序列最长回文子串DAG最长路背包问题总结字符串字符串hash进阶KMP算法专题扩展分块思想树状数组BIT","tags":["算法","C++"],"categories":["算法"]},{"title":"蓝桥杯真题","path":"/2024/05/29/蓝桥杯真题/","content":"蓝桥杯真题单词分析from collections import Counters = list(input())s.sort()d = Counter(s)print(d.most_common(1)[0][0])print(d.most_common(1)[0][1]) 成绩统计n = int(input())nums = [int(input()) for _ in range(n)]a = d = 0for num in nums: if num = 85: a += 1 d += 1 elif num = 60: d += 1print(fround(d*100/n)%)print(fround(a*100/n)%) 门牌制作n = 2020res = 0for i in range(1, n + 1): res += str(i).count(2)print(res) 数字三角形n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0 for _ in range(n + 2)] for _ in range(n)]dp[0][1] = nums[0][0]for i in range(1, n): for j in range(1, i+2): dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + nums[i][j-1]if n 1: print(dp[n-1][(n + 1) // 2])else: print(max(dp[n-1][n // 2], dp[n-1][n // 2 + 1])) 卡片from sys import exitnums = [2021] * 10for i in range(1, 10000): for char in str(i): nums[int(char)] -= 1 if nums[int(char)] 0: print(i-1) exit(0) 跑步锻炼from datetime import datetime,timedeltastart = datetime(2000, 1, 1)end = datetime(2020, 10, 1)res = 0while start = end: if start.day == 1 or start.weekday() == 0: res += 2 else: res += 1 start += timedelta(days=1)print(res) 蛇形填数nums = [[0] * 100 for _ in range(100)]nums[0][0] = 1i, j, t = 0, 0, 1for _ in range(30): j += 1 t += 1 nums[i][j] = t for _ in range(j): i += 1 j -= 1 t += 1 nums[i][j] = t i += 1 t += 1 nums[i][j] = t for _ in range(i): i -= 1 j += 1 t += 1 nums[i][j] = tprint(nums[19][19]) 货物摆放n = 2021041820210418nums = []for i in range(1, int(n ** 0.5) + 1): if n % i == 0: nums.append(i) nums.append(n/i)res = 0for i in nums: for j in nums: if n % (i*j) == 0: res += 1print(res) # 2430 ！杨辉三角形暴力（40%） n = int(input())nums = []for i in range(1, 1600): nums.append([1] * i + [0]) for j in range(1, i): nums[i-1][j] = nums[i-2][j] + nums[i-2][j-1]for i, num in enumerate(nums): if n in num: d = num.index(n) res = i * (i+1) // 2 + d + 1 print(res) break 组合数+二分 import mathdef C(n, m): a, b = 1, 1 for i in range(1, min(m, n-m) + 1): a *= n n -= 1 b *= i return a // b # return math.comb(n, m) # python3.8def search(x): l = x r = max(x, n) while l r: mid = l + r 1 if C(mid, x // 2) n: l = mid + 1 else: r = mid return ln = int(input())for i in range(34, -1, -2): t = search(i) if C(t, i//2) == n: print(t * (t+1) // 2 + i//2 + 1) break 时间显示from datetime import datetime, timedeltastamp = int(input())d = datetime(1970, 1, 1) + timedelta(milliseconds=stamp)print(d.strftime(%H:%M:%S)) 裁纸刀n, m = 20, 22print(4 + m - 1 + (n - 1) * m) 路径import mathdp = [0] * 2022nums = [[float(inf)] * 2022 for _ in range(2022)]for i in range(1, 2022): for j in range(i+1, min(i+22, 2022)): d = math.gcd(i, j) nums[i][j] = d * i//d * j//ddp[1] = 0for i in range(2, 2022): t = float(inf) for j in range(min(i, 22)): t = min(t, dp[i-j] + nums[i-j][i]) dp[i] = tprint(dp[2021]) 排列字母s = list(input())s.sort()print(.join(s)) 答疑n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key = lambda x:(x[0] + x[1] + x[2], x[0] + x[1]))res = last = 0for num in nums: res += last + num[0] + num[1] last += num[0] + num[1] + num[2]print(res) 直线n, m = 20, 21res = set()for x1 in range(n): for y1 in range(m): for x2 in range(n): for y2 in range(m): if x1 == x2: continue k = (y2 - y1) / (x2 - x1) b = (x2 * y1 - x1 * y2) / (x2 - x1) res.add((k, b))print(len(res) + n) 特殊日期import datetimestart = datetime.datetime(1900, 1, 1)end = datetime.datetime(9999, 12, 31)res = 0while start end: t = start.strftime(%Y %m %d) y, m, d = t.split() if sum(map(int, y)) == sum(map(int, m)) + sum(map(int, d)): res += 1 start += datetime.timedelta(days=1)print(res) 纸张尺寸a, b = 1189, 841res = [(a, b )]for i in range(9): if a b: a, b = b, a a //= 2 res.append((b, a))s = int(input()[-1])print(res[s][0])print(res[s][1]) 青蛙过河n, x = map(int, input().split())nums = list(map(int, input().split()))sums = [0] * nfor i in range(n - 1): sums[i + 1] = sums[i] + nums[i]def check(y): for i in range(n - y): if sums[i + y] - sums[i] 2 * x: return False return Truel, r = 1, nwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) 工作时长from datetime import datetimetmp = []with open(records.txt) as f: for line in f: tmp.append(datetime.strptime(line.strip(), %Y-%m-%d %H:%M:%S))tmp.sort()res = 0for i in range(0, len(tmp), 2): res += (tmp[i + 1] - tmp[i]).total_seconds()print(int(res)) 求和res = 0for i in range(1, 20230409): res += iprint(res) 特殊时间def check(s): return s.count(1) == 3 or s.count(2) == 3tmp = [] #0111, 0222, 1011, 1101, 1110, 1112, 1121, 1222, 1211, 1113, 1114, 1115, 1116, 1117, 1118, 1119for i in range(1, 13): for j in range(1, 31): s = fi:02dj:02d if check(s): tmp.append(s)res = 4 * (4*9 + 3*3 + 2*4)print(res) 数位排序n, m = int(input()), int(input())tmp = list(range(1, n + 1))tmp.sort(key=lambda x:sum([int(i) for i in str(x)]))print(tmp[m - 1]) 括号序列！！！ 天干地支tiangan = [jia, yi, bing, ding, wu, ji, geng, xin, ren, gui]dizhi = [zi, chou, yin, mao, chen, si, wu, wei, shen, you, xu, hai]n = int(input()) + 56a, b = n % 10, n % 12print(ftiangan[a]dizhi[b]) 阶乘的和n = int(input())nums = list(map(int, input().split()))nums.sort()res = nums[0]count = 0nex = nums[0] + 1while True: for num in nums: if num == res: count += 1 if count % nex == 0: count /= nex res = nex nex += 1 else: breakprint(res) 分糖果n, x = map(int, input().split())s = list(input())s.sort()if s[x - 1] != s[0]: print(s[x - 1])elif s[x] == s[-1]: print(s[x - 1], end = ) for i in range(x, n, x): print(s[i], end = )else: for i in s[x - 1: ]: print(i, end = ) 平面切分n = int(input())nums = list(set([tuple(map(int, input().split())) for _ in range(n)]))res = 1 + len(nums)lines = []for k1, b1 in nums: point = set() for k2, b2 in lines: if k1 != k2: x = (b2 - b1) / (k1 - k2) y = (b1 *k2 - b2*k1) / (k2 - k1) point.add((x, y)) res += len(point) lines.append([k1, b1])print(res) 回路计数def gcd(a, b): return a if b == 0 else gcd(b, a % b)n, state = 21, 1 21g = [[0] * (n + 1) for _ in range(n + 1)]dp = [[0] * (n + 1) for _ in range(state)]dp[1][0] = 1for i in range(n + 1): for j in range(n + 1): if gcd(i, j) == 1: g[i][j] = 1for i in range(state): for j in range(n): if i j 1: for k in range(n): if g[j + 1][k + 1] == 1 and i k 1: dp[i][j] += dp[i - (1 j)][k]print(sum(dp[-1]))# print(881012367360) 三国游戏n = int(input())X, Y, Z = list(map(int, input().split())), list(map(int, input().split())), list(map(int, input().split()))A = sorted([X[i] - Y[i] - Z[i] for i in range(n)], reverse=True)B = sorted([Y[i] - X[i] - Z[i] for i in range(n)], reverse=True)C = sorted([Z[i] - X[i] - Y[i] for i in range(n)], reverse=True)a = b = c = res = 0for i in range(n): a += A[i] b += B[i] c += C[i] if a 0 or b 0 or c 0: res += 1 else: breakprint(res if res else -1) 左孩子右兄弟import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]for i in range(2, n + 1): t = int(input()) g[t].append(i)def dfs(u): if not g[u]: return 0 res = 0 for i in g[u]: res = max(res, dfs(i)) return len(g[u]) + resprint(dfs(1)) 2023res = 0def check(s): for i in range(8): if s[i] == 2 and i 5: for j in range(i+1, 8): if s[j] == 0 and j 6: for k in range(j+1, 8): if s[k] == 2 and k 7: for t in range(k+1, 8): if s[t] == 3 and t 8: return True return Falsefor s in range(12345678, 98765433): s = str(s) if 2 not in s or 0 not in s or 3 not in s: continue if check(s): res += 1print(98765433 - 12345678 - res)# print(85959030) 翻转n = int(input())for _ in range(n): res = 0 t, s = list(input()), list(input()) m = len(s) if s[0] != t[0] or s[-1] != t[-1]: res = -1 else: for i in range(1, m-1): if s[i] != t[i]: if s[i] != s[i-1] and s[i] != s[i+1]: res += 1 else: res = -1 break print(res) 123！！！暴力 t = int(input())nums = [0]for i in range(1, 3300): for j in range(1, i): nums.append(j)for i in range(1, len(nums)): nums[i] += nums[i - 1]for _ in range(t): a, b = map(int, input().split()) print(nums[b] - nums[a-1]) ！！！二分 maxn = 1414215s, a = [0] * maxn, [0] * maxnfor i in range(1, maxn): a[i] = a[i - 1] + i s[i] = s[i - 1] + a[i]def presum(x): l, r = 0, maxn while l r: mid = (l + r + 1) 1 if a[mid] x: r = mid - 1 else: l = mid return s[l] + a[x - a[l]]T = int(input())for _ in range(T): l, r = map(int, input().split()) print(presum(r) - presum(l - 1)) 平均n = int(input())nums = [[] for _ in range(10)]for _ in range(n): a, b = map(int, input().split()) nums[a].append(b)res = 0n = n // 10for i in range(10): nums[i] = sorted(nums[i]) res += sum(nums[i][:-n])print(res) 填充s = input()judge = [00, 11, 0?, ?0, 1?, ?1, 11]i = res = 0while i len(s) - 1: if s[i: i + 2] in judge: i += 2 res += 1 else: i += 1print(res) 阶乘约数dicts = def divisor(x): for i in range(2, int(x ** 0.5) + 1): while x % i == 0: dicts[i] = dicts.get(i, 0) + 1 x //= i if x 1: dicts[x] = dicts.get(x, 0) + 1for i in range(1, 101): divisor(i)res = 1for i in dicts.values(): res *= i + 1print(res) 子树的大小T = int(input())for _ in range(T): n, m, k = map(int, input().split()) l = r = k res = tmp = 1 while r * m + 1 n: tmp *= m l = l * m - m + 2 r = r * m + 1 res += tmp l = l * m - m + 2 res += max(0, n - l + 1) print(res) 硬币兑换nums = [i for i in range(2024)] + [0] * 2023for i in range(1, 2024): nums[2 * i] += i // 2 for j in range(i + 1, 2024): nums[i + j] += iprint(max(nums)) 玩具蛇dicts = [(1, 0), (-1, 0), (0, 1), (0, -1)]res = 0g = [[False] * 4 for _ in range(4)]def dfs(x, y, c): if c == 16: global res res += 1 return for i, j in dicts: a, b = x + i, y + j if 0 = a 4 and 0 = b 4 and not g[a][b]: g[a][b] = True dfs(a, b, c + 1) g[a][b] = Falsefor i in range(4): for j in range(4): g[i][j] = True dfs(i, j, 1) g[i][j] = Falseprint(res) 寻找整数# 11 * 17 = 187for i in range(187, 10**12, 187): if i % 49 == 46 and i % 48 == 41 and i % 47 == 5 and i % 46 == 15 and i % 45 == 29: print(i) # 5458460249 12590206409for i in range(5458460249, 10 ** 17, 7131746160): if i % 44 == 33 and i % 43 == 11 and i % 42 == 11 and i % 41 == 1 and i % 40 == 9 \\ and i % 39 == 23 and i % 38 == 37 and i % 37 == 22 and i % 36 == 29 and i % 35 == 4: print(i) 合数个数n = 2020state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n + 1, i): state[j] = Falseres = 0for i in range(1, n + 1): if state[i]: res += 1print(n - res) 寻找2020n = 300g = [input() for _ in range(n)]res = 0for i in range(n): for j in range(n - 3): if g[i][j: j + 4] == 2020: res += 1for i in range(n - 3): for j in range(n): if g[i][j] == 2 and g[i + 1][j] == 0 and g[i + 2][j] == 2 and g[i + 3][j] == 0: res += 1for i in range(n - 3): for j in range(n - 3): if g[i][j] == 2 and g[i + 1][j + 1] == 0 and g[i + 2][j + 2] == 2 and g[i + 3][j + 3] == 0: res += 1print(res) 子矩阵！！暴力（5 MOD = 998244353n, m, a, b = map(int, input().split())A = [list(map(int, input().split())) for _ in range(n)]def fun(c, d): x, y = float(-inf), float(inf) for i in range(a): for j in range(b): x = max(x, A[c + i][d + j]) y = min(y, A[c + i][d + j]) return (x * y) % MODres = 0for i in range(n - a + 1): for j in range(m - b + 1): res = (res + fun(i, j)) % MODprint(res) 管道n, m = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]def check(time): tmp = [] for i in range(n): if time nums[i][1]: l = max(1, nums[i][0] - time + nums[i][1]) r = min(m, nums[i][0] + time - nums[i][1]) tmp.append((l, r)) tmp.sort() if not tmp or tmp[0][0] 1: return False a = tmp[0][1] for l, r in tmp[1:]: if a + 1 l: return False else: a = max(a, r) return a == ml, r = 1, 1000000000while l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) 异或数列def init(n): cnt = 1 while n: if n 1: nums[cnt] += 1 n = 1 cnt += 1T = int(input())for _ in range(T): a = list(map(int, input().split())) n = a[0] nums = [0] * 23 s = 0 for i in range(1, n + 1): init(a[i]) s ^= a[i] if not s: print(0) else: for i in range(20, 0, -1): if nums[i] == 1: print(1) break elif nums[i] % 2 == 1: if n % 2 == 1: print(1) else: print(-1) break 纯质数n = 20210605state = [True] * (n + 1)for i in range(2, int(n ** 0.5) + 1): if state[i]: for j in range(2 * i, n, i): state[j] = Falseres = 0for i in range(2, n + 1): if state[i]: for char in str(i): if char not in 2357: res -= 1 break res += 1print(res) 互质数的个数a, b = map(int, input().split())MOD = 998244353def qpow(a, b): res = 1 while b: if b 1: res = res * a % MOD b = 1 a = a * a % MOD return resdef euler(x): res = x for i in range(2, int(x ** 0.5) + 1): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x 1: res *= (1 - 1 / x) return int(res)print(qpow(a, b - 1) * euler(a) % MOD) 最长不下降子序列from bisect import bisect_rightn, k = map(int, input().split())nums = list(map(int, input().split()))interval = [0] * nres = []for i in range(n): idx = bisect_right(res, nums[i]) if idx = len(res): res.append(nums[i]) else: res[idx] = nums[i] interval[i] = 1maxl = tmp = sum(interval[:k])for i in range(1, n - k + 1): tmp = tmp + interval[i + k - 1] - interval[i - 1] maxl = max(tmp, maxl)print(len(res) + maxl) 松散子序列s = list(map(lambda x: ord(x) - 96, list(input())))n = len(s)if n = 2: print(max(s))else: dp = [[0] * 2 for _ in range(n)] for i in range( n): dp[i][1] = max(dp[i - 2]) + s[i] dp[i][0] = max(dp[i - 1]) print(max(dp[-1])) 奇怪的数！！暴力（10%） def check(num): for i in range(len(num) - 4): if sum(int(s) for s in num[i: i + 5]) m: return False return Truen, m = map(int, input().split())if n 10: exit(0)res = 0for i in range(10 ** n): num = str(i).zfill(n) if all(int(s) % 2 == j % 2 for j, s in enumerate(num)): if check(num): res += 1print(res) 公因数匹配！！暴力（33.3%） import sysdef gcd(a, b): return gcd(b, a % b) if b else an = int(input())nums = list(map(int, input().split()))for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) 1: print(i + 1, j + 1) sys.exit(0) 求因数+堆 import heapqfrom collections import defaultdictn = int(input())nums = list(map(int, input().split()))facts = defaultdict(list)for i, num in enumerate(nums): for j in range(2, int(num ** 0.5) + 1): if num % j == 0: heapq.heappush(facts[j], i + 1) heapq.heappush(facts[num // j], i + 1) heapq.heappush(facts[num], i + 1)l = r = float(inf)for v in facts.values(): if len(v) 1: if l v[0]: l = v[0] r = v[1] elif l == v[0]: r = min(r, v[1])print(l, r) 保险箱n = int(input())s = [0] + list(map(int, input()[::-1]))t = [0] + list(map(int, input()[::-1]))dp = [[0] * 3 for _ in range(n + 1)]dp[1][0] = abs(s[1] - t[1])dp[1][1] = -s[1] + 10 + t[1]dp[1][2] = s[1] + 10 - t[1]for i in range(2, n + 1): dp[i][0] = min(dp[i-1][0] + abs(s[i] - t[i]), dp[i-1][1] + abs(s[i] + 1 - t[i]), dp[i-1][2] + abs(s[i] - 1 - t[i])) dp[i][1] = min(dp[i-1][0] + 10 - s[i] + t[i], dp[i-1][1] + 9 - s[i] + t[i], dp[i-1][2] + 11 - s[i] + t[i]) dp[i][2] = min(dp[i-1][0] + 10 + s[i] - t[i], dp[i-1][1] + 11 + s[i] - t[i], dp[i-1][2] + 9 + s[i] - t[i])print(min(dp[n])) 蜂巢d1, p1, q1, d2, p2, q2 = map(int, input().split())def fun(d, p, q): if d == 0: x = -p + q/2 y = q if d == 1: x = -p/2 + q y = p if d == 2: x = p/2 + q/2 y = p - q if d == 3: x = p - q/2 y = -q if d == 4: x = p/2 - q y = -p if d == 5: x = -p/2 - q/2 y = q - p return x, yx1, y1 = fun(d1, p1, q1)x2, y2 = fun(d2, p2, q2)a, b = abs(x1 - x2), abs(y1 - y2)if a b / 2: print(int(b))else: print(int(a + b - b // 2)) 异或和n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]for _ in range(n - 1): u, v = map(int, input().split()) if u v: u, v = v, u adj_list[u].append(v)def dfs(u): res = nums[u] for v in adj_list[u]: res ^= dfs(v) return res for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: nums[li[1]] = li[2] elif li[0] == 2: res = dfs(li[1]) print(res) 棋盘！！暴力 n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): g[i][j] = 1 if g[i][j] == 0 else 0for i in range(1, n + 1): print(.join(map(str, g[i][1:]))) 差分+前缀和 n, m = map(int, input().split())g = [[0] * (n + 1) for _ in range(n + 1)]diff = [[0] * (n + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += 1 diff[x2 + 1][y1] -= 1 diff[x1][y2 + 1] -= 1 diff[x2 + 1][y2 + 1] += 1for _ in range(m): x1, y1, x2, y2 = map(int, input().split()) insert(x1, y1, x2, y2, 1)for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1] + diff[i][j]for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = 1 if g[i][j] % 2 else 0for i in range(1, n + 1): print(.join(map(str, g[i][1:]))) 美丽的 2n = 2020res = 0for i in range(1, n + 1): if 2 in str(i): res += 1print(res) 数的拆分！！暴力（10%） T = int(input())nums = []for i in range(2, 10000): for j in range(2, 1000): if i ** j 1e9: break nums.append(i ** j)nums.sort()def check(a): if a in nums: return yes else: for num in nums: if a num: return no if a % num == 0 and a // num in nums: return yes return nofor _ in range(T): a = int(input()) print(check(a)) 数学 status = [True] * 4001primes = []def is_square(x): n = round(x ** 0.5) return n * n == xdef is_cubic(x): n = round(x ** (1/3)) return n * n * n == xfor i in range(2, 4001): if status[i]: primes.append(i) for j in range(2 * i, 4001, i): status[j] = Falsedef check(a): flag = True for prime in primes: if a % prime == 0: t = 0 while a % prime == 0: a //= prime t += 1 if t == 1: flag = False if flag and (is_square(a) or is_cubic(a)): print(yes) else: print(no)T = int(input())for _ in range(T): a = int(input()) if is_square(a) or is_cubic(a): print(yes) else: check(a) 大写s = input()print(s.upper()) 重新排序n = int(input())nums = list(map(int, input().split()))diff = [0] * (n + 2)m = int(input())for _ in range(m): l, r = map(int, input().split()) diff[l] += 1 diff[r + 1] -= 1tmps = [0] * (n + 1)for i in range(1, n + 1): tmps[i] = tmps[i - 1] + diff[i]res1 = res2 = 0for i in range(n): res1 += nums[i] * tmps[i + 1]nums.sort(reverse = True)tmps.sort(reverse = True)for i in range(n): res2 += nums[i] * tmps[i]print(res2 - res1) 消除游戏！！暴力（58.3%） s = list(input())for _ in range(10000): n = len(s) state = [True] * n for i in range(1, n - 1): if s[i] == s[i - 1] and s[i] != s[i + 1]: state[i] = state[i + 1] = 0 elif s[i] != s[i - 1] and s[i] == s[i + 1]: state[i] = state[i - 1] = 0 s = [s[i] for i in range(n) if state[i]] if len(s) == n: breakif s: print(.join(map(str, s)))else: print(EMPTY) 技能升级！！暴力（40%） n, m = map(int, input().split())nums = []for _ in range(n): a, b = map(int, input().split()) while a 0: nums.append(a) a -= bnums.sort(reverse=True)print(sum(nums[:m])) 二分 n, m = map(int, input().split())a, b = [], []for i in range(n): x, y = map(int, input().split()) a.append(x) b.append(y)def check(x): cnt = 0 for i in range(n): if a[i] x: continue cnt += (a[i] - x) // b[i] + 1 if cnt = m: return True return Falsel, r = 0, 1000000while l = r: mid = l + r 1 if check(mid): l = mid + 1 else: r = mid - 1res = 0surplus = mfor i in range(n): if a[i] r: continue t = (a[i] - l) // b[i] + 1 if a[i] - (t - 1) * b[i] == r: t -= 1 res += t * a[i] - t * (t - 1) * b[i] // 2 surplus -= tprint(res + surplus * r) 质因数个数！！暴力（80%） n = int(input())primes = []state = [True] * 5000001for i in range(2, 5000001): if state[i]: primes.append(i) for j in range(2 * i, 5000001, i): state[j] = Falseres = 0for prime in primes: if n % prime == 0: res += 1print(res) ！！数学优化（90%） n = int(input())res = 0i = 2while i * i n: if n % i == 0: res += 1 while n % i == 0: n //= i i += 1 if n 1: res += 1print(res) 全排列的价值n = int(input())nums = [0] + [0] * nMOD = 998244353 fac, sum1 = [1] * (n + 1), [1] * (n + 1)for i in range(2, n + 1): fac[i] = fac[i - 1] * i % MOD sum1[i] = sum1[i - 1] + i % MODfor i in range(2, n + 1): nums[i] = (i * nums[i - 1] + fac[i - 1] * sum1[i - 1]) % MODprint(nums[n]) 混乱的数组n = int(input())if n == 10: print(5) print(5 4 3 2 1)elif n == 9: print(5) print(4 3 2 1 1)elif n == 8: print(5) print(3 2 2 1 1)elif n == 7: print(5) print(3 2 1 1 1)elif n == 6: print(4) print(4 3 2 1)elif n == 5: print(4) print(3 2 1 1)elif n == 4: print(4) print(2 2 1 1)elif n == 3: print(3) print(3 2 1)elif n == 2: print(3) print(2 1 1)elif n == 1: print(2) print(2 1)else: for i in range(100): if i * (i - 1) // 2 == n: print(i) print(*range(i, 0, -1)) 完全日期from datetime import datetime, timedeltastart = datetime(2001, 1, 1)end = datetime(2021, 12, 31)res = 0while start = end: t = start.strftime(%Y%m%d) a = sum([int(i) for i in t]) if a in [4, 9, 16, 25, 36]: res += 1 start += timedelta(days=1)print(res) 带宽print(200 // 8) 小蓝的旅行计划import heapq, sysn, m = map(int, input().split())left = [0]oils = [0] * (n + 1)oils[0] = mcost = []consume = 0for i in range(1, n + 1): a, b, c = map(int, input().split()) left.append(c) if a m: print(-1) sys.exit(0) if oils[i - 1] a: while cost and oils[i - 1] a: price, idx = cost[0] maxadd = min(left[idx], m - oils[i - 1]) if maxadd = a - oils[i - 1]: maxadd = a - oils[i - 1] consume += price * maxadd oils[i - 1] += maxadd left[idx] -= maxadd if left[idx] == 0: heapq.heappop(cost) if oils[i - 1] a: print(-1) sys.exit(0) heapq.heappush(cost, (b, i)) oils[i] = oils[i - 1] - aprint(consume) 斐波那契与7# 14, 16, 17, 23, 34, 37, 43, 56 从14开始，60个循环，# (202202011200 - 14) % 60 = 46print((202202011200 - 14) // 60 * 8 + 8) GCD！！暴力（20%） def gcd(a, b): return gcd(b, a % b) if b else aa, b = map(int, input().split())res = 1maxgcd = 0for i in range(1, 1000000): t = gcd(a + i, b + i) if t maxgcd: res = i maxgcd = tprint(res) ！！数学 a, b = map(int, input().split())if a b: a, b = b, ac = b - aif c a: c = (a // c + 1) * ck = c - aprint(k) 最小权值dp = [float(inf)] * 2022dp[0] = 0for i in range(1, 2022): for j in range(i): l, r = j, i - j - 1 dp[i] = min(dp[i], 1 + 2 * dp[l] + 3 * dp[r] + l * l * r)print(dp[2021]) 二进制问题！！暴力（40%） n, k = map(int, input().split())def check(x): cnt = 0 while x: if x 1: cnt += 1 x = 1 return cnt == kres = 0for i in range(1, n + 1): if check(i): res += 1print(res) 最优清零方案！！暴力（60%） n, k = map(int, input().split())nums = list(map(int, input().split()))res = 0for _ in range(1000): for i in range(n - k + 1): a = min(nums[i: i + k]) if a: for j in range(i, i + k): nums[j] -= a res += a else: res += nums[i] nums[i] = 0 if all(nums): break for i in range(n - k + 1, n): res += nums[i] nums[i] = 0print(res) ！！优化 n, k = map(int, input().split())nums = list(map(int, input().split()))idx =res = 0while idx + k - 1 n: mint = min(nums[idx: idx + k]) imint = nums[idx: idx + k].index(mint) if mint 0: for j in range(idx, idx + k): nums[j] -= mint res += mint idx += imint + 1res += sum(nums)print(res) 本质上升序列！！暴力 s = tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwln = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) ！！动态规划 s = tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwln = 200tmp = [set(char) for char in s]for i in range(n): for j in range(i): if s[j] s[i]: for t in tmp[j]: tmp[i].add(t + s[i])res = set()for t in tmp: for i in t: res.add(i)print(len(res))# print(3616159) 矩形拼接T = int(input())def check4(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j == k: return True if i == j and a1 + b1 + a2 + b2 - i - j == k: return True if i == k and a1 + b1 + a3 + b3 - i - k == j: return True if j == k and a2 + b2 + a3 + b3 - j - k == i: return True return Falsedef check6(a1, b1, a2, b2, a3, b3): for i in [a1, b1]: for j in [a2, b2]: for k in [a3, b3]: if i == j or j == k or i == k: return True if i + j == k or i + k == j or j + k == i: return Truefor _ in range(T): a1, b1, a2, b2, a3, b3 = map(int, input().split()) if check4(a1, b1, a2, b2, a3, b3): print(4) elif check6(a1, b1, a2, b2, a3, b3): print(6) else: print(8) 重复字符串k = int(input())s = input()nums = []res = 0if len(s) % k: print(-1)else: n = len(s) // k for i in range(0, len(s), n): nums.append(s[i: i + n]) a = [[0] * 27 for _ in range(n)] for i in range(n): for j in range(k): a[i][ord(nums[j][i]) - 97] += 1 for i in a: res += sum(i) - max(i) print(res) 小蓝做实验n = 100000000state = [True] * (n + 1)def check(x): for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return Truefor i in range(2, n + 1): if state[i]: for i in range(i * 2, n + 1, i): state[i] = Falseres = 0with open(primes_2.txt) as f: for i in f.readlines(): i = int(i.strip( )) if i 1e8: if check(i): res += 1 else: if state[i]: res += 1print(res)print(342693) 近似gcddef gcd(a, b): return gcd(b, a % b) if b else an, g = map(int, input().split())nums = list(map(int, input().split()))l = r = res = 0t = -1for r in range(n): a = gcd(g, nums[r]) if a != g: l = t + 1 t = r if r - l + 1 = 2: res += r - lprint(res) 环境治理n, q = map(int, input().split())D = [list(map(int, input().split())) for _ in range(n)]L = [list(map(int, input().split())) for _ in range(n)]def check(mid): g = [[D[i][j] for j in range(n)] for i in range(n)] circle, remain = mid // n, mid % n for i in range(n): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - circle) for i in range(remain): for j in range(n): g[i][j] = g[j][i] = max(L[i][j], g[i][j] - 1) for k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[k][j]) p = sum([sum(i) for i in g]) return p = ql, r = 0, 10000000while l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l if l 10000000 else -1) 取模！！暴力（35%） T = int(input())def check(n, m): for x in range(1, m): for y in range(x + 1, m + 1): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) ！！暴力换个顺序就全通过了 T = int(input())def check(n, m): for y in range(2, m + 1): for x in range(1, y): if n % x == n % y: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) ！！反证法 import sysT = int(input())def check(n, m): for i in range(1, m + 1): if n % i != i - 1: return True return Falsefor _ in range(T): n, m = map(int, input().split()) if check(n, m): print(Yes) else: print(No) 和与乘积！！暴力（30%） n = int(input())nums = list(map(int, input().split()))muls, sums = [1] * (n + 1), [0] * (n + 1)for i in range(1, n + 1): muls[i] = muls[i - 1] * nums[i - 1] sums[i] = sums[i - 1] + nums[i - 1]res = 0for r in range(1, n + 1): for l in range(1, i + 1): if sums[r] - sums[l - 1] == muls[r] // muls[l - 1]: res += 1print(res) ！！优化–处理连续的1 n = int(input())nums = list(map(int, input().split()))res = cnt = 0preone = [0] * (n) # 前面有多少个1for i in range(n): preone[i] = cnt if nums[i] == 1: cnt += 1 else: cnt = 0for r in range(n): he, ji = 0, 1 l = r while l = 0: he += nums[l] ji *= nums[l] if he == ji: res += 1 if ji - he l: break if preone[l] == 0: l -= 1 continue if ji = he: he += preone[l] else: he += preone[l] if ji = he: res += 1 l -= preone[l] l -= 1print(res) 替换字符！！暴力（40%） s = list(input())n = len(s)m = int(input())for _ in range(m): l, r, x, y = input().split() for i in range(int(l), int(r) + 1): if s[i - 1] == x: s[i - 1] = yprint(.join(map(str, s))) ！！用replace方法 s = input()m = int(input())for _ in range(m): l, r, x, y = input().split() l, r = int(l), int(r) s1 = s[: l - 1] s2 = s[l - 1: r] s2 = s2.replace(x, y) s3 = s[r:] s = s1 + s2 + s3print(s) 打折！！暴力（40%） n, m = map(int, input().split())nums = [[float(inf)] * (n + 1) for _ in range(1001)]for _ in range(m): s, t, p, c = map(int, input().split()) tmps = [] for _ in range(c): a, b = map(int, input().split()) tmps.append((a, b * p // 100, b)) for i in range(1, 1001): for tmp in tmps: if s = i = t: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[1]) else: nums[i][tmp[0]] = min(nums[i][tmp[0]], tmp[2])res = float(inf)for num in nums: res = min(res, sum(num[1:]))print(res) 翻转括号序列n, m = map(int, input().split())s = input()nums = [0] * nfor i in range(n): if s[i] == (: nums[i] = 1 else: nums[i] = -1for _ in range(m): li = list(map(int, input().split())) if li[0] == 1: l, r = int(li[1]), int(li[2]) for i in range(l - 1, r): nums[i] *= -1 if li[0] == 2: l = int(li[1]) - 1 res = t = 0 for i in range(l, n): t += nums[i] if t 0: break elif t == 0: res = i + 1 print(res) 斐波那契数组n = int(input())fib = [1, 1]res = 0nums = list(map(int, input().split()))dic = for i in range(2, 30): fib.append(fib[i - 1] + fib[i - 2])for i in range(n): if i = 30: res += 1 else: dic[nums[i] / fib[i]] = dic.get(nums[i] / fib[i], 0) + 1print(res + min(30, n) - max(dic.values())) 最少的1！！暴力（30%） def fun(x): cnt = 0 while x: if x 1: cnt += 1 x = 1 return cntn = int(input())res = float(inf)for i in range(2, 1000): cnt = fun(n) n *= i res = min(res, cnt)print(res) 冰山！！暴力（80%） n, m, k = map(int, input().split())nums = a = list(map(int, input().split()))for i in a: nums[i] = nums.get(i, 0) + 1MOD = 998244353for _ in range(m): x, y = map(int, input().split()) nums = k + x: v for k, v in nums.items() if k + x 0 for key, value in nums.copy().items(): if key k: del nums[key] nums[k] = (nums.get(k, 0) + value) % MOD nums[1] = (nums.get(1, 0) +(key - k) * value) % MOD if y: nums[y] = nums.get(y, 0) + 1 res = 0 for key, value in nums.items(): res = (res + key * value) % MOD print(res) 六六大顺！！暴力（30%） n = int(input())res = 0for i in range(n): t = i * 4 + 3 + i * 5 + 6 res += int(t)print(res) 补给n, d = map(int, input().split())g = [[0] * n for _ in range(n)]p = [list(map(int, input().split())) for _ in range(n)]for i in range(n): for j in range(i + 1, n): t = ((p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2) ** 0.5 if t d: g[i][j] = g[j][i] = float(inf) else: g[i][j] = g[j][i] = t# floydfor k in range(n): for i in range(n): for j in range(n): g[i][j] = min(g[i][j], g[i][k] + g[j][k])f = [[float(inf)] * n for j in range(1 n)]f[1][0] = 0for j in range(1, 1 n): for i in range(n): if (j i) 1: for k in range(n): if k != i and (j k) 1: f[j][i] = min(f[j][i], f[j - (1 i)][k] + g[k][i])res = min(f[(1 n) - 1][i] + g[i][0] for i in range(n))print(fres:.2f) 分石头t=int(input())def is_prime(i): count=0 j=3 while 1: if(i%j==0): count+=1 i//=j j=2 j+=1 if(i==1):break if(j*j=i): if(j*j==i): count+=1 count+=1 break return count%2for _ in range(t): n=int(input()) a=list(map(int,input().split())) ou=0;ji=0 s=0 for i in a: while i%2==0: i//=2 if(is_prime(i)==0): ou+=1 else:ji+=1 # 如果石子堆数是奇数，或者质数的数量是奇数，则小蓝有必胜策略 if(len(a)%2==1 or ji%2==1): print(1) else: print(0) 注意二分找左边界l=mid+1,找右边界r=mid-1，并且mid=l+r+11","tags":["算法","Python","蓝桥杯"],"categories":["算法"]},{"title":"蓝桥杯辅导课","path":"/2024/03/29/蓝桥杯辅导课/","content":"递归与递推递归实现指数型枚举92. 递归实现指数型枚举 n = int(input())st = []def dfs(u): if u == n + 1: print( .join(map(str, st))) return dfs(u + 1) st.append(u) dfs(u + 1) st.pop()dfs(1) 递归实现排列型枚举94. 递归实现排列型枚举 n = int(input())st = [0] * (n + 1)used = [False] * (n + 1)def dfs(u): if u == n + 1: print( .join(map(str, st[1:]))) return for i in range(1, n + 1): if not used[i]: st[u] = i used[i] = True dfs(u + 1) used[i] = Falsedfs(1) 递归实现组合型枚举93. 递归实现组合型枚举 n, m = map(int, input().split())st = [0] * (m + 1)def dfs(u, start): if n + u - start m: return if u == m + 1: print( .join(map(str, st[1:]))) return for i in range(start, n + 1): st[u] = i dfs(u + 1, i + 1)dfs(1, 1) 带分数1209. 带分数 n = int(input())st = [0] * 10res = 0def check(a, c): b = n * c - a * c nums = set(123456789) return set(str(a) + str(b) + str(c)) == numsdef dfs_c(u, a, c): b = n * c - a * c if len(str(a) + str(b) + str(c)) 9: return global res res += check(a, c) for i in range(1, 10): if not st[i]: st[i] = True dfs_c(u + 1, a, c * 10 + i) st[i] = Falsedef dfs_a(u, a): if a = n: return dfs_c(u, a, 0) for i in range(1, 10): if not st[i]: st[i] = True dfs_a(u + 1, a * 10 + i) st[i] = Falsedfs_a(0, 0)print(res) 简单斐波那契717. 简单斐波那契 n = int(input())nums = [0, 1] + [0] * nfor i in range(2, n + 1): nums[i] = nums[i - 1] + nums[i - 2]print( .join(map(str, nums[:n]))) 费解的开关95. 费解的开关 t = int(input())dirs = [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]def turn(a, b): for i in range(5): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x 5 and 0 = y 5: g[x][y] = 1 if g[x][y] == 0 else 0for idx in range(t): g = [list(input()) for _ in range(5)] if idx t - 1: input() res = 10 tmp = [i[:] for i in g] for x in range(32): stp = 0 for i in range(5): if x i 1: turn(0, i) stp += 1 for i in range(4): for j in range(5): if g[i][j] == 0: turn(i + 1, j) stp +=1 if 0 not in g[4]: res = min(res, stp) g = [i[:] for i in tmp] print(-1 if res 6 else res) 翻硬币1208. 翻硬币 a, b = list(input()), list(input())res = 0for i in range(len(a) - 1): if a[i] != b[i]: a[i+1] = o if a[i+1] == * else * res += 1print(res) 飞行员兄弟116. 飞行员兄弟 g = [list(input()) for _ in range(4)]res = []def turn(x, y): backup[x][y] = - if backup[x][y] == + else +def turn_all(x, y): for i in range(4): turn(x, i) turn(i, y) turn(x, y)for x in range(1 16): tmp = [] backup = [i[:] for i in g] for i in range(4): for j in range(4): if x (4 * i + j) 1: turn_all(i, j) tmp.append((i+1, j+1)) if not any(+ in i for i in backup): if len(res) len(tmp): res = [i[:] for i in tmp]print(len(res))for i in res: print(i[0], i[1]) 二分与前缀和数的范围789. 数的范围 n, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l, r = 0, n - 1 while l r: mid = l + r 1 if nums[mid] = k: r = mid else: l = mid + 1 if nums[l] == k: print(l, end= ) r = n - 1 while l r: mid = l + r + 1 1 if nums[mid] = k: l = mid else: r = mid - 1 if nums[l] == k: print(l) else: print(-1, -1) bisect import bisectn, q = map(int, input().split())nums = list(map(int, input().split()))for _ in range(q): k = int(input()) l = bisect.bisect_left(nums, k) r = bisect.bisect_right(nums, k) if l != r: print(l, r - 1) else: print(-1, -1) 数的三次方根790. 数的三次方根 n = float(input())l, r = -10000, 10000while r - l 1e-8: mid = (l + r) / 2 if mid * mid * mid = n: l = mid else: r = midprint(fl:.6f) 机器人跳跃问题730. 机器人跳跃问题 n = int(input())nums = list(map(int, input().split()))h = max(nums)def check(e): for num in nums: e = 2 * e - num if e h: return True elif e 0: return False return Truel, r = 0, hwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) 四平方和1221. 四平方和 暴力 import mathn = int(input())def fun(): for i in range(int((n/4) ** 0.5) + 1): for j in range(i, int(((n - i*i) / 3) ** 0.5) + 1): for k in range(j, int(((n - i*i - j*j) / 2) ** 0.5) + 1): l = int(math.sqrt(n - i*i - j*j - k*k)) if i*i + j*j + k*k + l*l == n: return i, j, k, lprint(*fun()) 哈希表 n = int(input())dic = for c in range(int(n ** 0.5) + 1): for d in range(int((n - c*c) ** 0.5) + 1): t = c*c + d*d if t not in dic: dic[t] = (c, d)for a in range(int(n ** 0.5) + 1): for b in range(int((n - a*a) ** 0.5) + 1): t = n - a*a - b*b if t in dic: print(a, b, dic[t][0], dic[t][1]) exit() 分巧克力1227. 分巧克力 n, k = map(int, input().split())chocolates = [list(map(int, input().split())) for _ in range(n)]def check(x): t = 0 for chocolate in chocolates: t += (chocolate[0] // x) * (chocolate[1] // x) if t = k: return True return Falsel, r = 1, 100000while l r: mid = l + r + 1 1 if check(mid): l = mid else: r = mid - 1print(l) 前缀和795. 前缀和 n, m = map(int, input().split())nums = list(map(int, input().split()))sums = [0] + nums[:]for i in range(1, n+1): sums[i] += sums[i-1]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l-1]) 子矩阵的和796. 子矩阵的和 from sys import stdininput = lambda: stdin.readline().strip()n, m, q = map(int, input().split())nums = [[0] * (m+1)] + [[0] + list(map(int, input().split())) for _ in range(n)]sums = [num[:] for num in nums]for i in range(1, n+1): for j in range(1, m+1): sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1-1][y2] - sums[x2][y1-1] + sums[x1-1][y1-1]) 激光炸弹99. 激光炸弹 - AcWing题 cnt, r = map(int, input().split())values = [[0] * 5002 for _ in range(5002)]r = min(r, 5001)n = m = rfor _ in range(cnt): x, y, w = map(int, input().split()) x += 1 y += 1 n, m = max(n, x), max(m, y) values[x][y] += wfor i in range(1, n+1): for j in range(1, m+1): values[i][j] += values[i-1][j] + values[i][j-1] - values[i-1][j-1]res = 0for i in range(r, n+1): for j in range(r, m+1): t = values[i][j] - values[i-r][j] - values[i][j-r] + values[i-r][j-r] res = max(res, t)print(res) K倍区间1230. K倍区间 n, k = map(int, input().split())sums = [0] + [int(input()) for _ in range(n)]for i in range(1, n+1): sums[i] += sums[i-1]cnt = [0] * (n+1)res = 0for i in range(n+1): res += cnt[sums[i] % k] cnt[sums[i] % k] += 1print(res) 数学与简单DP买不到的数目AcWing 1205. 买不到的数目 暴力 n, m = map(int, input().split())def check(i, n, m): if not i: return True if i = n and check(i-n, n, m): return True if i = m and check(i-m, n, m): return True return Falseres = 0for i in range(1, 1000): if not check(i, n, m): res = iprint(res) 优化 n, m = map(int, input().split())dp = [False] * (1000001)dp[0] = Truefor i in range(1, 1000001): if i = m: dp[i] |= dp[i-m] if i = n: dp[i] |= dp[i-n]res = 0for i in range(1, 1000001): if not dp[i]: res = iprint(res) 公式 n, m = map(int, input().split())print((n-1) * (m-1) - 1) 蚂蚁感冒1211. 蚂蚁感冒 n = int(input())nums = list(map(int, input().split()))left = right = 0for i in range(1, n): if abs(nums[0]) abs(nums[i]) and nums[i] 0: left += 1 elif abs(nums[0]) abs(nums[i]) and nums[i] 0: right += 1if nums[0] 0 and not right or nums[0] 0 and not left: print(1)else: print(1 + left + right) 饮料换购1216. 饮料换购 n = int(input())res = nwhile n 2: res += n // 3 n = n // 3 + n % 3print(res) 背包问题2. 01背包问题 n, v = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]dp = [[0] * (v+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(1, v+1): dp[i][j] = dp[i-1][j] if j = nums[i-1][0]: dp[i][j] = max(dp[i][j], dp[i-1][j-nums[i-1][0]] + nums[i-1][1])print(dp[n][v]) 摘花生1015. 摘花生 t = int(input())for _ in range(t): r, c = map(int, input().split()) g = [list(map(int, input().split())) for _ in range(r)] dp = [[0] * (c+1) for _ in range(r+1)] for i in range(1, r+1): for j in range(1, c+1): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + g[i-1][j-1] print(dp[i][j]) 最长上升子序列895. 最长上升子序列 n = int(input())nums = [0] + list(map(int, input().split()))dp = [1] * (n+1)for i in range(1, n+1): for j in range(1, i): if nums[i] nums[j]: dp[i] = max(dp[i], dp[j] + 1)print(max(dp)) 地宫取宝1212. 地宫取宝 n, m, k = map(int, input().split())MOD = 1000000007g = [[0] * (m+1)] + [[0] + list(map(lambda x: int(x) + 1, input().split())) for _ in range(n)]dp = [[[[0] * 14 for _ in range(k+1)] for _ in range(m+1)] for _ in range(n+1)]dp[1][1][1][g[1][1]] = 1dp[1][1][0][0] = 1for i in range(1, n+1): for j in range(1, m+1): if i == 1 and j == 1: continue for u in range(k+1): for v in range(14): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u][v] + dp[i][j-1][u][v]) % MOD if u 0 and v == g[i][j]: for t in range(v): dp[i][j][u][v] = (dp[i][j][u][v] + dp[i-1][j][u-1][t] + dp[i][j-1][u-1][t])print(sum(dp[i][j][k]) % MOD) 波动数列1214. 波动数列 n, s, a, b = map(int, input().split())dp = [[0] * n for _ in range(n)]dp[0][0] = 1MOD = 100000007for i in range(1, n): for j in range(n): dp[i][j] = (dp[i-1][(j-i*a) % n] + dp[i-1][(j+i*b) % n]) % MODprint(dp[n-1][s%n]) 枚举、模拟与排序连号区间数1210. 连号区间数 n = int(input())nums = list(map(int, input().split()))res = 0for i in range(n): minv, maxv = float(inf), float(-inf) for j in range(i, n): minv = min(minv, nums[j]) maxv = max(maxv, nums[j]) if maxv - minv == j - i: res += 1print(res) 递增三元组1236. 递增三元组 前缀和 n = int(input())a = list(map(lambda x: int(x) + 1, input().split()))b = list(map(lambda x: int(x) + 1, input().split()))c = list(map(lambda x: int(x) + 1, input().split()))cnta, cntc, suma, sumc = [0] * 100002, [0] * 100002, [0] * 100002, [0] * 100002for i in range(n): cnta[a[i]] += 1for i in range(1, 100002): suma[i] = suma[i-1] + cnta[i]for i in range(n): cntc[c[i]] += 1for i in range(1, 100002): sumc[i] = sumc[i-1] + cntc[i]res = 0for i in b: res += suma[i-1] * (n - sumc[i])print(res) 二分 import bisectn = int(input())a = list(map(int, input().split()))b = list(map(int, input().split()))c = list(map(int, input().split()))a.sort()c.sort()res = 0for i in b: l = bisect.bisect_left(a, i) r = bisect.bisect_right(c, i) res += l * (n-r)print(res) 特别数的和1245. 特别数的和 n = int(input())res = 0for i in range(1, n+1): if 0 in str(i) or 1 in str(i) or 2 in str(i) or 9 in str(i): res += iprint(res) 错误票据1204. 错误票据 n = int(input())nums = []for _ in range(n): nums.extend(map(int, input().split()))nums.sort()a = b = 0for i in range(1, len(nums)): if nums[i] == nums[i-1] + 2: a = nums[i] - 1 elif nums[i] == nums[i-1]: b = nums[i]print(a, b) 回文日期466. 回文日期 date1, date2 = input(), input()days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]rev = [92200229]for i in range(1, 13): for j in range(1, days[i] + 1): t = fi:02dj:02d rev.append(t[::-1] + t)res = 0for i in rev: if date1 = i = date2: res += 1print(res) 移动距离1219. 移动距离 w, m, n = map(int, input().split())m, n = m - 1, n - 1x1, x2 = m // w, n // wy1, y2 = m % w, n % wif x1 % 2: y1 = w - 1 - y1if x2 % 2: y2 = w - 1 - y2print(abs(x1 - x2) + abs(y1 - y2)) 日期问题1229. 日期问题 from time import strptimel, r, s = 1960-01-01, 2059-12-31, input().split(/)res = []def check(date): if l = date = r: try: strptime(date, %Y-%m-%d) res.append(date) except: passfor i in [19, 20]: check(i + s[0] + - + s[1] + - + s[2]) check(i + s[2] + - + s[1] + - + s[0]) check(i + s[2] + - + s[0] + - + s[1])res.sort()for i in set(res): print(i) 航班时间1231. 航班时间 t = int(input())for _ in range(t): res = 0 for _ in range(2): a = input().split() for i in range(len(a)): if i == 2: res += int(a[2][2]) * 24 * 3600 else: b = list(map(int, a[i].split(:))) res += (-1) ** (i+1) * (b[0] * 3600 + b[1] * 60 + b[2]) res //= 2 print(fres // 3600:02d:res % 3600 // 60:02d:res % 60:02d) 外卖店优先级1241. 外卖店优先级 n, m, t = map(int, input().split())a, st, last = [0] * (n+1), [0] * (n+1), [0] * (n+1)b = [list(map(int, input().split())) for _ in range(m)]b.sort()for i, j in b: a[j] = max(0, a[j] - max(0, i - last[j] - 1)) if a[j] = 3: st[j] = 0 a[j], last[j] = a[j] + 2, i if a[j] 5: st[j] = 1for i in range(1, n+1): a[i] = max(0, a[i] - t + last[i]) if a[i] = 3: st[i] = 0print(sum(st)) 归并排序787. 归并排序 n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return mid = l + r 1 merge_sort(l, mid) merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmpmerge_sort(0, n - 1)print(*nums) 逆序对的数量788. 逆序对的数量 n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return 0 mid = l + r 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) 树状数组与线段树动态求连续区间和树状数组 1264. 动态求连续区间和 n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [0] * (n+1)def lowbit(x): return x -xdef add(x, v): while x = n: tree[x] += v x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return resfor i in range(1, n+1): add(i, nums[i])for _ in range(m): k, a, b = map(int, input().split()) if k: add(a, b) else: print(query(b) - query(a-1)) 线段树 n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): tree[u][2] = tree[u 1][2] + tree[u 1 | 1][2]def build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r 1 build(u 1, l, mid) build(u 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] = l and tree[u][1] = r: return tree[u][2] mid = tree[u][0] + tree[u][1] 1 res = 0 if l = mid: res += query(u 1, l, r) if r mid: res += query(u 1 | 1, l, r) return resdef modify(u, x, v): if tree[u][0] == tree[u][1]: tree[u][2] += v else: mid = tree[u][0] + tree[u][1] 1 if x = mid: modify(u 1, x, v) else: modify(u 1 | 1, x, v) pushup(u)build(1, 1, n)for _ in range(m): k, a, b = map(int, input().split()) if k: modify(1, a, b) else: print(query(1, a, b)) 数星星1265. 数星星 n = int(input())tree = [0] * 32002res = [0] * ndef lowbit(x): return x -xdef add(x): while x = 32001: tree[x] += 1 x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return resfor _ in range(n): x, y = map(int, input().split()) res[query(x+1)] += 1 add(x+1)for i in res: print(i) 数列区间最大值1270. 数列区间最大值 dp(爆空间) n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))dp = [[0] * (n+1) for _ in range(n+1)]for i in range(1, n + 1): for j in range(i, n + 1): dp[i][j] = max(dp[i][j - 1], nums[j])for _ in range(m): x, y = map(int, input().split()) print(dp[x][y]) 线段树(TLE) n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))tree = [[0, 0, 0] for _ in range(4 * n + 1)]def pushup(u): t = max(tree[u 1][2], tree[u 1 | 1][2]) tree[u][2] = tdef build(u, l, r): tree[u] = [l, r, 0] if l == r: tree[u][2] = nums[l] else: mid = l + r 1 build(u 1, l, mid) build(u 1 | 1, mid + 1, r) pushup(u)def query(u, l, r): if tree[u][0] = l and tree[u][1] = r: return tree[u][2] mid = tree[u][0] + tree[u][1] 1 left = right = 0 if l = mid: left = query(u 1, l, r, ) if r mid: right = query(u 1 | 1, l, r) return max(left, right)build(1, 1, n)for _ in range(m): x, y = map(int, input().split()) print(query(1, x, y)) 小朋友排队1215. 小朋友排队 N = 1000001n = int(input())nums = [0] + list(map(lambda x: int(x) + 1, input().split()))ct = [0] * (n + 1)def lowbit(x): return x -xdef add(x, v): while x = N: tree[x] += v x += lowbit(x)def query(x): res = 0 while x 0: res += tree[x] x -= lowbit(x) return restree = [0] * (N + 1)for i in range(1, n + 1): ct[i] = query(N) - query(nums[i]) add(nums[i], 1)tree = [0] * (N + 1)for i in range(n, 0, -1): ct[i] += query(nums[i] - 1) add(nums[i], 1)res = 0for i in ct[1:]: res += i * (i + 1) 1print(res) 油漆面积1228. 油漆面积 线段树太难，跳过！ 三体攻击1232. 三体攻击 二分 + 三维差分 (难) from sys import stdininput = lambda: stdin.readline().strip()def get(i, j, k): return (i * B + j) * C + kdef check(mid): b = [0]*N for i in range(1, mid + 1): x1, x2, y1, y2, z1, z2, c = op[i] b[get(x1, y1, z1)] -= c b[get(x1, y1, z2 + 1)] += c b[get(x1, y2 + 1, z1)] += c b[get(x1, y2 + 1, z2 + 1)] -= c b[get(x2 + 1, y1, z1)] += c b[get(x2 + 1, y1, z2 + 1)] -= c b[get(x2 + 1, y2 + 1, z1)] -= c b[get(x2 + 1, y2 + 1, z2 + 1)] += c # 对b求一下三维前缀和 arr = s[:] for i in range(1, A + 1): for j in range(1, B + 1): for k in range(1, C + 1): b[get(i, j, k)] += b[get(i - 1, j, k)] + b[get(i,j-1,k)] + b[get(i,j,k-1)] + b[get(i-1,j-1,k-1)] - \\ b[get(i - 1, j - 1, k)] - b[get(i - 1, j, k - 1)] - b[get(i, j - 1, k - 1)] arr[get(i, j, k)] += b[get(i,j,k)] if arr[get(i, j, k)] 0: return True return FalseA, B, C, m = map(int, input().split())N = (A+1)*(B+1)*(C+1)s, b, bp = [0]*N, [0]*N, [0]*Narr = list(map(int, input().split()))t = 0for i in range(1, A+1): for j in range(1, B+1): for k in range(1, C+1): s[get(i,j,k)] = arr[t] # 把地球军队的生命值给赋值 t += 1op = [[]] + [list(map(int, input().split())) for _ in range(m)]l, r = 1, mwhile l r: mid = l + r 1 if check(mid): r = mid else: l = mid + 1print(l) 差分797. 差分 n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diff = [0] * (n + 2)def insert(l, r, c): diff[l] += c diff[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diff[i]print(*nums[1:]) 差分矩阵798. 差分矩阵 n, m, q = map(int, input().split())nums = [[0] * (m + 1)] + [[0] + list(map(int, input().split())) for _ in range(n)]diff = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diff[x1][y1] += c diff[x1][y2 + 1] -= c diff[x2 + 1][y1] -= c diff[x2 + 1][y2 + 1] += cfor _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, nums[i][j]) nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diff[i][j] print(nums[i][j], end= ) print() 螺旋折线1237. 螺旋折线 x, y = map(int, input().split())if abs(x) = y: print(2 * y * (2 * y - 1) + x + y)elif abs(y) = x: print(2 * x * 2 * x + x - y)elif abs(x) = -y + 1: print(2 * -y * (2 * -y + 1) - x - y)else: print((2 * -x - 1) * (2 * -x - 1) - x + y - 1) 双指针、BFS与图论日志统计1238. 日志统计 n, d, k = map(int, input().split())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort()cnt, st = [0] * 100001, [False] * 100001j = 0for i in range(n): idx = nums[i][1] cnt[idx] += 1 while nums[i][0] - nums[j][0] = d: cnt[nums[j][1]] -= 1 j += 1 if cnt[idx] = k: st[idx] = Truefor i in range(100001): if st[i]: print(i) 献给阿尔吉侬的花束1101. 献给阿尔吉侬的花束 from collections import dequet = int(input())dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(start, end, g): q = deque() q.append(start) dist = [[-1] * c for _ in range(r)] dist[start[0]][start[1]] = 0 while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x r and 0 = y c and g[x][y] != # and dist[x][y] == -1: dist[x][y] = dist[a][b] + 1 if x == end[0] and y == end[1]: print(dist[x][y]) return q.append((x, y)) print(oop!)for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] for i in range(r): for j in range(c): if g[i][j] == S: start = (i, j) elif g[i][j] == E: end = (i, j) bfs(start, end, g) 红与黑1113. 红与黑 dfs dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dfs(a, b): cnt = 1 st[a][b] = True for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y m and g[x][y] == . and not st[x][y]: st[x][y] = True cnt += dfs(x, y) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == @: print(dfs(i, j)) break bfs from collections import dequedirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) cnt = 1 st[a][b] = True while q: a, b = q.popleft() for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y m and g[x][y] == . and not st[x][y]: st[x][y] = True cnt += 1 q.append((x, y)) return cntwhile True: m, n = map(int, input().split()) if not m: break g = [input() for _ in range(n)] st = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if g[i][j] == @: print(bfs(i, j)) break 交换瓶子1224. 交换瓶子 贪心 n = int(input())nums = [0] + list(map(int, input().split()))st = [False] * (n + 1)cnt = 0for i in range(1, n + 1): t = nums[i] if not st[t]: st[t] = True cnt += 1 while not st[nums[t]]: st[nums[t]] = True t = nums[t]print(n - cnt) 并查集 n = int(input())nums = [0] + list(map(int, input().split()))fa = [i for i in range(n + 1)]s = [0] * (n + 1)def find(x): if fa[x] == x: return x fa[x] = find(fa[x]) return fa[x]for i in range(1, n + 1): fx, fy = find(nums[i]), find(nums[nums[i]]) fa[fx] = fyfor i in range(1, n + 1): s[find(i)] += 1res = 0for i in range(1, n + 1): if s[i]: res += s[i] - 1print(res) 完全二叉树的权值1240. 完全二叉树的权值 前缀和 n = int(input())nums = [0] + list(map(int, input().split()))for i in range(1, n + 1): nums[i] += nums[i - 1]res, depth = float(-inf), 1i = j = 1while i = n: t = nums[min(n, i * 2 - 1)] - nums[i - 1] if t res: res = t depth = j i *= 2 j += 1print(depth) 地牢大师1096. 地牢大师 from collections import dequedirs = [(1, 0 ,0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]def bfs(start, end): q = deque() q.append(start) dist = [[[-1] * c for _ in range(r)] for _ in range(l)] dist[start[0]][start[1]][start[2]] = 0 while q: a, b, d = q.popleft() for i in range(6): x, y, z = a + dirs[i][0], b + dirs[i][1], d + dirs[i][2] if 0 = x l and 0 = y r and 0 = z c and g[x][y][z] != # and dist[x][y][z] == -1: dist[x][y][z] = dist[a][b][d] + 1 if x == end[0] and y == end[1] and z == end[2]: print(fEscaped in dist[x][y][z] minute(s).) return q.append((x, y, z)) print(Trapped!)while True: l, r, c = map(int, input().split()) if not l: break g = [0] * l for i in range(l): g[i] = [input() for _ in range(r)] input() for i in range(l): for j in range(r): for k in range(c): if g[i][j][k] == S: start = (i, j, k) elif g[i][j][k] == E: end = (i, j, k) bfs(start, end) 全球变暖1233. 全球变暖 from collections import dequen = int(input())g = [input() for _ in range(n)]st = [[False] * n for _ in range(n)]dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]def bfs(a, b): q = deque() q.append((a, b)) total = bound = 0 st[a][b] = True while q: a, b = q.popleft() total += 1 is_bound = False for i in range(4): x, y = a + dirs[i][0], b + dirs[i][1] if 0 = x n and 0 = y n: if g[x][y] == .: is_bound = True elif g[x][y] == # and not st[x][y]: st[x][y] = True q.append((x, y)) if is_bound: bound += 1 if total == bound: global res res += 1res = 0for i in range(n): for j in range(n): if g[i][j] == # and not st[i][j]: bfs(i, j)print(res) 大臣的旅费1207. 大臣的旅费 dfs(爆栈) import syssys.setrecursionlimit(100000)n = int(input())g = [[] for _ in range(n + 1)]dist = [0] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def dfs(u, father, distance): dist[u] = distance for i, j in g[u]: if i != father: dfs(i, u, distance + j)dfs(1, -1, 0)t = dist.index(max(dist))dfs(t, -1, 0)t = max(dist)print(10 * t + t * (t + 1) // 2) bfs from collections import dequen = int(input())g = [[] for _ in range(n + 1)]dist = [-1] * (n + 1)for _ in range(n - 1): a, b, c = map(int, input().split()) g[a].append((b, c)) g[b].append((a, c))def bfs(u): q = deque([u]) dist[u] = 0 while q: u = q.popleft() for i, j in g[u]: if dist[i] == -1: dist[i] = dist[u] + j q.append(i)bfs(1)t = dist.index(max(dist))dist = [-1] * (n + 1)bfs(t)t = max(dist)print(t * 10 + t * (t + 1) // 2) 贪心股票买卖 II1055. 股票买卖 II n = int(input())nums = list(map(int, input().split()))res = 0for i in range(1, n): res += max(0, nums[i] - nums[i - 1])print(res) 货仓选址104. 货仓选址 n = int(input())nums = list(map(int, input().split()))nums.sort()a = nums[n // 2]res = 0for num in nums: res += abs(a - num)print(res) 糖果传递122. 糖果传递 n = int(input())nums = [0] + [int(input()) for _ in range(n)]sums = [0] * (n + 2)avg = sum(nums) // nfor i in range(n, 1, -1): sums[i] = sums[i + 1] - nums[i] + avgsums = sums[1: n + 1]sums.sort()res = 0a = sums[n // 2]for i in sums: res += abs(i - a)print(res) n = int(input())nums = [int(input()) for _ in range(n)]avg = sum(nums) // na = [0] + [i - avg for i in nums]for i in range(1, n + 1): a[i] += a[i - 1]a = sorted(a[1:])t = a[n // 2]res = 0for i in a: res += abs(t - i)print(res) 雷达设备112. 雷达设备 n, d = map(int, input().split())g = []for _ in range(n): x, y = map(int, input().split()) if y d: print(-1) exit(0) else: x1 = x - (d * d - y * y) ** 0.5 x2 = x + (d * d - y * y) ** 0.5 g.append((x1, x2))g.sort(key=lambda x: x[1])res, last = 0, float(-inf)for i in range(n): if g[i][0] last: res += 1 last = g[i][1]print(res) 付账问题1235. 付账问题 n, s = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, avg = 0, s / nfor i, num in enumerate(nums): cur = s / (n - i) if num cur: res += (avg - num) ** 2 s -= num else: res += (cur - avg) ** 2 * (n - i) breakres = (res / n) ** 0.5print(fres:.4f) 乘积最大1239. 乘积最大 n, k = map(int, input().split())nums = [int(input()) for _ in range(n)]MOD = 1000000009nums.sort()res = sign = 1l, r = 0, n - 1if k % 2: res = nums[r] r, k = r - 1, k - 1 if res 0: sign = -1while k: x, y = nums[l] * nums[l + 1], nums[r] * nums[r - 1] if x * sign y * sign: res *= x l += 2 else: res *= y r -= 2 res = res % MOD if res 0 else -(-res % MOD) k -= 2print(res) 后缀表达式1247. 后缀表达式 n, m = map(int, input().split())nums = list(map(int, input().split()))if not m: print(sum(nums))else: nums.sort() res = nums[-1] - nums[0] for num in nums[1: -1]: res += abs(num) print(res) 灵能传输1248. 灵能传输 t = int(input())for _ in range(t): n = int(input()) nums = [0] + list(map(int, input().split())) for i in range(1, n + 1): nums[i] += nums[i - 1] s0, sn = nums[0], nums[-1] if s0 sn: s0, sn = sn, s0 nums.sort() s0, sn = nums.index(s0), nums.index(sn) l, r = 0, n res = [0] * (n + 1) st = [0] * (n + 1) for i in range(s0, -1, -2): res[l] = nums[i] st[i] = True l += 1 for i in range(sn, n + 1, 2): res[r] = nums[i] st[i] = True r -= 1 for i in range(n + 1): if not st[i]: res[l] = nums[i] l += 1 ans = 0 for i in range(1, n + 1): ans = max(ans, abs(res[i] - res[i - 1])) print(ans) 数论等差数列1246. 等差数列 n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else ad = 0for i in range(1, n): d = gcd(nums[i] - nums[0], d)if d: print((nums[-1] - nums[0]) // d + 1)else: print(n) X的因子链1295. X的因子链 N = (1 20) + 10primes, st, minp = [], [False] * N, [0] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) minp[i] = i j = 0 while i * primes[j] = n and j len(primes): st[primes[j] * i] = True minp[primes[j] * i] = primes[j] if i % primes[j] == 0: break j += 1get_prime(N - 1)fact, sums = [0] * 30, [0] * Nwhile True: try: x = int(input()) k = total = 0 while x 1: p = minp[x] fact[k], sums[k] = p, 0 while x % p == 0: x //= p sums[k] += 1 total += 1 k += 1 res = 1 for i in range(1, total + 1): res *= i for i in range(k): for j in range(1, sums[i] + 1): res //= j print(total, res) except: break 聪明的燕姿1296. 聪明的燕姿 N = 50000primes, st = [], [False] * Ndef get_prime(n): for i in range(2, n + 1): if not st[i]: primes.append(i) j = 0 while i * primes[j] = n: st[i * primes[j]] = True if i % primes[j] == 0: break j += 1def is_prime(x): if x N: return not st[x] i = 0 while primes[i] = x / primes[i]: if x % primes[i] == 0: return False i += 1 return Truedef dfs(last, prod, s): if s == 1: res.append(prod) return if s - 1 (0 if last 0 else primes[last]) and is_prime(s - 1): res.append(prod * (s - 1)) i = last + 1 while primes[i] = s / primes[i]: p = primes[i] j, t = 1 + p, p while t = s: if s % j == 0: dfs(i, prod * t, s // j) t *= p j += t i += 1get_prime(N - 1)while True: try: x = int(input()) res = [] dfs(-1, 1, x) print(len(res)) if res: res.sort() print(*res) except: break 五指山1299. 五指山 t = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(t): n, d, x, y = map(int, input().split()) gcd, a, b = exgcd(n, d) if (y - x) % gcd: print(Impossible) else: b *= (y - x) // gcd print(b % (n // gcd)) 最大比例1223. 最大比例 n = int(input())nums = list(map(int, input().split()))nums.sort()def gcd(a, b): return gcd(b, a % b) if b else adef gcd_sub(a, b): if a b: a, b = b, a if b == 1: return a return gcd_sub(b, a // b)a, b = [], []for i in range(1, n): if nums[i] != nums[i - 1]: d = gcd(nums[i], nums[0]) a.append(nums[i] // d) b.append(nums[0] // d)up, down = a[0], b[0]for i in range(1, len(a)): up = gcd_sub(up, a[i]) down = gcd_sub(down, b[i])print(fup/down) C 循环1301. C 循环 def exgcd(a, b): if b == 0: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ywhile True: a, b, c, k = map(int, input().split()) if a == 0 and b == 0 and c == 0 and k == 0: break k = 1 k gcd, x, y = exgcd(c, k) if (b - a) % gcd: print(FOREVER) else: x *= (b - a) // gcd print(x % (k // gcd)) 正则问题1225. 正则问题 s = input().strip()i = 0def dfs(): global i res = 0 while i len(s): if s[i] == (: i += 1 res += dfs() i += 1 elif s[i] == |: i += 1 res = max(res, dfs()) elif s[i] == ): break else: i += 1 res += 1 return resprint(dfs()) 糖果1243. 糖果 IDA* def lowbit(x): return x -xdef h(st): t = (1 m) - 1 - st res = 0 while t: res += 1 i = lowbit(t) t -= i for row in col[log2[i]]: t = ~row return resdef dfs(depth, st): if depth == 0 or h(st) depth: return st == (1 m) - 1 t = -1 i = (1 m) - 1 - st while i: j = lowbit(i) i -= j if t == -1 or len(col[log2[j]]) len(col[t]): t = log2[j] for row in col[t]: if dfs(depth - 1, row | st): return True return Falsen, m, k = map(int, input().split())log2 = [0] * (1 m + 1)for i in range(m): log2[1 i] = icol = [[] for _ in range(m + 1)]for _ in range(n): t = list(map(int, input().split())) tt = 0 for ti in t: tt |= 1 (ti - 1) for i in range(m): if (tt i) 1: col[i].append(tt)depth = 0while depth = m and not dfs(depth, 0): depth += 1print(-1 if depth m else depth) dp n, m, k = map(int, input().split())dp = [-1] * ((1 m) + 1)val = [0] * nfor i in range(n): t = list(map(int, input().split())) for j in t: val[i] |= 1 (j - 1) dp[val[i]] = 1for i in range(n): for j in range(1 m): if dp[j] == -1: continue if dp[j | val[i]] == -1: dp[j | val[i]] = dp[j] + dp[val[i]] else: dp[j | val[i]] = min(dp[j | val[i]], dp[j] + dp[val[i]])print(dp[(1 m) - 1]) 复杂DP鸣人的影分身1050. 鸣人的影分身 t = int(input())for _ in range(t): m, n = map(int, input().split()) dp = [[0] * (n + 1) for _ in range(m + 1)] dp[0][0] = 1 for i in range(m + 1): for j in range(1, n + 1): dp[i][j] = dp[i][j - 1] if i = j: dp[i][j] += dp[i - j][j] print(dp[m][n]) 糖果1047. 糖果 n, k = map(int, input().split())dp = [[float(-inf)] * (k + 1) for _ in range(n + 1)]dp[0][0] = 0for i in range(1, n + 1): x = int(input()) for j in range(k + 1): dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - x) % k] + x)print(dp[n][0]) 密码脱落1222. 密码脱落 s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]for i in range(n): for l in range(n - i): r = l + i if i == 0: dp[l][r] = 1 else: if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] + 2 dp[l][r] = max(dp[l][r], dp[l + 1][r], dp[l][r - 1])print(n - dp[0][n - 1]) 生命之树1220. 生命之树 import syssys.setrecursionlimit(100000)n = int(input())w = [0] + list(map(int, input().split()))adj_list = [[] for _ in range(n + 1)]dp = [float(-inf)] * (n + 1)for _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, fa): dp[u] = w[u] for v in adj_list[u]: if v != fa: dfs(v, u) dp[u] += max(0, dp[v])dfs(1, -1) print(max(dp)) 包子凑数1226. 包子凑数 n = int(input())dp = [[0] * 10000 for _ in range(n + 1)]w = [0] + [int(input()) for _ in range(n)]def gcd(a, b): return gcd(b, a % b) if b else ad = w[1]for i in range(2, n + 1): d = gcd(d, w[i])if d == 1: dp[0][0] = 1 for i in range(1, n + 1): for j in range(10000): dp[i][j] = dp[i - 1][j] if j = w[i]: dp[i][j] |= dp[i][j - w[i]] res = 0 for i in range(10000): if not dp[n][i]: res += 1 print(res)else: print(INF) 括号配对1070. 括号配对 s = input()n = len(s)dp = [[0] * (n + 1) for _ in range(n + 1)]def check(l, r): if s[l - 1] == ( and s[r - 1] == ): return True if s[l - 1] == [ and s[r - 1] == ]: return True return Falsefor i in range(n, 0, -1): for j in range(i + 1, n + 1): if check(i, j): dp[i][j] = dp[i + 1][j - 1] + 2 for k in range(i, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j])print(n - dp[1][n]) 斐波那契前 n 项和1303. 斐波那契前 n 项和 n, m = map(int, input().split())f1 = [1, 1, 1]a = [[0, 1, 0], [1, 1, 1], [0, 0, 1]]def mul1(b, c): tmp = [0] * 3 for i in range(3): for j in range(3): tmp[i] = (tmp[i] + b[j] * c[j][i]) % m return tmpdef mul2(b, c): tmp = [[0] * 3 for _ in range(3)] for i in range(3): for j in range(3): for k in range(3): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % m return tmpn -= 1while n: if n 1: f1 = mul1(f1, a) a = mul2(a, a) n = 1print(f1[2]) 垒骰子1217. 垒骰子 n, m = map(int, input().split())MOD = int(1e9) + 7op = [3, 4, 5, 0, 1, 2]f1 = [4, 4, 4, 4, 4, 4]d = [[4] * 6 for _ in range(6)]st = [[False] * 6 for _ in range(6)]for _ in range(m): a, b = map(lambda x: int(x) - 1, input().split()) st[a][b] = st[b][a] = Truefor i in range(6): for j in range(6): if st[j][op[i]]: d[j][i] = 0def mul1(b, c): tmp = [0] * 6 for i in range(6): for j in range(6): tmp[i] = (tmp[i] + b[j] * c[j][i]) % MOD return tmpdef mul2(b, c): tmp = [[0] * 6 for _ in range(6)] for i in range(6): for j in range(6): for k in range(6): tmp[i][j] = (tmp[i][j] + b[i][k] * c[k][j]) % MOD return tmpn -= 1while n: if n 1: f1 = mul1(f1, d) d = mul2(d, d) n = 1print(sum(f1) % MOD) 疑难杂题修改数组1242. 修改数组 import syssys.setrecursionlimit(100000)n = int(input())nums = list(map(int, input().split()))p = [i for i in range(1100001)]res = []def find(x): if x != p[x]: p[x] = find(p[x]) return p[x]for num in nums: x = find(num) res.append(x) p[x] = x + 1print(*res) 倍数问题1234. 倍数问题 n, K = map(int, input().split())nums = list(map(int, input().split()))dp = [[float(-inf)] * K for _ in range(4)]dp[0][0] = 0a = [[] for _ in range(K)]for num in nums: a[num % K].append(num)for i in range(K): tmp = sorted(a[i], reverse = True) for i in range(min(3, len(tmp))): for j in range(3, 0, -1): for k in range(K): dp[j][k] = max(dp[j][k], dp[j - 1][(k - tmp[i]) % K] + tmp[i])print(dp[3][0]) 组合数问题523. 组合数问题 t, k = map(int, input().split())c = [[0] * 2001 for _ in range(2001)]s = [[0] * 2001 for _ in range(2001)]for i in range(2001): for j in range(i + 1): if j == 0: c[i][j] = 1 else: c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % k if c[i][j] == 0: s[i][j] = 1for i in range(2001): for j in range(2001): if i: s[i][j] += s[i - 1][j] if j: s[i][j] += s[i][j - 1] if i and j: s[i][j] -= s[i - 1][j - 1]for _ in range(t): n, m = map(int, input().split()) print(s[n][m]) 模拟散列表840. 模拟散列表 n = int(input())dicts = for _ in range(n): op, x = input().split() if op == I: dicts[x] = dicts.get(x, 0) + 1 elif op == Q: if dicts.get(x): print(Yes) else: print(No)","tags":["算法","Python","蓝桥杯","AcWing"],"categories":["算法"]},{"title":"PAT 乙级","path":"/2024/01/29/pat乙级/","content":"1001 害死人不偿命的(3n+1)猜想n = int(input())num = 0while n != 1: if n % 2 == 0: n = n // 2 else: n = (3 * n + 1) // 2 num += 1print(num) 1002 写出这个数n = input()res = 0for char in n: res += int(char)dicts = [ling, yi, er, san, si, wu, liu, qi, ba, jiu]ans = []for char in str(res): ans.append(dicts[int(char)])print( .join(map(str, ans))) 1003 我要通过！n = int(input())def check(arg): length = len(arg) idx = cnt1 = cnt2 = cnt3 = 0 while idx length and arg[idx] == A: cnt1 += 1 idx += 1 if idx length and arg[idx] == P: idx += 1 else: return False while idx length and arg[idx] == A: idx += 1 cnt2 += 1 if idx length and arg[idx] == T: idx += 1 else: return False while idx length and arg[idx] == A: idx += 1 cnt3 += 1 if idx == length and cnt1 * cnt2 == cnt3 and cnt2: return True else: return Falsefor _ in range(n): a = input() print(YES if check(a) else NO) 1004 成绩排名n = int(input())students = []for i in range(n): name, number, grade = input().split() students.append([name, number, grade])students.sort(key=lambda x: int(x[2]))print(students[-1][0], students[-1][1])print(students[0][0], students[0][1]) 1005 继续(3n+1)猜想n = int(input())nums = list(map(int, input().split()))res = nums[:]def check(num): while num != 1: if num % 2 == 0: num = num // 2 else: num = (3 * num + 1) // 2 if num in res: res.remove(num) returnfor num in nums: check(num)res.sort(reverse=True)print( .join(map(str, res))) 1006 换个格式输出整数n = 00 + input()res = B * int(n[-3]) + S * int(n[-2]) + .join([str(i) for i in range(1, int(n[-1]) + 1)])print(res) 1007 素数对猜想n = int(input())state = [True] * (n + 1)primes = []for i in range(2, n + 1): if state[i]: primes.append(i) for j in range(i * 2, n + 1, i): state[j] = Falseres = 0for i in range(len(primes) - 1): if primes[i + 1] - primes[i] == 2: res += 1print(res) 1008 数组元素循环右移问题n, m = map(int, input().split())nums = list(map(int, input().split()))nums = nums[n - m: ] + nums[: n - m]print( .join(map(str, nums))) 1009 说反话s = list(input().split())print( .join(map(str, s[::-1]))) 1010 一元多项式求导nums = list(map(int, input().split()))res = []for i in range(0, len(nums), 2): a = nums[i] * nums[i + 1] b = nums[i + 1] - 1 if a: res.extend((a, b))if not res: res.extend((0, 0))print( .join(map(str, res))) 1011 A+B 和 Ct = int(input())for i in range(1, t + 1): a, b, c = map(int, input().split()) if a + b c: print(fCase #i: true) else: print(fCase #i: false) 1012 数字分类nums = list(map(int, input().split()))res1 = res2 = len2 = res3 = res4 = len4 = res5 = 0for num in nums[1: ]: if num % 10 == 0: res1 += num elif num % 5 == 1: res2 += (-1) ** (len2 % 2) * num len2 += 1 elif num % 5 == 2: res3 += 1 elif num % 5 == 3: res4 += num len4 += 1 elif num % 5 == 4: res5 = num if num res5 else res5if not res1: res1 = Nif not len2: res2 = Nif not res3: res3 = Nif len4: res4 = round(res4 / len4, 1)else: res4 = Nif not res5: res5 = Nprint(res1, res2, res3, res4, res5) 1013 数素数m, n = map(int, input().split())state = [True] * 600000for i in range(2, int(600000**0.5) + 1): if state[i]: for j in range(i * i, 600000, i): state[j] = Falseprimes = [num for num in range(2, 600000) if state[num]]tmps = primes[m - 1: n]ress = [tmps[i:i+10] for i in range(0, len(tmps), 10)]for res in ress: print( .join(map(str, res))) 1014 福尔摩斯的约会s1, s2, s3, s4 = input(), input(), input(), input()len1, len2 = min(len(s1), len(s2)), min(len(s3), len(s4))res = []DAY = A: MON, B: TUE, C: WED, D: THU, E: FRI, F: SAT, G: SUNfor i in range(len1): if s1[i] == s2[i] and A = s1[i] = G: res.append(DAY[s1[i]]) breakfor j in range(i + 1, len1): if s1[j] == s2[j]: if 0 = s1[j] = 9: res.append(0 + s1[j]) break if A = s1[j] = N: res.append(str(ord(s1[j]) - 55)) breakfor i in range(len2): if s3[i] == s4[i] and (97 = ord(s3[i]) = 122 or 65 = ord(s3[i]) = 90): if i 10: res.append(0 + str(i)) else: res.append(str(i))print(fres[0] res[1]:res[2]) 1015 德才论（部分通过）from sys import stdininput = lambda: stdin.readline().strip()n, l, h = map(int, input().split())res1, res2, res3, res4 = [], [], [], []for _ in range(n): a, b, c = map(int, input().split()) if b = h and c = h: res1.append([a, b, c, b + c]) elif b = h and c = l: res2.append([a, b, c, b + c]) elif b = l and c = l and b = c: res3.append([a, b, c, b + c]) elif b = l and c = l: res4.append([a, b, c, b + c])print(len(res1) + len(res2) + len(res3) + len(res4))res1.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res2.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res3.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)res4.sort(key=lambda x: (x[3], x[1], -x[0]), reverse=True)for res in res1: print( .join(map(str, res[: -1])))for res in res2: print( .join(map(str, res[: -1])))for res in res3: print( .join(map(str, res[: -1])))for res in res4: print( .join(map(str, res[: -1]))) 1016 部分A+BA, Da, B, Db = input().split()Pa = Da * A.count(Da) if A.count(Da) else 0Pb = Db * B.count(Db) if A.count(Da) else 0print(int(Pa) + int(Pb)) 1017 A除以Ba, b = map(int, input().split())print(a // b, a % b) 1018 锤子剪刀布n = int(input())a = b = c = 0jia, yi = [], []for _ in range(n): x, y = input().split() jia.append(x) yi.append(y) if x == y: c += 1 elif x == C and y == J or x == J and y == B or x == B and y == C: a += 1 jia.append(x) else: b += 1 yi.append(y)print(a, c, b)print(n - a - c, c, n - b - c)b1, c1, j1 = jia.count(B), jia.count(C), jia.count(J)b2, c2, j2 = yi.count(B), yi.count(C), yi.count(J)t1, t2 = max(b1, c1, j1), max(b2, c2, j2)if b1 == t1: print(B, end= )elif c1 == t1: print(C, end= )else: print(J, end= )if b2 == t2: print(B)elif c2 == t2: print(C)else: print(J) 1019 数字黑洞n = input()def fun(n): n = map(int, list(str(n).zfill(4))) b = list(map(str, sorted(n))) a = b[::-1] c = .join(a) d = .join(b) e = int(c) - int(d) e = str(e).zfill(4) print(fc - d = e) if e != 0000 and e != 6174: fun(e)fun(n) 020 月饼N, D = map(int, input().split())stocks = list(map(float, input().split()))prices = list(map(float, input().split()))profits = [price / stock for stock, price in zip(stocks, prices)]yuebings = sorted(zip(stocks, prices, profits), key=lambda x: x[2], reverse=True)res = 0for stock, price, profit in yuebings: a = min(stock, D) res += a * profit D -= a if not D: breakprint(fres:.2f) 1021 个位数统计n = input()nums = 0123456789for num in nums: if n.count(num): print(fnum:n.count(num)) 1022 D进制的A+Ba, b, d = map(int, input().split())c = a + bres = []while c: res.append(c % d) c //= dif res: print(.join(map(str, res[::-1])))else: print(0) 1023 组个最小数nums = list(map(int, input().split()))res = for i in range(1, 10): if nums[i]: nums[i] -= 1 res = str(i) breaknums = [str(num) * nums[num] for num in range(10) if nums[num]]print(res + .join(map(str, nums))) 1024 科学计数法a = input()res = []if a[0] == -: res.append(-)e = a.find(E)exp = int(a[e+2:])if a[e + 1] == +: res.append(a[1]) if exp = e - 3: res.append(a[3: e]) res.append(0 * (exp - e + 3)) else: res.append(a[3: 3 + exp]) res.append(.) res.append(a[3 + exp: e])elif a[e + 1] == -: res.append(0.) if exp 1: res.append(0 * (exp - 1)) res.append(a[1]) res.append(a[3: e])print(.join(res)) 1025 反转链表start, n, k = map(int, input().split())datas, nexts, lst = [0] * 100001, [0] * 100001, []for _ in range(n): a, b, c = map(int, input().split()) datas[a], nexts[a] = b, cwhile start != -1: lst.append(start) start = nexts[start]cnt = len(lst)for i in range(0, cnt - cnt % k, k): lst[i: i + k] = lst[i: i + k][::-1]for i in range(cnt - 1): print(flst[i]:05d datas[lst[i]] lst[i + 1]:05d)print(flst[-1]:05d datas[lst[-1]] -1) 1026 程序运行时间c1, c2 = map(int, input().split())t = (c2 - c1 + 50) // 100res = []while t: if t % 60 10: res.append(0 + str(t % 60)) else: res.append(str(t % 60)) t //= 60while len(res) 3: res.append(00)print(:.join( res[::-1])) 1027 打印沙漏n, symbol = input().split()shalous = []shalou = -1for i in range(30): shalou += 2 * (2 * i + 1) shalous.append(shalou)for i in range(30): if int(n) shalous[i]: breaka = 2 * (i - 1) + 1for j in range(a, 1, -2): print( * ((a - j) // 2) + symbol * j)for j in range(1, a + 1, 2): print( * ((a - j) // 2) + symbol * j)print(int(n) - shalous[i - 1]) 1028 人口普查（部分通过）from sys import stdininput = lambda: stdin.readline().strip()n = int(input())nums = []for _ in range(n): name, birth = input().split() y, m, d = birth.split(/) if 18140906 = y + m + d = 20140906: nums.append([name, int(y), int(m), int(d)])nums.sort(key=lambda x: (x[1], x[2], x[3]))if nums: print(len(nums), nums[0][0], nums[-1][0])else: print(0) 1029 旧键盘a, b = input(), input()dicts = for char in b: dicts[char] = 1res = []for char in a: if not dicts.get(char, 0): if char.isalpha(): char = char.upper() res.append(char)print(.join(.fromkeys(res).keys())) 1030 完美数列n, p = map(int, input().split())nums = list(map(int, input().split()))nums.sort()res, j = 1, 0for i in range(n): while j n and nums[j] = nums[i] * p: j += 1 res = max(res, j - i)print(res) 1031 查验身份证n = int(input())dicts = [1, 0, X, 9, 8, 7, 6, 5, 4, 3, 2]weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]def check(id_card): check_num = 0 for i in range(17): if 48 = ord(id_card[i]) = 57: check_num += int(id_card[i]) * weights[i] else: return False check_num %= 11 return id_card[-1] == str(dicts[check_num])res = 0for _ in range(n): id_card = input() if not check(id_card): print(id_card) res += 1if not res: print(All passed) 1032 挖掘机技术哪家强n = int(input())nums = [-1] + [0] * 100000for _ in range(n): a, b = map(int, input().split()) nums[a] += bprint(nums.index(max(nums)), max(nums)) 1033 旧键盘打字bad, string = list(input()), input()shift = Falsefor i in bad: if i == +: shift = True if 65 = ord(i) = 90: bad.append(i.lower())for i in string: if 65 = ord(i) = 90 and shift: continue if i not in bad: print(i, end=) 1034 有理数四则运算import matha, b = input().split()def simplify(a): x, y = map(int, a.split(/)) return str(x // math.gcd(x, y)) + / + str(y // math.gcd(x, y))a, b = simplify(a), simplify(b)def calculate(a, b): x1, y1 = map(int, a.split(/)) x2, y2 = map(int, b.split(/)) t = str(x1 * y2 + x2 * y1) + / + str(y1 * y2) res.append(simplify(t)) t = str(x1 * y2 - x2 * y1) + / + str(y1 * y2) res.append(simplify(t)) t = str(x1 * x2) + / + str(y1 * y2) res.append(simplify(t)) if not x2: res.append(1/0) else: if x2 0: x2, y2 = -x2, -y2 t = str(x1 * y2) + / + str(y1 * x2) res.append(simplify(t))res = []calculate(a, b)def simplify2(a): x, y = map(int, a.split(/)) if not y: return Inf ans = t = abs(x) // y if not x % y: ans = str(t) elif t: ans = str(t) + + str(abs(x - t * y * x // abs(x))) + / + str(y) else: ans = str(abs(x)) + / + str(y) return (- + ans + ) if x 0 else ansa, b, res = simplify2(a), simplify2(b), [simplify2(i) for i in res]print(fa + b = res[0])print(fa - b = res[1])print(fa * b = res[2])print(fa / b = res[3]) 1035 插入与归并n = int(input())start = list(map(int, input().split()))mid = list(map(int, input().split()))for i in range(n - 1, -1, -1): if start[i] != mid[i]: breakif sorted(mid[:i + 1]) == mid[:i + 1]: print(Insertion Sort) a = start[i + 1] while a start[i]: i += 1 a = start[i + 1] for j in range(i + 1): if a mid[j]: print( .join(map(str, (mid[: j] + [a] + mid[j:i + 1] + mid[i+2:])))) breakelse: print(Merge Sort) i = 1 flag = True while i n and flag: i *= 2 for j in range(i, n, i): if sorted(mid[j-i: j]) != mid[j-i: j]: flag = False break if i j: mid.sort() else: for j in range(i, n, i): mid[j-i: j] = sorted(mid[j-i: j]) mid[j:] = sorted(mid[j:]) print( .join(map(str, mid))) 1036 跟奥巴马一起编程n, c = input().split()n = int(n)row = int(n / 2 + 0.5) - 2print(c * n)for _ in range(row): print(c + * (n - 2) + c)print(c * n) 1037 在霍格沃茨找零钱p, a = input().split()g1, s1, k1 = map(int, p.split(.))g2, s2, k2 = map(int, a.split(.))t1 = (g1 * 17 + s1) * 29 + k1t2 = (g2 * 17 + s2) * 29 + k2t3 = abs(t2 - t1)k3 = t3 % 29s3 = t3 // 29 % 17g3 = (t3 // 29 - s3) // 17if t2 = t1: print(fg3.s3.k3)else: print(f-g3.s3.k3) 1038 统计同成绩学生n = int(input())nums = list(map(int, input().split()))checks = list(map(int, input().split()))scores = [0] * 101for num in nums: scores[num] += 1res = []for check in checks[1:]: res.append(scores[check])print( .join(map(str, res))) 1039 到底买不买s, t = input(), input()a, dict1 = 0, for char in s: dict1[char] = dict1.get(char, 0) + 1for char in t: if dict1.get(char, 0): a += 1 dict1[char] -= 1if a == len(t): print(fYes len(s) - len(t))else: print(fNo len(t) - a) 1040 有几个PATimport bisects = input()p, a, pa, t = [], [], [], []for idx, char in enumerate(s): if char == P: p.append(idx) elif char == A: a.append(idx) elif char == T: t.append(idx)tmp = 0for i in a: x = bisect.bisect(p, i) tmp += x pa.append(tmp)res = 0for i in t: x = bisect.bisect(a, i) if x: res += pa[x-1]print(res % 1000000007) 1041 考试座位号n = int(input())nums = [0] * 10001for _ in range(n): a, b, c = map(int, input().split()) nums[b] = (a, c)m = int(input())inqurie = map(int, input().split())for i in inqurie: print(nums[i][0], nums[i][1]) 1042 字符统计from collections import Counters = input()t = []for char in s: if 65 = ord(char) = 90: char = char.lower() if 97 = ord(char) = 122: t.append(char)t.sort()t = Counter(t)print(t.most_common(1)[0][0], t.most_common(1)[0][1]) 1043 输出PATestfrom collections import Counters = input()t = [char for char in s if char in PATest]counter = Counter(t)res = for _ in range(counter.most_common(1)[0][1]): for char in PATest: if counter[char]: counter[char] -= 1 res += charprint(res) 1044 火星数字n = int(input())units = [tret, jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec]tens = [tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou]for _ in range(n): a = input() try: a = int(a) except ValueError: if len(a) 4: x, y = a.split() ten, unit = tens.index(x) + 1, units.index(y) print(ten * 13 + unit) else: if a in units: print(units.index(a)) else: print((tens.index(a) + 1) * 13) else: unit, ten = a % 13, a // 13 if ten 0 and unit 0: print(tens[ten - 1], units[unit]) elif ten 0: print(tens[ten - 1]) else: print(units[unit]) 1045 快速排序n = int(input())nums = list(map(int, input().split()))lefts, rights, res = [], [], []left, right = 0, float(inf)for num in nums: if left num: left = num lefts.append(left)for num in nums[::-1]: if right num: right = num rights.append(right)for left, num, right in zip(lefts, nums, rights[::-1]): if left = num = right: res.append(num)print(len(res))print( .join(map(str, res))) 1046 划拳n = int(input())a = b = 0for _ in range(n): x1, x2, y1, y2 = map(int, input().split()) if x2 == y2: continue if x1 + y1 == x2: b += 1 elif x1 + y1 == y2: a += 1print(a, b) 1047 编程团体赛n = int(input())nums = [0] * 1001for _ in range(n): num, score = input().split() a, b = map(int, num.split(-)) nums[a] += int(score)res = max(nums)print(nums.index(res), res) 1048 数字加密a, b = input().split()l = max(len(a), len(b))a = list(map(int, a[::-1])) + [0] * (l - len(a))b = list(map(int, b[::-1])) + [0] * (l - len(b))dicts = [J, Q, K]res = []for i in range(l): if i % 2 == 0: t = (a[i] + b[i]) % 13 res.append(dicts[t - 10] if t = 10 else t) else: res.append((b[i] - a[i] + 10) % 10)print(.join(map(str, res[::-1]))) 1049 数列的片段和（部分通过）n = int(input())nums = list(map(float, input().split()))res, a = 0, 1for num in nums: res += num * a * n n -= 1 a += 1print(fres:.2f) 1050 螺旋矩阵import mathN = int(input())nums = list(map(int, input().split()))nums.sort(reverse=True)m = n = 0for i in range(1, int(math.sqrt(N)) + 1): if N % i == 0: n, m = i, N // ires = [[0] * n for _ in range(m)]u, d, l, r = 0, m, 0, nidx = 0while True: res[u][l:r] = nums[idx: idx+r-l] u += 1 idx += r-l if u == d or l == r: break for i in range(u, d): res[i][r-1] = nums[idx] idx += 1 r -= 1 if u == d or l == r: break res[d-1][l:r] = nums[idx: idx+r-l][::-1] idx += r-l d -= 1 if u == d or l == r: break for i in range(d-1, u-1, -1): res[i][l] = nums[idx] idx += 1 l += 1 if u == d or l == r: breakfor row in res: print( .join(map(str, row))) 1051 复数乘法import mathr1, p1, r2, p2 = map(float, input().split())a1 = r1 * math.cos(p1)b1 = r1 * math.sin(p1)a2 = r2 * math.cos(p2)b2 = r2 * math.sin(p2)a3 = a1*a2-b1*b2 b3 = a1*b2+a2*b1if abs(a3) 0.005: a3 = 0if abs(b3) 0.005: print(fa3:.2f+0.00i)elif b3 0: print(fa3:.2f+b3:.2fi)else: print(fa3:.2fb3:.2fi) 1052 卖个萌看不懂题 1053 住房空置率n, e, d = map(float, input().split())maybe_vacant = vacant = 0for _ in range(int(n)): nums = list(map(float, input().split())) t = sum(1 for i in nums[1:] if i e) if t / nums[0] 0.5: if nums[0] d: vacant += 1 else: maybe_vacant += 1print(fmaybe_vacant / n * 100:.1f% vacant / n * 100:.1f%)","tags":["算法","Python","PAT"],"categories":["算法"]},{"title":"算法基础课","path":"/2024/01/29/算法基础课/","content":"AcWing算法基础课基础算法快速排序785. 快速排序 n = int(input())nums = list(map(int, input().split()))def quick_sort(l, r): if l = r: return i, j = l - 1, r + 1 x = nums[l + r 1] while i j: while True: i += 1 if nums[i] = x: break while True: j -= 1 if nums[j] = x: break if i j: nums[i], nums[j] = nums[j], nums[i] quick_sort(l, j) quick_sort(j + 1, r)quick_sort(0, n - 1)print(*nums) 786. 第k个数 n, k = map(int, input().split())nums = list(map(int, input().split()))def quick_select(l, r, k): if l = r: return nums[l] x = nums[(l + r) // 2] i, j = l - 1, j + 1 while i j: while True: i += 1 if nums[i] = x: break while True: j -= 1 if nums[j] = x: break if i j: nums[i], nums[j] = nums[j], nums[i] sl = j - l + 1 if k = sl: return quick_select(l, j, k) else: return quick_select(j + 1, r, k - sl) print(quick_select(0, n - 1, k)) 归并排序787. 归并排序 n = int(input())nums = [int(x) for x in input().split()]def merge_sort(nums, l, r): if l = r: return mid = (l + r) // 2 merge_sort(nums, l, mid) merge_sort(nums, mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp merge_sort(nums, 0, n - 1)print( .join(list(map(str, nums)))) 788. 逆序对的数量 n = int(input())nums = list(map(int, input().split()))def merge_sort(l, r): if l = r: return 0 mid = l + r 1 res = merge_sort(l, mid) + merge_sort(mid + 1, r) i, j = l, mid + 1 tmp = [] while i = mid and j = r: if nums[i] = nums[j]: tmp.append(nums[i]) i += 1 else: tmp.append(nums[j]) j += 1 res += mid - i + 1 tmp += nums[i: mid + 1] tmp += nums[j: r + 1] nums[l: r + 1] = tmp return resprint(merge_sort(0, n - 1)) 二分789. 数的范围 n, q = map(int, input().split())nums = [int(x) for x in input().split()]while q 0: q -= 1 x = int(input()) l, r = 0, n - 1 while l r: mid = (l + r) // 2 if nums[mid] = x: r = mid else: l = mid + 1 if nums[l] != x: print(-1 -1) continue left = l l, r = 0, n - 1 while l r: mid = (l + r + 1) // 2 if nums[mid] = x: l = mid else: r = mid - 1 print(fleft l) 790. 数的三次方根 n = float(input())l, r = -100, 100while abs(l - r) 1e-8: mid = (l + r) / 2 if mid ** 3 n: r = mid else: l = midprint(fl:.6f) 前缀和795. 前缀和 n, m = map(int, input().split())nums = [int(x) for x in input().split()]sums = [0] * (n + 1)for i in range(n): sums[i + 1] = sums[i] + nums[i]for _ in range(m): l, r = map(int, input().split()) print(sums[r] - sums[l - 1]) 796. 子矩阵的和 n, m, q = map(int, input().split())nums = [[0] * (m + 1) for _ in range(n + 1)]sums = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:]for i in range(1, n + 1): for j in range(1, m + 1): sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + nums[i][j]for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(sums[x2][y2] - sums[x1 - 1][y2] - sums[x2][y1 - 1] + sums[x1 - 1][y1 - 1]) 差分797. 差分 n, m = map(int, input().split())nums = [0] + list(map(int, input().split()))diffs = [0] * (n + 2)def insert(l, r, c): diffs[l] += c diffs[r + 1] -= cfor i in range(1, n + 1): insert(i, i, nums[i])for _ in range(m): l, r, c = map(int, input().split()) insert(l, r, c)for i in range(1, n + 1): nums[i] = nums[i - 1] + diffs[i] print(nums[i], end= ) 798. 差分矩阵 n, m, q = map(int, input().split())nums = [[0] * (m + 2) for _ in range(n + 2)]diffs = [[0] * (m + 2) for _ in range(n + 2)]def insert(x1, y1, x2, y2, c): diffs[x1][y1] += c diffs[x1][y2 + 1] -= c diffs[x2 + 1][y1] -= c diffs[x2 + 1][y2 + 1] += cfor i in range(1, n + 1): tmps = list(map(int, input().split())) nums[i] = [0] + tmps[:] for j in range(1, m + 1): insert(i, j, i, j, tmps[j - 1])for _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c)for i in range(1, n + 1): for j in range(1, m + 1): nums[i][j] = nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1] + diffs[i][j] print(nums[i][j], end= ) print() 双指针799. 最长连续不重复子序列 n = int(input())nums = list(map(int, input().split()))dic = dict.fromkeys(nums, 0)j = res = 0for i in range(n): dic[nums[i]] += 1 while dic[nums[i]] 1: dic[nums[j]] -= 1 j += 1 res = max(res, i - j + 1)print(res) 800. 数组元素的目标和 n, m, x = map(int, input().split())a = list(map(int, input().split()))b = list(map(int, input().split()))j = m - 1for i in range(n): while j and a[i] + b[j] x: j -= 1 if a[i] + b[j] == x: print(i, j) break 二进制801. 二进制中1的个数 n = int(input())nums = list(map(int, input().split()))def lowbit(x): return x -xfor num in nums: res = 0 while num: num -= lowbit(num) res += 1 print(res, end= ) 离散化802. 区间和 n, m = map(int, input().split())# adds = [list(map(int, input().split())) for _ in range(n)]# querys = [list(map(int, input().split())) for _ in range(m)]# indexs = [add[0] for add in adds]# for l, r in querys:# indexs += [l, r]adds, querys, indexs = [], [], []for i in range(n): x, c = map(int, input().split()) adds.append([x, c]) indexs.append(x)for i in range(m): l, r = map(int, input().split()) querys.append([l, r]) indexs.append(l) indexs.append(r)indexs.sort()indexs = list(set(indexs))n = len(indexs)def find(x): l, r = 0, n - 1 while l r: mid = l + r 1 if indexs[mid] = x: r = mid else: l = mid + 1 return l + 1nums = [0] * (n + 1)sums = [0] * (n + 1)for x, c in adds: nums[find(x)] += cfor i in range(1, n + 1): sums[i] = sums[i - 1] + nums[i]for l, r in querys: print(sums[find(r)] - sums[find(l) - 1]) 区间合并803. 区间合并 n = int(input())nums = [list(map(int, input().split())) for _ in range(n)]nums.sort(key=lambda x: x[0])st, ed = float(-inf), float(-inf)res = 0for l, r in nums: if ed l: res += 1 st = l ed = r else: ed = max(ed, r)print(res) 数据结构单链表826. 单链表 def insert_head(x): global head, idx e[idx] = x ne[idx] = head head = idx idx += 1 def insert(k, x): global idx e[idx] = x ne[idx] = ne[k] ne[k] = idx idx += 1 def remove(k): ne[k] = ne[ne[k]] N = 100010e, ne = [0] * N, [0] * Nhead, idx = -1, 0n = int(input())for _ in range(n): ops = input().split() if ops[0] == H: insert_head(int(ops[1])) elif ops[0] == I: insert(int(ops[1]) - 1, int(ops[2])) else: k = int(ops[1]) if not k: head = ne[head] remove(k - 1)i = headres = []while i != -1: res.append(e[i]) i = ne[i]print( .join(map(str, res))) 双链表827. 双链表 N = 100010e, l, r = [0] * N, [0] * N, [0] * Nr[0], l[1], idx = 1, 0, 2def insert(k, x): global idx e[idx] = x r[idx] = r[k] l[idx] = k l[r[k]] = idx r[k] = idx idx += 1def remove(k): r[l[k]] = r[k] l[r[k]] = l[k]n = int(input())for _ in range(n): ops = input().split() if ops[0] == L: insert(0, int(ops[1])) elif ops[0] == R: insert(l[1], int(ops[1])) elif ops[0] == IL: insert(l[int(ops[1]) + 1], int(ops[2])) elif ops[0] == IR: insert(int(ops[1]) + 1, int(ops[2])) else: remove(int(ops[1]) + 1)i = r[0]res = []while i != 1: res.append(e[i]) i = r[i]print( .join(map(str, res))) 栈828. 模拟栈 n = int(input())stack = []for _ in range(n): ops = input().split() if ops[0] == push: stack.append(ops[1]) elif ops[0] == pop: stack.pop() elif ops[0] == query: print(stack[-1]) elif ops[0] == empty: print(NO if stack else YES) 3302. 表达式求值 dic = (: 0, +: 1, -: 1, *: 2, /: 2ops, nums = [], []def new_eval(): b = nums.pop() a = nums.pop() o = ops.pop() if o == +: nums.append(a + b) elif o == -: nums.append(a - b) elif o == *: nums.append(a * b) elif o == /: nums.append(int(a / b))a = input()n = len(a)i = 0while i n: c = a[i] if c.isdigit(): j, x = i, 0 while j n and a[j].isdigit(): x = x * 10 + int(a[j]) j += 1 i = j - 1 nums.append(x) elif c == (: ops.append(c) elif c == ): while ops[-1] != (: new_eval() ops.pop() else: while ops and dic[ops[-1]] = dic[c]: new_eval() ops.append(c) i += 1while ops: new_eval()print(nums[-1]) 队列829. 模拟队列 import collectionsn = int(input())queue = collections.deque()for _ in range(n): ops = input().split() if ops[0] == push: queue.append(ops[1]) elif ops[0] == pop: queue.popleft() elif ops[0] == query: print(queue[0]) elif ops[0] == empty: print(NO if queue else YES) 单调栈830. 单调栈 n = int(input())nums = list(map(int, input().split()))stack, res = [], []for num in nums: if not stack: stack.append(num) res.append(-1) continue while stack and num = stack[-1]: stack.pop() if not stack: res.append(-1) else: res.append(stack[-1]) stack.append(num)print( .join(map(str, res))) 单调队列154. 滑动窗口 n, k = map(int, input().split())nums = list(map(int, input().split()))q = [0] * 1000010hh, tt = 0, -1res1, res2 = [], []for i in range(n): if hh = tt and i - k + 1 q[hh]: hh += 1 while hh = tt and nums[q[tt]] nums[i]: tt -= 1 tt += 1 q[tt] = i if i = k - 1: res1.append(nums[q[hh]])hh, tt = 0, -1for i in range(n): if hh = tt and i - k + 1 q[hh]: hh += 1 while hh = tt and nums[q[tt]] nums[i]: tt -= 1 tt += 1 q[tt] = i if i = k - 1: res2.append(nums[q[hh]])print( .join(map(str, res1)))print( .join(map(str, res2))) KMP831. KMP字符串 n = int(input())p = + input()m = int(input())s = + input()ne = [0] * 1000010j = 0for i in range(2, n + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = jj = 0res = []for i in range(1, m + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == n: res.append(i - j) j = ne[j]print( .join(map(str, res))) Trie835. Trie字符串统计 N = 10010tries = [[0] * 26 for _ in range(N)]cnt = [0] * Nidx = 1def insert(string): global idx p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: tries[p][t] = idx idx += 1 p = tries[p][t] cnt[p] += 1def query(string): p = 0 for char in string: t = ord(char) - 97 if not tries[p][t]: return 0 p = tries[p][t] return cnt[p]n = int(input())for _ in range(n): op, string = input().split() if op == I: insert(string) elif op == Q: print(query(string)) 143. 最大异或对 N = 100010M = 31 * Ntries = [[0] * 2 for _ in range(M)]n = int(input())nums = list(map(int, input().split()))idx, res = 0, 0def insert(x): global idx p = 0 for i in range(32)[::-1]: u = x i 1 if not tries[p][u]: idx += 1 tries[p][u] = idx p = tries[p][u]def query(x): p, res = 0, 0 for i in range(32)[::-1]: u = x i 1 if tries[p][u^1]: res = res * 2 + u^1 p = tries[p][u^1] else: res = res * 2 + u p = tries[p][u] return resfor num in nums: insert(num) t = query(num) res = max(res, t^num)print(res) 并查集836. 合并集合 n, m = map(int, input().split())p = [i for i in range(n + 1)]def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): op, a, b = input().split() a, b = int(a), int(b) if op == M: p[find(a)] = find(b) elif op == Q: if find(a) == find(b): print(Yes) else: print(No) 837. 连通块中点的数量 n, m = map(int, input().split())p = [i for i in range(n + 1)]size = [1] * (n + 1)def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m): ops = input().split() if ops[0] == C: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): continue size[find(b)] += size[find(a)] p[find(a)] = find(b) elif ops[0] == Q1: a, b = int(ops[1]), int(ops[2]) if find(a) == find(b): print(Yes) else: print(No) elif ops[0] == Q2: print(size[find(int(ops[1]))]) 240. 食物链 n, m = map(int, input().split())p, d = [i for i in range(n + 1)], [0] * (n + 1)res = 0def find(x): if p[x] != x: t = find(p[x]) d[x] += d[p[x]] p[x] = t return p[x]for _ in range(m): op, x, y = map(int, input().split()) if x n or y n: res += 1 continue px, py = find(x), find(y) diff = (d[x] - d[y]) % 3 if op == 1: if px == py and diff: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] elif op == 2: if px == py and diff != 1: res += 1 else: p[px] = p[y] d[px] = d[y] - d[x] + 1print(res) 堆838. 堆排序 n, m = map(int, input().split())heap = [0] + list(map(int, input().split()))def down(k): t = k if 2 * k = n and heap[2 * k] heap[t]: t = 2 * k if 2 * k + 1 = n and heap[2 * k + 1] heap[t]: t = 2 * k + 1 if t != k: heap[t], heap[k] = heap[k], heap[t] down(t)for i in range(int(n / 2), -1, -1): down(i)for _ in range(m): print(heap[1], end= ) heap[1] = heap[n] n -= 1 down(1) 839. 模拟堆 N = 100010heap, ph, hp = [0] * N, [0] * N, [0] * Nsize, idx = 0, 0n = int(input())def swap(a, b): ph[hp[a]], ph[hp[b]] = b, a hp[a], hp[b] = hp[b], hp[a] heap[a], heap[b] = heap[b], heap[a]def down(k): t = k if 2 * k = size and heap[2 * k] heap[t]: t = 2 * k if 2 * k + 1 = size and heap[2 * k + 1] heap[t]: t = 2 * k + 1 if t != k: swap(t, k) down(t)def up(k): while k // 2 and heap[k // 2] heap[k]: swap(k // 2, k) k //= 2for _ in range(n): ops = input().split() if ops[0] == I: size += 1 idx += 1 heap[size] = int(ops[1]) ph[idx] = size hp[size] = idx up(size) elif ops[0] == PM: print(heap[1]) elif ops[0] == DM: swap(1, size) size -= 1 down(1) elif ops[0] == D: k = ph[int(ops[1])] swap(k, size) size -= 1 down(k) up(k) elif ops[0] == C: k, x = ph[int(ops[1])], int(ops[2]) heap[k] = x down(k) up(k) 哈希表840. 模拟散列表 拉链法 N = 100003h, e, ne = [-1] * N, [0] * N, [0] * Nn = int(input())idx = 0def insert(x): global idx k = x % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1def find(x): k = x % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return Falsefor _ in range(n): op, x = input().split() if op == I: insert(int(x)) elif op == Q: if find(int(x)): print(Yes) else: print(No) 开放寻址法 N = 200003null = 0x3f3f3f3fh = [null] * Nn = int(input())def find(x): k = x % N while h[k] != null and h[k] != x: k += 1 if k == N: k = 0 return kfor _ in range(n): op, x = input().split() k = find(int(x)) if op == I: h[k] = int(x) elif op == Q: if h[k] == int(x): print(Yes) else: print(No) python 自带 from collections import defaultdictdic = defaultdict(int)n = int(input())for _ in range(n): op, x = input().split() if op == I: dic[x] += 1 elif op == Q: print(Yes if dic[x] else No) 841. 字符串哈希 n, m = map(int, input().split())s = input()Q, P = 1 64, 131h, p = [0] * (n + 1), [1] * (n + 1)def get(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % Qfor i in range(1, n + 1): h[i] = (h[i - 1] * P + ord(s[i - 1])) % Q p[i] = (p[i - 1] * P) % Qfor _ in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(Yes) else: print(No) 搜索与图论DFS842. 排列数字 dfs 做法 n = int(input())path = [0] * nst = [False] * (n + 1)def dfs(x): if x == n: print( .join(map(str, path))) return for i in range(1, n + 1): if not st[i]: path[x] = i st[i] = True dfs(x + 1) st[i] = Falsedfs(0) python permutation方法 import itertoolsn = int(input())nums = [i for i in range(1, n + 1)]for res in itertools.permutations(nums, n): print( .join(map(str, res))) 843. n-皇后问题 全排列 n = int(input())g = [[. for _ in range(n)] for _ in range(n)]col, dg, udg = [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x): if x == n: for i in range(n): print(.join(map(str, g[i]))) print() return for y in range(n): if not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = Q col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x + 1) g[x][y] = . col[y] = dg[x + y] = udg[n - x + y] = 0dfs(0) 原始暴力枚举 n = int(input())g = [[. for _ in range(n)] for _ in range(n)]row, col, dg, udg = [0] * n, [0] * n, [0] * (2 * n), [0] * (2 * n)def dfs(x, y, s): if y == n: y = 0 x += 1 if x == n: if s == n: for i in range(n): print(.join(map(str, g[i]))) print() return if not row[x] and not col[y] and not dg[x + y] and not udg[n - x + y]: g[x][y] = Q row[x] = col[y] = dg[x + y] = udg[n - x + y] = 1 dfs(x, y + 1, s + 1) g[x][y] = . row[x] = col[y] = dg[x + y] = udg[n - x + y] = 0 dfs(x, y + 1, s)dfs(0, 0, 0) BFS844. 走迷宫 from collections import dequen, m = map(int, input().split())g = [list(map(int, input().split())) for _ in range(n)]path = [[-1] * m for _ in range(n)]prev = [[0] * m for _ in range(n)]q = deque()q.append((0, 0))path[0][0] = 0while q: a, b = q.popleft() for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): x = a + l y = b + r if 0 = x n and 0 = y m and not g[x][y] and path[x][y] == -1: q.append((x, y)) path[x][y] = path[a][b] + 1 prev[x][y] = (a, b)print(path[-1][-1])x, y = n - 1, m - 1while x 0 or y 0: x,y = prev[x][y] print(x,y) 845. 八数码 from collections import dequestart = .join(input().split())queue = deque([start])d = start: 0target = 12345678xdef swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 idx2 else(idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:]def bfs(): while queue: t = queue.popleft() distance = d[t] if t == target: return distance idx = t.find(x) x, y = idx // 3, idx % 3 for l, r in ((0, 1), (1, 0), (0, -1), (-1, 0)): a, b = x + l, y + r if 0 = a 3 and 0 = b 3: t = swap(t, a * 3 + b, idx) if t not in d: d[t] = distance + 1 queue.append(t) t = swap(t, a * 3 + b, idx) return -1print(bfs()) 树与图的深度优先遍历846. 树的重心 用链表作为邻接表 n = int(input())h, e, ne = [-1] * (n + 1), [0] * (2 * n), [0] * (2 * n)state = [False] * (n + 1)idx, ans = 0, ndef add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxdef dfs(u): global ans state[u] = True size, res = 1, 0 cur = h[u] while cur != -1: j = e[cur] if not state[j]: s = dfs(j) res = max(res, s) size += s cur = ne[cur] res = max(res, n - size) ans = min(ans, res) return sizefor _ in range(n - 1): a, b = map(int, input().split()) add(a, b) add(b, a)dfs(1)print(ans) 使用python的list[list] n = int(input())adj_list = [[] for _ in range(n + 1)]state = [False] * (n + 1)ans = nfor _ in range(n - 1): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u): global ans state[u] = True size, res = 1, 0 for j in adj_list[u]: if not state[j]: s = dfs(j) res = max(res, s) size += s res = max(res, n - size) ans = min(ans, res) return sizedfs(1)print(ans) 树与图的广度优先遍历847. 图中点的层次 from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)dist = [-1] * (n + 1)queue = deque([1])dist[1] = 0idx = 0def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b)def bfs(): while queue: node = queue.popleft() d = dist[node] if node == n: return d cur = h[node] while cur != -1: j = e[cur] if dist[j] == -1: queue.append(j) dist[j] = d + 1 cur = ne[cur] return -1print(bfs()) 使用python的list[list] from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]d = [0] * (n + 1)queue = deque([1])for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def bfs(): while queue: cur = queue.popleft() distance = d[cur] if cur == n: return distance for j in adj_list[cur]: if not d[j]: d[j] = distance + 1 queue.append(j) return -1print(bfs()) 拓扑排序848. 有向图的拓扑序列 from collections import dequen, m = map(int, input().split())h, e, ne = [-1] * (n + 1), [0] * (m + 1), [0] * (m + 1)d = [0] * (n + 1)idx = 0queue = deque()def add(a, b): global idx idx += 1 e[idx] = b ne[idx] = h[a] h[a] = idxfor _ in range(m): a, b = map(int, input().split()) add(a, b) d[b] += 1def topsort(): for i in range(1, n + 1): if not d[i]: queue.append(i) res = [] while queue: node = queue.popleft() res.append(node) t = h[node] while t != -1: j = e[t] d[j] -= 1 if d[j] == 0: queue.append(j) t = ne[t] if len(res) == n: print( .join(map(str, res))) else: print(-1)topsort() 使用python的list[list] from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]in_degree = [0] * (n + 1)queue = deque()for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) in_degree[b] += 1for i in range(1, n + 1): if not in_degree[i]: queue.append(i)res = []while queue: node = queue.popleft() res.append(node) for j in adj_list[node]: in_degree[j] -= 1 if not in_degree[j]: queue.append(j)if len(res) == n: print( .join(map(str, res)))else: print(-1) Dijkstra849. Dijkstra求最短路 I n, m = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]dist = [float(inf)] * (n + 1)state = [False] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)def dijkstra(): for _ in range(1, n + 1): t = min((j for j in range(1, n + 1) if not state[j]), key=lambda j: dist[j]) state[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], dist[t] + g[t][j]) print(dist[n] if dist[n] != float(inf) else -1)dijkstra() 850. Dijkstra求最短路 II import heapqn, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(inf)] * (n + 1)dist[1] = 0heap = []heapq.heappush(heap, (0, 1))s = set()for _ in range(m): x, y, z = map(int, input().split()) adj_list[x].append((y, z))while heap: d, node = heapq.heappop(heap) if node in s: continue s.add(node) for neighbor, weight in adj_list[node]: if dist[neighbor] dist[node] + weight: dist[neighbor] = dist[node] + weight heapq.heappush(heap, (dist[neighbor], neightbor))print(dist[n] if dist[n] != float(inf) else -1) bellman-ford853. 有边数限制的最短路 n, m, k = map(int, input().split())e = []dist = [float(inf)] * (n + 1)dist[1] = 0for _ in range(m): a, b, c = map(int, input().split()) e.append((a, b, c))for _ in range(k): backup = dist.copy() for a, b, w in e: dist[b] = min(dist[b], backup[a] + w)print(dist[n] if dist[n] != float(inf) else impossible) spfa851. spfa求最短路 from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist = [float(inf)] * (n + 1)state = [False] * (n + 1)queue = deque([1])dist[1] = 0state[1] = Truefor _ in range(m): a, b, w = map(int, input().split()) adj_list[a].append((b, w))while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] dist[cur] + weight: dist[neighbor] = dist[cur] + weight if not state[neighbor]: queue.append(neighbor) state[neighbor] = Trueprint(dist[n] if dist[n] != float(inf) else impossible) 852. spfa判断负环 from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]dist, cnt = [0] * (n + 1), [0] * (n + 1)state = [True] * (n + 1)queue = deque([i for i in range(1, n + 1)])for _ in range(m): a, b, c = map(int, input().split()) adj_list[a].append((b, c))def spfa(): while queue: cur = queue.popleft() state[cur] = False for neighbor, weight in adj_list[cur]: if dist[neighbor] dist[cur] + weight: dist[neighbor] = dist[cur] + weight cnt[neighbor] = cnt[cur] + 1 if cnt[neighbor] = n: return True if not state[neighbor]: queue.append(neighbor) state[neighbor] = True return Falseprint(Yes if spfa() else No) Floyd854. Floyd求最短路 n, m, q = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): g[i][i] = 0for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c)for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): g[i][j] = min(g[i][j], g[i][k] + g[k][j])for _ in range(q): a, b = map(int, input().split()) print(g[a][b] if g[a][b] != float(inf) else impossible) Prim858. Prim算法求最小生成树 n, m = map(int, input().split())g = [[float(inf)] * (n + 1) for _ in range(n + 1)]state = [False] * (n + 1)dist = [float(inf)] * (n + 1)for _ in range(m): a, b, c = map(int, input().split()) g[a][b] = min(g[a][b], c) g[b][a] = g[a][b]def prim(): res = 0 for i in range(n): t = min((j for j in range(1, n + 1) if not state[j]), key = lambda x: dist[x]) if i and dist[t] == float(inf): return impossible if i: res += dist[t] for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) state[t] = True return resprint(prim()) Krustal859. Kruskal算法求最小生成树 n, m = map(int, input().split())e = []p = [i for i in range(n + 1)]res, cnt = 0, 0def find(x): if p[x] != x: p[x] = find(p[x]) return p[x]for _ in range(m):\ta, b, c = map(int, input().split())\te.append((a, b, c))e.sort(key=lambda x: x[2])for a, b, c in e: a, b = find(a), find(b) if a != b: p[a] = b res += c cnt += 1print(res if cnt == n - 1 else impossible) 染色法判定二分图860. 染色法判定二分图 dfs会爆栈 n, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def dfs(u, c): color[u] = c for neighbor in adj_list[u]: if not color[neighbor]: if not dfs(neighbor, c * -1): return False elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not colort[i]: if not dfs(i, 1): print(No) breakelse: print(Yes) bfs from collections import dequen, m = map(int, input().split())adj_list = [[] for _ in range(n + 1)]color = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b) adj_list[b].append(a)def bfs(u): queue = deque() queue.append((u, 1)) while queue: node, c = queue.popleft() color[node] = c for neighbor in adj_list[node]: if not color[neighbor]: queue.append((neighbor, c * -1)) elif color[neighbor] == c: return False return Truefor i in range(1, n + 1): if not color[i]: if not bfs(i): print(No) breakelse: print(Yes) 匈牙利算法861. 二分图的最大匹配 n1, n2, m = map(int, input().split())n = max(n1, n2)adj_list = [[] for _ in range(n + 1)]match = [0] * (n + 1)for _ in range(m): a, b = map(int, input().split()) adj_list[a].append(b)def find(u): for neighbor in adj_list[u]: if not state[neighbor]: state[neighbor] = True if not match[neighbor] or find(match[neighbor]): match[neighbor] = u return True return Falseres = 0for i in range(1, n1 + 1): state = [0] * (n + 1) if find(i): res += 1print(res) 数学知识质数866. 试除法判定质数 import mathn = int(input())def prime(x): if x 2: return False for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: return False return Truefor _ in range(n): x = int(input()) print(Yes if prime(x) else No) 867. 分解质因数 import mathn = int(input())def divid(x): for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: s = 0 while x % i == 0: x //= i s += 1 print(i, s) if x 1: print(x, 1)for _ in range(n): x = int(input()) divid(x) print() 868. 筛质数 线性筛法–每个合数只能被自己的最小质因数删除O(n) n = int(input())state = [True] * (n + 1)res = []for i in range(2, n + 1): if state[i]: res.append(i) j = 0 while res[j] * i = n: state[res[j] * i] = False if i % res[j] == 0: break j += 1print(len(res)) 埃氏筛法O(n lognlogn) n = int(input())state = [True] * (n + 1)res = 0for i in range(2, n + 1): if state[i]: res += 1 for j in range(2 * i, n + 1, i): state[j] = Falseprint(res) 约数869. 试除法求约数 import mathn = int(input())def divisor(x): res = [] for i in range(1, int(math.sqrt(x) + 1)): if x % i == 0: res.append(i) if i * i != x: res.append(x // i) res.sort() print( .join(map(str, res)))for _ in range(n): a = int(input()) divisor(a) 870. 约数个数 $N p^{\\alpha1}{1} * p^{\\alpha2}{2} * \\cdots * p^{\\alpha k}_{k}$ 约数个数$res (a_{1} + 1) (a_{2} + 1) \\cdots (a_{k} + 1)$ import mathn = int(input())dict = def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for v in dict.values(): res = res * (v + 1) % (1e9 + 7)print(int(res)) 871. 约数之和 约数之和$res (p^{0}{1} + p^{1}{1} + \\cdots p^{a_{1}}{1}) * (p^{0}{2} + p^{1}{2} + \\cdots p^{a{2}}{2}) * \\cdots *(p^{0}{k} + p^{1}{k} + \\cdots p^{a{k}}_{k})$ import mathn = int(input())dict = MOD = int(1e9 + 7)def divisor(x): for i in range(2, int(math.sqrt(x) + 1)): while x % i == 0: x //= i dict[i] = dict.get(i, 0) + 1 if x 1: dict[x] = dict.get(x, 0) + 1for _ in range(n): x = int(input()) divisor(x)res = 1for p, a in dict.items(): t = 1 while a: t = (t * p + 1) % MOD a -= 1 res = res * t % MODprint(res) 872. 最大公约数 辗转相除法 n = int(input())def gcd(a, b): return gcd(b, a % b) if b else afor _ in range(n): a, b = map(int, input().split()) print(gcd(a, b)) python自带 import mathn = int(input())for _ in range(n): a, b = map(int, input().split()) print(math.gcd(a, b)) 欧拉函数873. 欧拉函数 $\\varphi(1) 1$ 当n不是质数：$\\varphi(n) n * \\sum^{x}{i1}(1 - \\frac{1}{p{k}})$ 当n是质数：$\\varphi(n) n - 1$ import mathn = int(input())def euler(x): res = x for i in range(2, int(math.sqrt(x) + 1)): if x % i == 0: res *= (1 - 1 / i) while x % i == 0: x //= i if x 1: res *= (1 - 1 / x) print(int(res))for _ in range(n): x = int(input()) euler(x) 874. 筛法求欧拉函数 n = int(input())state = [False] * (n + 1)phi = [0] * (n + 1)phi[1] = 1primes = []def euler(x): for i in range(2, n + 1): if not state[i]: primes.append(i) phi[i] = i - 1 j = 0 while primes[j] * i = n: state[primes[j] * i] = True if i % primes[j] == 0: phi[primes[j] * i] = phi[i] * primes[j] break phi[primes[j] * i] = phi[i] * (primes[j] - 1) j += 1 print(sum(phi))euler(n) 快速幂875. 快速幂 费马小定理$a^{p - 1} \\equiv 1 \\ (mod \\enspace p)$ n = int(input())for _ in range(n): a, k, p = map(int, input().split()) res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p print(res) 876. 快速幂求逆元 当n为质数时，b的乘法逆元$x b^{(n - 2)}$ 当n不是质数时，使用拓展欧几里得求逆元 $a * x \\equiv 1 \\ (mod \\ p)$ n = int(input())def quick_mi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resfor _ in range(n): a, p = map(int, input().split()) print(quick_mi(a, p - 2, p) if a % p else impossible) 扩展欧几里得算法877. 扩展欧几里得算法 求解$ax + by gcd(a, b)$ 当b0时 $ax+bya$ 故而 $x1, y0$ 当$b eq 0$时$x y \\prime, \\quad y x \\prime - \\lfloor\\frac{a}{b}\\rfloor * y \\prime$ n = int(input())def exgcd(a, b): if not b: return 1, 0 y, x = exgcd(b, a % b) y -= a // b * x return x, yfor _ in range(n): a, b = map(int, input().split()) print(*exgcd(a, b)) 878. 线性同余方程 当$gcd(a,m) \\mid b$有解，求出以一组解使得$a * x_{0} + m * y_{0} gcd(a,m)$， 所以$x x_{0} * \\frac{b}{gcd(a,m)} % m$ n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, yfor _ in range(n): a, b, m = map(int, input().split()) d, x, _ = exgcd(a, m) print(impossible if b % d else x * b // d % m) 中国剩余定理$Mm_{1} \\cdot m_{2} \\cdot \\cdots \\cdot m_{R}, \\quad M_{i} \\frac{M}{m_{i}}$, $M^{-1}{i}$表示$M_i$模$m{i}$的逆，即$M_i \\cdot m^{-1}{i} \\equiv 1 \\ (mod \\ m{i})$ $x a_1 \\cdot M_1 \\cdot M^{-1}{1} + a_2 \\cdot M_2 \\cdot M^{-1}{2} + \\cdots + a_k \\cdot M_k \\cdot M^{-1}_{k}$ 204. 表达整数的奇怪方式 注 $m_1,m_2 \\cdots m_k$ 不两两互质 n = int(input())def exgcd(a, b): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b) y -= a // b * x return d, x, ya1, m1 = map(int, input().split())for _ in range(n - 1): a2, m2 = map(int, input().split()) d, k1, _ = exgcd(a1, a2) if (m2 - m1) % d: print(-1) break k1 *= (m2 - m1) // d k1 %= a2 // d m1 += a1 * k1 a1 = a1 * a2 // delse: print(m1 % a1) 高斯消元883. 高斯消元解线性方程组 n = int(input())g = [list(map(float, input().split())) for _ in range(n)]def gauss(): idx, zero = 0, 1e-6 for c in range(n): t = max(range(c, n), key=lambda x: abs(g[x][c])) if abs(g[t][c]) zero: continue g[idx][c:], g[t][c:] = g[t][c:], g[idx][c:] for i in range(n, c, -1): g[idx][i] /= g[idx][c] for i in range(idx + 1, n): if abs(g[i][c]) zero: for j in range(n, c - 1, -1): g[i][j] -= g[idx][j] * g[i][c] idx += 1 if idx n: for i in range(idx, n): if abs(g[i][n]) zero: print(No solution) return print(Infinite group solutions) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] -= g[i][j] * g[j][n] for i in range(n): print(fg[i][n]:.2f)gauss() 884. 高斯消元解异或线性方程组 n = int(input())g = [list(map(int, input().split())) for _ in range(n)]def gauss(): idx = 0 for c in range(n): t = idx for i in range(idx, n): if g[i][c]: t = i break if not g[t][c]: continue g[t][c:], g[idx][c:] = g[idx][c:], g[t][c:] for i in range(idx + 1, n): if g[i][c]: for j in range(c, n + 1): g[i][j] ^= g[idx][j] idx += 1 if idx n: for i in range(idx, n): if g[i][n]: print(No solution) return print(Multiple sets of solutions) return for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][n] ^= g[i][j] g[j][n] for i in range(n): print(g[i][n])gauss() 求组合数885. 求组合数 I $C^{b}{a} C^{b - 1}{a - 1} + C^{b}_{a - 1}$ n = int(input())N, MOD = 2010, int(1e9+7)g = [[1] + [0] * N for _ in range(N)]for i in range(N): for j in range(i + 1): g[i][j] = (g[i - 1][j] + g[i - 1][j - 1]) % MODfor _ in range(n): a, b = map(int, input().split()) print(g[a][b]) 886. 求组合数 II 注 $\\frac{a}{b} \\enspace mod \\enspace p eq \\frac{a \\enspace mod \\enspace p}{b \\enspace mod \\enspace p}$ 可以用逆元计算 $\\frac{a}{b} \\enspace mod \\enspace p a \\times b^{-1} \\enspace mod \\enspace p$ $C^{b}_{a} \\frac{a!}{b! * (a - b)!} a! * infact(b!) * infact((a - b)!)$ n = int(input())N, MOD = 100010, int(1e9 + 7)fact, infact = [1] * N, [1] * Ndef qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resfor i in range(1, N): fact[i] = fact[i - 1] * i % MOD infact[i] = infact[i - 1] * qmi(i, MOD - 2, MOD) % MODfor _ in range(n): a, b = map(int, input().split()) print(fact[a] * infact[b] * infact[a - b] % MOD) 887. 求组合数 III 卢卡斯定理 Lucas $O(logpNplogp)$ $C^{b}{a} \\equiv C^{\\frac{b}{p}}{\\frac{a}{p}} C^{b \\ mod \\ p}_{a \\ mod \\ p} \\ (mod \\ p)$ n = int(input())def qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resdef C(a, b): res = 1 i, j = 1, a while i = b: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1 return resdef lucas(a, b, p): if a p and b p: return C(a, b) else: return C(a % p, b % p) * lucas(a // p, b // p, p) % pfor _ in range(n): a, b, p = map(int, input().split()) print(lucas(a, b, p)) 888. 求组合数 IV import matha, b = map(int, input().split())print(math.factorial(a) // math.factorial(b) // math.factorial(a - b)) 889. 满足条件的01序列 卡特兰数 $ans C^{n}{2n} - C^{n - 1}{2n} \\frac{C^{n}_{2n}}{n + 1}$ n = int(input())p = int(1e9 + 7)def qmi(a, k, p): res = 1 while k: if k 1: res = res * a % p k = 1 a = a * a % p return resres = 1i, j = 1, 2 * nwhile i = n: res = res * j % p res = res * qmi(i, p - 2, p) % p i += 1 j -= 1print(res * qmi(n + 1, p - 2, p) % p) 使用公式+python硬解(很慢） import mathn = int(input())print(math.factorial(2 * n) // (math.factorial(n) ** 2 * (n + 1)) % int(1e9 + 7)) 容斥原理$$\\bigcup_{i1}^{m} S_{i}S_{1}+S_{2}+\\cdots+S_{m}-(S_{1} \\bigcap S_{2}+S_{1} \\bigcap S_{3}+\\ldots+S_{m-1} \\bigcap S_{m})+(S_{1} \\bigcap S_{2} \\bigcap S_{3}+\\ldots+S_{m-2} \\bigcap S_{m-1} \\bigcap S_{m})+\\ldots+(-1)^{m-1}(\\bigcap_{i1}^{m} S)$$ 890. 能被整除的数 n, m = map(int, input().split())p = list(map(int, input().split()))res = 0for i in range(1, 1 m): t, s = 1, 0 for j in range(m): if i j 1: if t * p[j] n: break t *= p[j] s += 1 else: if s 1: res += n // t else: res -= n // tprint(res) 博弈论891. Nim游戏 mex(S)为求出不属于集合S的最小非负整数 n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(1, n): res ^= nums[i]print(Yes if res else No) 892. 台阶-Nim游戏 n = int(input())nums = list(map(int, input().split()))res = nums[0]for i in range(2, n, 2): res ^= nums[i]print(Yes if res else No) 893. 集合-Nim游戏 $SG(x)mex({SG(y_{1}),SG(y_{2})····SG(y_{k})})$ $SG(G)SG(G_{1})\\oplus SG(G_{2}) \\oplus \\cdots \\oplus SG(G_{m})$ k = int(input())s = list(map(int, input().split()))n = int(input())nums = list(map(int, input().split()))f = [-1] * 10010def sg(x): if f[x] != -1: return f[x] S = sg(x - i) for i in s if x = i i = 0 while i in S: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(Yes if nim(n, nums) else No) 894. 拆分-Nim游戏 n = int(input())nums = list(map(int, input().split()))f = [-1] * 101def sg(x): if f[x] != -1: return f[x] s = set() for i in range(x): for j in range(i + 1): s.add(sg(i) ^ sg(j)) i = 0 while i in s: i += 1 f[x] = i return f[x]def nim(n, nums): res = 0 for num in nums: res ^= sg(num) return resprint(Yes if nim(n, nums) else No) 动态规划背包问题2. 01背包问题 二维dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j = v[i]: f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])print(f[n][m]) 一维dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 3. 完全背包问题 二维dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] if j = v[i]: f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])print(f[n][m]) 一维dp n, m = map(int, input().split())v, w = [0] * (n + 1), [0] * (n + 1)f = [0] * (m + 1)for i in range(1, n + 1): a, b = map(int, input().split()) v[i] = a w[i] = bfor i in range(1, n + 1): for j in range(1, m + 1): if j = v[i]: f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 4. 多重背包问题 I n, m = map(int, input().split())v, w, s = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): a, b, c = map(int, input().split()) v[i] = a w[i] = b s[i] = cfor i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = f[i - 1][j] k = 0 while k = s[i] and j = k * v[i]: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) k += 1print(f[n][m]) 5. 多重背包问题 II n, m = map(int, input().split())N = 20010v, w, f = [0] * (N + 1), [0] * (N + 1), [0] * (N + 1)idx = 1for _ in range(n): a, b, c = map(int, input().split()) k = 1 while k c: v[idx] = a * k w[idx] = b * k c -= k k *= 2 idx += 1 if c: v[idx] = a * c w[idx] = b * c idx += 1for i in range(1, idx): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i])print(f[m]) 9. 分组背包问题 n, m = map(int, input().split())N = 101v = [[0] * N for _ in range(N)]w = [[0] * N for _ in range(N)]s, f = [0] * N, [0] * Nfor i in range(1, n + 1): s[i] = int(input()) for j in range(1, s[i] + 1): v[i][j], w[i][j] = map(int, input().split())for i in range(1, n + 1): for j in range(m, 0, -1): for k in range(1, s[i] + 1): if j = v[i][k]: f[j] = max(f[j], f[j - v[i][k]] + w[i][k])print(f[m]) 线性DP898. 数字三角形 n = int(input())INF = -1e9a = [[INF] * (n + 1) for _ in range(n + 1)]f = [[INF] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): a[i] = [INF] + list(map(int, input().split()))f[1][1] = a[1][1]for i in range(2, n + 1): for j in range(1, i + 1): f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]print(max(f[n])) 895. 最长上升子序列 n = int(input())a = [0] + list(map(int, input().split()))f = [1] * (n + 1)for i in range(1, n + 1): for j in range(1, i): if a[i] a[j]: f[i] = max(f[i], f[j] + 1)print(max(f)) 897. 最长公共子序列 n, m = map(int, input().split())a, b = + input(), + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = max(f[i - 1][j], f[i][j - 1]) if a[i] == b[j]: f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1)print(f[n][m]) 902. 最短编辑距离 n = int(input())a = + input()m = int(input())b = + input()f = [[0] * (m + 1) for _ in range(n + 1)]for i in range(1, n + 1): f[i][0] = ifor i in range(1, m + 1): f[0][i] = ifor i in range(1, n + 1): for j in range(1, m + 1): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1print(f[n][m]) 899. 编辑距离 n, m = map(int, input().split())N = 11a = [[0] * N for _ in range(n + 1)]f = [[0] * N for _ in range(N)]for i in range(n): a[i] = + input()def distance(a, b): la, lb = len(a), len(b) for i in range(1, la): f[i][0] = i for i in range(1, lb): f[0][i] = i for i in range(1, la): for j in range(1, lb): if a[i] == b[j]: f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1]) else: f[i][j] = min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1 return f[la - 1][lb - 1]for _ in range(m): b, limit = input().split() b, limit = + b, int(limit) res = 0 for i in range(n): if distance(a[i], b) = limit: res += 1 print(res) 896. 最长上升子序列 II n = int(input())a = list(map(int, input().split()))q = [0] * (n + 1)res = 0for i in range(n): l, r = 0, res while l r: mid = l + r + 1 1 if q[mid] a[i]: l = mid else: r = mid - 1 q[r + 1] = a[i] res = max(res, r + 1)print(res) 区间DP282. 石子合并 n = int(input())s = [0] + list(map(int, input().split()))f = [[0] * (n + 1) for _ in range(n + 1)]for i in range(1, n + 1): s[i] += s[i - 1]for length in range(2, n + 1): for i in range(1, n - length + 2): l, r = i, i + length - 1 f[l][r] = float(inf) for k in range(l, r): f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1])print(f[1][n]) 计数类DP900. 整数划分 n = int(input())MOD = int(1e9 + 7)f = [0] * (n + 1)f[0] = 1for i in range(1, n + 1): for j in range(i, n + 1): f[j] = (f[j] + f[j - i]) % MODprint(f[n]) 数位统计DP338. 计数问题 def power10(x): res = 1 while x: res *= 10 x -= 1 return resdef count(n, x): res = cnt = 0 m = n while m: cnt += 1 m //= 10 for i in range(1, cnt + 1): r = power10(i - 1) l = n // (r * 10) if x: res += l * r else: res += (l - 1) * r d = n // r % 10 if d == x: res += n % r + 1 elif d x: res += r return reswhile True: a, b = map(int, input().split()) if not a and not b: break if a b: a, b = b, a for i in range(10): print(count(b, i) - count(a - 1, i), end= ) print() 状态压缩DP291. 蒙德里安的梦想 def fun(n, m): f = [[0] * (1 12) for _ in range(12)] st = [False] * (1 12) for i in range(1 n): cnt = 0 st[i] = True for j in range(n): if i j 1: if cnt 1: st[i] = False cnt = 0 else: cnt += 1 if cnt 1: st[i] = False f[0][0] = 1 for i in range(1, m + 1): for j in range(1 n): for k in range(1 n): if not (j k) and st[j | k]: f[i][j] += f[i - 1][k] return f[m][0]while True: a, b = map(int, input().split()) if not a and not b: break print(fun(a, b)) 91. 最短Hamilton路径 n = int(input())g = [list(map(int, input().split())) for _ in range(n)]f = [[float(inf)] * n for _ in range(1 n)]f[1][0] = 0for i in range(1 n): for j in range(n): if i j 1: for k in range(n): if i k 1: f[i][j] = min(f[i][j], f[i - (1 j)][k] + g[k][j])print(f[i - (1 n)][n - 1]) 树形DP285. 没有上司的舞会 import syssys.setrecursionlimit(3000)n = int(input())f = [[0] * 2 for _ in range(n + 1)]parent = [False] * (n + 1)happy = [0] * (n + 1)adj_list = [[] for _ in range(n + 1)]for i in range(1, n + 1): happy[i] = int(input())for _ in range(n - 1): a, b = map(int, input().split()) parent[a] = True adj_list[b].append(a)root = 1while parent[root]: root += 1def dfs(u): f[u][1] = happy[u] for j in adj_list[u]: dfs(j) f[u][0] += max(f[j][1], f[j][0]) f[u][1] += f[j][0]dfs(root)print(max(f[root][0], f[root][1])) 记忆化搜索901. 滑雪 n, m = map(int, input().split())f = [[0] * m for _ in range(n)]g = [list(map(int, input().split())) for _ in range(n)]dircts = [(0, 1), (1, 0), (0, -1), (-1, 0)]def dp(x, y): if f[x][y]: return f[x][y] f[x][y] = 1 for l, r in dircts: a, b = x + l, b + r if 0 = a n and 0 = b m and g[a][b] g[x][y]: f[x][y] = max(f[x][y], dp(a, b) + 1) return f[x][y]res = 0for i in range(n): for j in range(m): res = max(res, dp(i, j))print(res) 贪心区间问题905. 区间选点 n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x:x[1])res, end = 0, float(-inf)for a, b in g: if a end: res += 1 end = bprint(res) 908. 最大不相交区间数量 n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[1])res, end = 0, float(-inf)for a, b in g: if a end: res += 1 end = bprint(res) 906. 区间分组 import heapqn = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()res = []for a, b in g: if res and a res[0]: heapq.heappop(res) heapq.heappush(res, b)print(len(res)) 907. 区间覆盖 s, t = map(int, input().split())n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort()idx = res = 0flag = Falsewhile idx n: r = float(-inf) while idx n and g[idx][0] = s: r = max(r, g[idx][1]) idx += 1 if r s: break s = r res += 1 if r = t: flag = True breakprint(res if flag else -1) Huffman树148. 合并果子 import heapqn = int(input())nums = list(map(int, input().split()))heapq.heapify(nums)res = 0while len(nums) 1: a, b = heapq.heappop(nums), heapq.heappop(nums) res += a + b heapq.heappush(nums, a + b)print(res) 排序不等式913. 排队打水 n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for i, num in enumerate(nums): res += num * (n - i - 1)print(res) 绝对值不等式104. 货仓选址 n = int(input())nums = list(map(int, input().split()))nums.sort()res = 0for num in nums: res += abs(num - nums[n // 2])print(res) 推公式125. 耍杂技的牛 n = int(input())g = [list(map(int, input().split())) for _ in range(n)]g.sort(lambda x: x[0] + x[1])res, pre_sum = float(-inf), 0for w, s in g: res = max(res, pre_sum - s) pre_sum += wprint(res) Python注意容易爆栈import sys sys.setrecursionlimit(100000) ​ python语言并不适合递归算法，因为其递归深度，语言自身就有限制，就算去除限制，其也会开辟大量空间 交换str两个字符的位置def swap(s, idx1, idx2): l, r = (idx1, idx2) if idx1 idx2 else (idx2, idx1) return s[:l] + s[r] + s[l + 1: r] + s[l] + s[r + 1:] 增强函数记忆力import functools#lru_cache，可以为函数自动增加记忆化的能力，在递归算法中非常实用@functools.lru_cache() 科学计数法要用int# 默认的科学计数法是小数表示MOD = int(1e9 + 7) 取模%运算c++中 cout 7 % 4 endl; // 3cout -7 % 4 endl; // -3cout 7 % -4 endl; // 3cout -7 % -4 endl; // -3 python中 print(7 % 4) // 3print(-7 % 4) // 1print(7 % -4) // -1print(-7 % -4) // -3 C 语言和 Python 在涉及有负数取余运算时，结果可能不同的本质原因是：C 语言中是向0取整，而 Python 是向负无穷取整。 输入from sys import stdininput = lambda: stdin.readline().strip()n, m = map(int, input().split()) 常用函数import mathmath.factorial(x)math.gcd(a, b) 二分二分找左边界l=mid+1,找右边界r=mid-1，并且mid=l+r+11","tags":["算法","Python","AcWing"],"categories":["算法"]},{"title":"Python入门","path":"/2024/01/01/python入门/","content":"出处 类型和运算#-- 寻求帮助: dir(obj) # 简单的列出对象obj所包含的方法名称，返回一个字符串列表 help(obj.func) # 查询obj.func的具体介绍和用法 #-- 测试类型的三种方法，推荐第三种 if type(L) == type([]): print(L is list) if type(L) == list: print(L is list) if isinstance(L, list): print(L is list) #-- Python数据类型：哈希类型、不可哈希类型 # 哈希类型，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看其hash值，也可以作为字典的key 数字类型：int, float, decimal.Decimal, fractions.Fraction, complex 字符串类型：str, bytes 元组：tuple 冻结集合：frozenset 布尔类型：True, False None # 不可hash类型：原地可变类型：list、dict和set。它们不可以作为字典的key。#-- 数字常量 1234, -1234, 0, 999999999 # 整数 1.23, 1., 3.14e-10, 4E210, 4.0e+210 # 浮点数 0o177, 0x9ff, 0X9FF, 0b101010 # 八进制、十六进制、二进制数字 3+4j, 3.0+4.0j, 3J # 复数常量，也可以用complex(real, image)来创建 hex(I), oct(I), bin(I) # 将十进制数转化为十六进制、八进制、二进制表示的“字符串” int(string, base) # 将字符串转化为整数，base为进制数 # 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数 float(inf), float(-inf), float(nan) # 无穷大, 无穷小, 非数 #-- 数字的表达式操作符 yield x # 生成器函数发送协议 lambda args: expression # 生成匿名函数 x if y else z # 三元选择表达式 x and y, x or y, not x # 逻辑与、逻辑或、逻辑非 x in y, x not in y # 成员对象测试 x is y, x is not y # 对象实体测试 xy, x=y, xy, x=y, x==y, x!=y # 大小比较，集合子集或超集值相等性操作符 1 a 3 # Python中允许连续比较 x|y, xy, x^y # 位或、位与、位异或 xy, xy # 位操作：x左移、右移y位 +, -, *, /, //, %, ** # 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算 -x, +x, ~x # 一元减法、识别、按位求补（取反） x[i], x[i:j:k] # 索引、分片 int(3.14), float(3) # 强制类型转换 #-- 整数可以利用bit_length函数测试所占的位数 a = 1; a.bit_length() # 1 a = 1024; a.bit_length() # 11 #-- repr和str显示格式的区别 repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。 str格式：打印语句，转化成一种对用户更加友好的格式。 #-- 数字相关的模块 # math模块 # Decimal模块：小数模块 import decimal from decimal import Decimal Decimal(0.01) + Decimal(0.02) # 返回Decimal(0.03) decimal.getcontext().prec = 4 # 设置全局精度为4 即小数点后边4位 # Fraction模块：分数模块 from fractions import Fraction x = Fraction(4, 6) # 分数类型 4/6 x = Fraction(0.25) # 分数类型 1/4 接收字符串类型的参数#-- 集合set set是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。 set支持union(联合), intersection(交), difference(差)和symmetric difference(对称差集)等数学运算。 set支持x in set, len(set), for x in set。 set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作 s = set([3,5,9,10]) # 创建一个数值集合，返回3, 5, 9, 10 t = set(Hello) # 创建一个字符的集合，返回l, H, e, o a = t | s; t.union(s) # t 和 s的并集 b = t s; t.intersection(s) # t 和 s的交集 c = t – s; t.difference(s) # 求差集（项在t中, 但不在s中） d = t ^ s; t.symmetric_difference(s) # 对称差集（项在t或s中, 但不会同时出现在二者中） t.add(x); t.remove(H) # 增加/删除一个item s.update([10,37,42]) # 利用[......]更新s集合 x in s, x not in s # 集合中是否存在某个值 s.issubset(t); s = t # 测试是否 s 中的每一个元素都在 t 中 s.issuperset(t); s = t # 测试是否 t 中的每一个元素都在 s 中 s.copy(); s.discard(x); # 删除s中x s.clear() # 清空s x**2 for x in [1, 2, 3, 4] # 集合解析，结果：16, 1, 4, 9 x for x in spam # 集合解析，结果：a, p, s, m #-- 集合frozenset，不可变对象 set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的) frozenset是不可变对象，即存在hash值，可作为字典的键值 frozenset对象没有add、remove等方法，但有union/intersection/difference等方法 a = set([1, 2, 3]) b = set() b.add(a) # error: set是不可哈希类型 b.add(frozenset(a)) # ok，将set变为frozenset，可哈希#-- 布尔类型bool type(True) # 返回class bool isinstance(False, int) # bool类型属于整型，所以返回True True == 1; True is 1 # 输出(True, False) #-- 动态类型简介 变量名通过引用，指向对象。 Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如类型标示符 引用计数器等 #共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！ #共享引用和相等测试： L = [1], M = [1], L is M # 返回False L = M = [1, 2, 3], L is M # 返回True，共享引用 #增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改 L = M = [1, 2] L = L + [3, 4] # L = [1, 2, 3, 4], M = [1, 2] L += [3, 4] # L = [1, 2, 3, 4], M = [1, 2, 3, 4]#-- 常见字符串常量和表达式 S = # 空字符串 S = spam’s # 双引号和单引号相同 S = s p\\ta\\x00m # 转义字符 S = spam # 三重引号字符串，一般用于函数说明 S = r\\temp # Raw字符串，不会进行转义，抑制转义 S = bSpam # Python3中的字节字符串 S = uspam # Python2.6中的Unicode字符串 s1+s2, s1*3, s[i], s[i:j], len(s) # 字符串操作 a %s parrot % kind # 字符串格式化表达式 a 1 0 parrot.format(kind, red)# 字符串格式化方法 for x in s: print(x) # 字符串迭代，成员关系 [x*2 for x in s] # 字符串列表解析 ,.join([a, b, c]) # 字符串输出，结果：a,b,c #-- 内置str处理函数： str1 = stringobject str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title() # 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写 str1.ljust(width) # 获取固定长度，左对齐，右边不够用空格补齐 str1.rjust(width) # 获取固定长度，右对齐，左边不够用空格补齐 str1.center(width) # 获取固定长度，中间对齐，两边不够用空格补齐 str1.zfill(width) # 获取固定长度，右对齐，左边不足用0补齐 str1.find(t,start,end) # 查找字符串，可以指定起始及结束位置搜索 str1.rfind(t) # 从右边开始查找字符串 str1.count(t) # 查找字符串出现的次数 #上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1 str1.replace(old,new) # 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new str1.strip(); # 默认删除空白符 str1.strip(d); # 删除str1字符串中开头、结尾处，位于 d 删除序列的字符 str1.lstrip(); str1.lstrip(d); # 删除str1字符串中开头处，位于 d 删除序列的字符 str1.rstrip(); str1.rstrip(d) # 删除str1字符串中结尾处，位于 d 删除序列的字符 str1.startswith(start) # 是否以start开头 str1.endswith(end) # 是否以end结尾 str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper() # 判断字符串是否全为字符、数字、小写、大写#-- 三重引号编写多行字符串块，并且在代码折行处嵌入换行字符 mantra = hello world hello python hello my friend # mantra为hello world hello python hello my friend #-- 索引和分片： S[0], S[len(S)–1], S[-1] # 索引 S[1:3], S[1:], S[:-1], S[1:10:2] # 分片，第三个参数指定步长，如`S[1:10:2]`是从1位到10位没隔2位获取一个字符。#-- 字符串转换工具： int(42), str(42) # 返回(42, 42) float(4.13), str(4.13) # 返回(4.13, 4.13) ord(s), chr(115) # 返回(115, s) int(1001, 2) # 将字符串作为二进制数字，转化为数字，返回9 bin(13), oct(13), hex(13) # 将整数转化为二进制/八进制/十六进制字符串，返回(0b1101, 015, 0xd) #-- 另类字符串连接 name = wang hong # 单行，name = wanghong name = wang \\ hong # 多行，name = wanghong#-- Python中的字符串格式化实现1--字符串格式化表达式 基于C语言的print模型，并且在大多数的现有的语言中使用。 通用结构：%[(name)][flag][width].[precision]typecode this is %d %s bird % (1, dead) # 一般的格式化表达式 %s---%s---%s % (42, 3.14, [1, 2, 3]) # 字符串输出：42---3.14---[1, 2, 3] %d...%6d...%-6d...%06d % (1234, 1234, 1234, 1234) # 对齐方式及填充：1234... 1234...1234 ...001234 x = 1.23456789 %e | %f | %g % (x, x, x) # 对齐方式：1.234568e+00 | 1.234568 | 1.23457 %6.2f*%-6.2f*%06.2f*%+6.2f % (x, x, x, x) # 对齐方式： 1.23*1.23 *001.23* +1.23 %(name1)d---%(name2)s % name1:23, name2:value2 # 基于字典的格式化表达式 %(name)s is %(age)d % vars() # vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量 #-- Python中的字符串格式化实现2--字符串格式化调用方法 # 普通调用 0, 1 and 2.format(spam, ham, eggs) # 基于位置的调用 motto and pork.format(motto = spam, pork = ham) # 基于Key的调用 motto and 0.format(ham, motto = spam) # 混合调用 # 添加键 属性 偏移量 (import sys) my 1[spam] runs 0.platform.format(sys, spam:laptop) # 基于位置的键和属性 config[spam] sys.platform.format(sys = sys, config = spam:laptop) # 基于Key的键和属性 first = 0[0], second = 0[1].format([A, B, C]) # 基于位置的偏移量 # 具体格式化 0:e, 1:.3e, 2:g.format(3.14159, 3.14159, 3.14159) # 输出3.141590e+00, 3.142e+00, 3.14159 fieldname:format_spec.format(......) # 说明: fieldname是指定参数的一个数字或关键字, 后边可跟可选的.name或[index]成分引用 format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type] fill ::= any character #填充字符 align ::= | | = | ^ #对齐方式 sign ::= + | - | #符号说明 width ::= integer #字符串宽度 precision ::= integer #浮点数精度 type ::= b | c | d | e | E | f | F | g | G | n | o | s | x | X | % # 例子: =0:10 = 1:10.format(spam, 123.456) # 输出=spam = 123.456 =0:10=.format(test) # 输出= test= =0:10=.format(test) # 输出=test = =0:^10=.format(test) # 输出= test = 0:X, 1:o, 2:b.format(255, 255, 255) # 输出FF, 377, 11111111 My name is 0:1..format(Fred, 8) # 输出My name is Fred . 动态指定参数#-- 常用列表常量和操作 L = [[1, 2], string, ] # 嵌套列表 L = list(spam) # 列表初始化 L = list(range(0, 4)) # 列表初始化 list(map(ord, spam)) # 列表解析 len(L) # 求列表长度 L.count(value) # 求列表中某个值的个数 L.append(obj) # 向列表的尾部添加数据，比如append(2)，添加元素2 L.insert(index, obj) # 向列表的指定index位置添加数据，index及其之后的数据后移 L.extend(interable) # 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别 L.index(value, [start, [stop]]) # 返回列表中值value的第一个索引 L.pop([index]) # 删除并返回index处的元素，默认为删除并返回最后一个元素 L.remove(value) # 删除列表中的value值，只删除第一次出现的value的值 L.reverse() # 反转列表 L.sort(cmp=None, key=None, reverse=False) # 排序列表 a = [1, 2, 3], b = a[10:] # 注意，这里不会引发IndexError异常，只会返回一个空的列表[] a = [], a += [1] # 这里实在原有列表的基础上进行操作，即列表的id没有改变 a = [], a = a + [1] # 这里最后的a要构建一个新的列表，即a的id发生了变化 #-- 用切片来删除序列的某一段 a = [1, 2, 3, 4, 5, 6, 7] a[1:4] = [] # a = [1, 5, 6, 7] a = [0, 1, 2, 3, 4, 5, 6, 7] del a[::2] # 去除偶数项(偶数索引的)，a = [1, 3, 5, 7] #-- 常用字典常量和操作 D = D = spam:2, tol:ham:1 # 嵌套字典 D = dict.fromkeys([s, d], 8) # s: 8, d: 8 D = dict(name = tom, age = 12) # age: 12, name: tom D = dict([(name, tom), (age, 12)]) # age: 12, name: tom D = dict(zip([name, age], [tom, 12])) # age: 12, name: tom D.keys(); D.values(); D.items() # 字典键、值以及键值对 D.get(key, default) # get函数 D.update(D_other) # 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据 D.pop(key, [D]) # 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常 D.popitem() # pop字典中随机的一项（一个键值对） D.setdefault(k[, d]) # 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。 del D # 删除字典 del D[key] # 删除字典的某一项 if key in D: if key not in D: # 测试字典键是否存在 # 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象 # 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。 # 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象 D[(1,2,3)] = 2 # tuple作为字典的key#-- 字典解析 D = k:8 for k in [s, d] # s: 8, d: 8 D = k:v for (k, v) in zip([name, age], [tom, 12]) # age: 12, name: tom #-- 字典的特殊方法__missing__：当查找找不到key时，会执行该方法 class Dict(dict): def __missing__(self, key): self[key] = [] return self[key] dct = dict() dct[foo].append(1) # 这有点类似于collections.defalutdict dct[foo] # [1] #-- 元组和列表的唯一区别在于元组是不可变对象，列表是可变对象 a = [1, 2, 3] # a[1] = 0, OK a = (1, 2, 3) # a[1] = 0, Error a = ([1, 2],) # a[0][1] = 0, OK a = [(1, 2)] # a[0][1] = 0, Error #-- 元组的特殊语法: 逗号和圆括号 D = (12) # 此时D为一个整数 即D = 12 D = (12, ) # 此时D为一个元组 即D = (12, ) #-- 文件基本操作 output = open(rC:\\spam, w) # 打开输出文件，用于写 input = open(data, r) # 打开输入文件，用于读。打开的方式可以为w, r, a, wb, rb, ab等 fp.read([size]) # size为读取的长度，以byte为单位 fp.readline([size]) # 读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) # 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。 fp.readable() # 是否可读 fp.write(str) # 把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) # 把seq的内容全部写到文件中(多行一次性写入) fp.writeable() # 是否可写 fp.close() # 关闭文件。 fp.flush() # 把缓冲区的内容写入硬盘 fp.fileno() # 返回一个长整型的”文件标签“ fp.isatty() # 文件是否是一个终端设备文件（unix系统中的） fp.tell() # 返回文件操作标记的当前位置，以文件的开头为原点 fp.next() # 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) # 将文件打开操作标记移到offset的位置。whence为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。 fp.seekable() # 是否可以seek fp.truncate([size]) # 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。 for line in open(data): print(line) # 使用for语句，比较适用于打开比较大的文件 with open(data) as file: print(file.readline()) # 使用with语句，可以保证文件关闭 with open(data) as file: lines = file.readlines() # 一次读入文件所有行，并关闭文件 open(f.txt, encoding = latin-1) # Python3.x Unicode文本文件 open(f.bin, rb) # Python3.x 二进制bytes文件 # 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等 #-- 其他 # Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真 # 通常意义下的类型分类：1. 数字、序列、映射。 2. 可变类型和不可变类型语法和语句#-- 赋值语句的形式 spam = spam # 基本形式 spam, ham = spam, ham # 元组赋值形式 [spam, ham] = [s, h] # 列表赋值形式 a, b, c, d = abcd # 序列赋值形式 a, *b, c = spam # 序列解包形式（Python3.x中才有） spam = ham = no # 多目标赋值运算，涉及到共享引用 spam += 42 # 增强赋值，涉及到共享引用#-- 序列赋值 序列解包 [a, b, c] = (1, 2, 3) # a = 1, b = 2, c = 3 a, b, c, d = spam # a = s, b = p, c = a, d = m a, b, c = range(3) # a = 0, b = 1, c = 2 a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4] *a, b = [1, 2, 3, 4] # a = [1, 2, 3], b = 4 a, *b, c = [1, 2, 3, 4] # a = 1, b = [2, 3], c = 4 # 带有*时 会优先匹配*之外的变量 如 a, *b, c = [1, 2] # a = 1, c = 2, b = []#-- print函数原型 print(value, ..., sep= , end= , file=sys.stdout, flush=False) # 流的重定向 print(hello world) # 等于sys.stdout.write(hello world) temp = sys.stdout # 原有流的保存 sys.stdout = open(log.log, a) # 流的重定向 print(hello world) # 写入到文件log.log sys.stdout.close() sys.stdout = temp # 原有流的复原 #-- Python中and或or总是返回对象(左边的对象或右边的对象) 且具有短路求值的特性 1 or 2 or 3 # 返回 1 1 and 2 and 3 # 返回 3#-- if/else三元表达符（if语句在行内） A = 1 if X else 2 A = 1 if X else (2 if Y else 3) # 也可以使用and-or语句（一条语句实现多个if-else） a = 6 result = (a 20 and big than 20 or a 10 and big than 10 or a 5 and big than 5) # 返回big than 5#-- Python的while语句或者for语句可以带else语句 当然也可以带continue/break/pass语句 while a 1: anything else: anything # else语句会在循环结束后执行，除非在循环中执行了break，同样的还有for语句 for i in range(5): anything else: anything#-- for循环的元组赋值 for (a, b) in [(1, 2), (3, 4)]: # 最简单的赋值 for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: # 自动解包赋值 for ((a, b), c) in [((1, 2), 3), (XY, 6)]: # 自动解包 a = X, b = Y, c = 6 for (a, *b) in [(1, 2, 3), (4, 5, 6)]: # 自动解包赋值#-- 列表解析语法 M = [[1,2,3], [4,5,6], [7,8,9]] res = [sum(row) for row in M] # G = [6, 15, 24] 一般的列表解析 生成一个列表 res = [c * 2 for c in spam] # [ss, pp, aa, mm] res = [a * b for a in [1, 2] for b in [4, 5]] # 多解析过程 返回[4, 5, 8, 10] res = [a for a in [1, 2, 3] if a 2] # 带判断条件的解析过程 res = [a if a 0 else 0 for a in [-1, 0, 1]] # 带判断条件的高级解析过程 # 两个列表同时解析：使用zip函数 for teama, teamb in zip([Packers, 49ers], [Ravens, Patriots]): print(teama + vs. + teamb) # 带索引的列表解析：使用enumerate函数 for index, team in enumerate([Packers, 49ers, Ravens, Patriots]): print(index, team) # 输出0, Packers 1, 49ers ...... #-- 生成器表达式 G = (sum(row) for row in M) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 输出(6, 15, 24) G = sum(row) for row in M # G = 6, 15, 24 解析语法还可以生成集合和字典 G = i:sum(M[i]) for i in range(3) # G = 0: 6, 1: 15, 2: 24#-- 文档字符串:出现在Module的开端以及其中函数或类的开端 使用三重引号字符串 module document def func(): function document print() class Employee(object): class document print() print(func.__doc__) # 输出函数文档字符串 print(Employee.__doc__) # 输出类的文档字符串 #-- 命名惯例: 以单一下划线开头的变量名(_X)不会被from module import*等语句导入 前后有两个下划线的变量名(__X__)是系统定义的变量名，对解释器有特殊意义 以两个下划线开头但不以下划线结尾的变量名(__X)是类的本地(私有)变量 #-- 列表解析 in成员关系测试 map sorted zip enumerate内置函数等都使用了迭代协议 first line in open(test.txt) # in测试 返回True或False list(map(str.upper, open(t))) # map内置函数 sorted(iter([2, 5, 8, 3, 1])) # sorted内置函数 list(zip([1, 2], [3, 4])) # zip内置函数 [(1, 3), (2, 4)]#-- del语句: 手动删除某个变量 del X#-- 获取列表的子表的方法: x = [1,2,3,4,5,6] x[:3] # 前3个[1,2,3] x[1:5] # 中间4个[2,3,4,5] x[-3:] # 最后3个[4,5,6] x[::2] # 奇数项[1,3,5] x[1::2] # 偶数项[2,4,6] #-- 手动迭代：iter和next L = [1, 2] I = iter(L) # I为L的迭代器 I.next() # 返回1 I.next() # 返回2 I.next() # Error:StopIteration #-- Python中的可迭代对象 1.range迭代器 2.map、zip和filter迭代器 3.字典视图迭代器：D.keys()), D.items()等 4.文件类型 函数语法规则#-- 函数相关的语句和表达式 myfunc(spam) # 函数调用 def myfunc(): # 函数定义 return None # 函数返回值 global a # 全局变量 nonlocal x # 在函数或其他作用域中使用外层（非全局）变量 yield x # 生成器函数返回 lambda # 匿名函数 #-- Python函数变量名解析:LEGB原则，即: local(functin) -- encloseing function locals -- global(module) -- build-in(python) 说明:以下边的函数maker为例 则相对于action而言 X为Local N为Encloseing #-- 嵌套函数举例:工厂函数 def maker(N): def action(X): return X ** N return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X#-- 嵌套函数举例:lambda实例 def maker(N): action = (lambda X: X**N) return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X#-- nonlocal和global语句的区别 # nonlocal应用于一个嵌套的函数的作用域中的一个名称 例如: start = 100 def tester(start): def nested(label): nonlocal start # 指定start为tester函数内的local变量 而不是global变量start print(label, start) start += 3 return nested # global为全局的变量 即def之外的变量 def tester(start): def nested(label): global start # 指定start为global变量start print(label, start) start += 3 return nested #-- 函数参数，不可变参数通过“值”传递，可变参数通过“引用”传递 def f(a, b, c): print(a, b, c) f(1, 2, 3) # 参数位置匹配 f(1, c = 3, b = 2) # 参数关键字匹配 def f(a, b=1, c=2): print(a, b, c) f(1) # 默认参数匹配 f(1, 2) # 默认参数匹配 f(a = 1, c = 3) # 关键字参数和默认参数的混合 # Keyword-Only参数:出现在*args之后 必须用关键字进行匹配 def keyOnly(a, *b, c): print() # c就为keyword-only匹配 必须使用关键字c = value匹配 def keyOnly(a, *, b, c): ...... # b c为keyword-only匹配 必须使用关键字匹配 def keyOnly(a, *, b = 1): ...... # b有默认值 或者省略 或者使用关键字参数b = value#-- 可变参数匹配: * 和 ** def f(*args): print(args) # 在元组中收集不匹配的位置参数 f(1, 2, 3) # 输出(1, 2, 3) def f(**args): print(args) # 在字典中收集不匹配的关键字参数 f(a = 1, b = 2) # 输出a:1, b:2 def f(a, *b, **c): print(a, b, c) # 两者混合使用 f(1, 2, 3, x=4, y=5) # 输出1, (2, 3), x:4, y:5 #-- 函数调用时的参数解包: * 和 ** 分别解包元组和字典 func(1, *(2, 3)) == func(1, 2, 3) func(1, **c:3, b:2) == func(1, b = 2, c = 3) func(1, *(2, 3), **c:3, b:2) == func(1, 2, 3, b = 2, c = 3) #-- 函数属性:(自己定义的)函数可以添加属性 def func():..... func.count = 1 # 自定义函数添加属性 print.count = 1 # Error 内置函数不可以添加属性 #-- 函数注解: 编写在def头部行 主要用于说明参数范围、参数类型、返回值类型等 def func(a:spam, b:(1, 10), c:float) - int : print(a, b, c) func.__annotations__ # c:class float, b:(1, 10), a:spam, return:class int # 编写注解的同时 还是可以使用函数默认值 并且注解的位置位于=号的前边 def func(a:spam=a, b:(1, 10)=2, c:float=3) - int : print(a, b, c)#-- 匿名函数:lambda f = lambda x, y, z : x + y + z # 普通匿名函数，使用方法f(1, 2, 3) f = lambda x = 1, y = 1: x + y # 带默认参数的lambda函数 def action(x): # 嵌套lambda函数 return (lambda y : x + y) f = lambda: a if xxx() else b # 无参数的lambda函数，使用方法f()#-- lambda函数与map filter reduce函数的结合 list(map((lambda x: x + 1), [1, 2, 3])) # [2, 3, 4] list(filter((lambda x: x 0), range(-4, 5))) # [1, 2, 3, 4] functools.reduce((lambda x, y: x + y), [1, 2, 3]) # 6 functools.reduce((lambda x, y: x * y), [2, 3, 4]) # 24 #-- 生成器函数:yield VS return def gensquare(N): for i in range(N): yield i** 2 # 状态挂起 可以恢复到此时的状态 for i in gensquare(5): # 使用方法 print(i, end = ) # [0, 1, 4, 9, 16] x = gensquare(2) # x是一个生成对象 next(x) # 等同于x.__next__() 返回0 next(x) # 等同于x.__next__() 返回1 next(x) # 等同于x.__next__() 抛出异常StopIteration #-- 生成器表达式:小括号进行列表解析 G = (x ** 2 for x in range(3)) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 和上述中的生成器函数的返回值一致 #（1）生成器(生成器函数/生成器表达式)是单个迭代对象 G = (x ** 2 for x in range(4)) I1 = iter(G) # 这里实际上iter(G) = G next(I1) # 输出0 next(G) # 输出1 next(I1) # 输出4 #（2）生成器不保留迭代后的结果 gen = (i for i in range(4)) 2 in gen # 返回True 3 in gen # 返回True 1 in gen # 返回False，其实检测2的时候，1已经就不在生成器中了，即1已经被迭代过了，同理2、3也不在了#-- 本地变量是静态检测的 X = 22 # 全局变量X的声明和定义 def test(): print(X) # 如果没有下一语句 则该句合法 打印全局变量X X = 88 # 这一语句使得上一语句非法 因为它使得X变成了本地变量 上一句变成了打印一个未定义的本地变量(局部变量) if False: # 即使这样的语句 也会把print语句视为非法语句 因为: X = 88 # Python会无视if语句而仍然声明了局部变量X def test(): # 改进 global X # 声明变量X为全局变量 print(X) # 打印全局变量X X = 88 # 改变全局变量X #-- 函数的默认值是在函数定义的时候实例化的 而不是在调用的时候 例子: def foo(numbers=[]): # 这里的[]是可变的 numbers.append(9) print(numbers) foo() # first time, like before, [9] foo() # second time, not like before, [9, 9] foo() # third time, not like before too, [9, 9, 9] # 改进: def foo(numbers=None): if numbers is None: numbers = [] numbers.append(9) print(numbers) # 另外一个例子 参数的默认值为不可变的: def foo(count=0): # 这里的0是数字, 是不可变的 count += 1 print(count) foo() # 输出1 foo() # 还是输出1 foo(3) # 输出4 foo() # 还是输出1 函数例子 数学运算类 abs(x) # 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模 complex([real[, imag]]) # 创建一个复数 divmod(a, b) # 分别取商和余数，注意：整型、浮点型都可以 float([x]) # 将一个字符串或数转换为浮点数。如果无参数将返回0.0 int([x[, base]]) # 将一个字符串或浮点数转换为int类型，base表示进制 long([x[, base]]) # 将一个字符串或浮点数转换为long类型 pow(x, y) # 返回x的y次幂 range([start], stop[, step]) # 产生一个序列，默认从0开始 round(x[, n]) # 四舍五入 sum(iterable[, start]) # 对集合求和 oct(x) # 将一个数字转化为8进制字符串 hex(x) # 将一个数字转换为16进制字符串 chr(i) # 返回给定int类型对应的ASCII字符 unichr(i) # 返回给定int类型的unicode ord(c) # 返回ASCII字符对应的整数 bin(x) # 将整数x转换为二进制字符串 bool([x]) # 将x转换为Boolean类型 集合类操作 basestring() # str和unicode的超类，不能直接调用，可以用作isinstance判断 format(value [, format_spec]) # 格式化输出字符串，格式化的参数顺序从0开始，如“I am 0,I like 1” enumerate(sequence[, start=0]) # 返回一个可枚举的对象，注意它有第二个参数 iter(obj[, sentinel]) # 生成一个对象的迭代器，第二个参数表示分隔符 max(iterable[, args...][key]) # 返回集合中的最大值 min(iterable[, args...][key]) # 返回集合中的最小值 dict([arg]) # 创建数据字典 list([iterable]) # 将一个集合类转换为另外一个集合类 set() # set对象实例化 frozenset([iterable]) # 产生一个不可变的set tuple([iterable]) # 生成一个tuple类型 str([object]) # 转换为string类型 sorted(iterable[, cmp[, key[, reverse]]]) # 集合排序 L = [(b,2),(a,1),(c,3),(d,4)] sorted(L, key=lambda x: x[1], reverse=True) # 使用Key参数和reverse参数 sorted(L, key=lambda x: (x[0], x[1])) # 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1] 逻辑判断 all(iterable) # 集合中的元素都为真的时候为真，特别的，若为空串返回为True any(iterable) # 集合中的元素有一个为真的时候为真，特别的，若为空串返回为False cmp(x, y) # 如果x y ,返回负数；x == y, 返回0；x y,返回正数 IO操作 file(filename [, mode [, bufsize]]) # file类型的构造函数。 input([prompt]) # 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入，意思是自行判断类型 # 在 Built-in Functions 里有一句话是这样写的：Consider using the raw_input() function for general input from users. raw_input([prompt]) # 设置输入，输入都是作为字符串处理 open(name[, mode[, buffering]]) # 打开文件，与file有什么不同？推荐使用open 其他 callable(object) # 检查对象object是否可调用 classmethod(func) # 用来说明这个func是个类方法 staticmethod(func) # 用来说明这个func为静态方法 dir([object]) # 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 help(obj) # 返回obj的帮助信息 eval(expression) # 计算表达式expression的值，并返回 exec(str) # 将str作为Python语句执行 execfile(filename) # 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。 filter(function, iterable) # 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数 list(filter(bool, range(-3, 4)))# 返回[-3, -2, -1, 1, 2, 3], 没有0 hasattr(object, name) # 判断对象object是否包含名为name的特性 getattr(object, name [, defalut]) # 获取一个类的属性 setattr(object, name, value) # 设置属性值 delattr(object, name) # 删除object对象名为name的属性 globals() # 返回一个描述当前全局符号表的字典 hash(object) # 如果对象object为哈希表类型，返回对象object的哈希值 id(object) # 返回对象的唯一标识，一串数字 isinstance(object, classinfo) # 判断object是否是class的实例 isinstance(1, int) # 判断是不是int类型 isinstance(1, (int, float)) # isinstance的第二个参数接受一个元组类型 issubclass(class, classinfo) # 判断class是否为classinfo的子类 locals() # 返回当前的变量列表 map(function, iterable, ...) # 遍历每个元素，执行function操作 list(map(abs, range(-3, 4))) # 返回[3, 2, 1, 0, 1, 2, 3] next(iterator[, default]) # 类似于iterator.next() property([fget[, fset[, fdel[, doc]]]]) # 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter reduce(function, iterable[, initializer]) # 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推 def add(x,y):return x + y reduce(add, range(1, 11)) # 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55) reduce(add, range(1, 11), 20) # 返回75 reload(module) # 重新加载模块 repr(object) # 将一个对象变幻为可打印的格式 slice(start, stop[, step]) # 产生分片对象 type(object) # 返回该object的类型 vars([object]) # 返回对象的变量名、变量值的字典 a = Class(); # Class为一个空类 a.name = qi, a.age = 9 vars(a) # name:qi, age:9 zip([iterable, ...]) # 返回对应数组 list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)] a = [1, 2, 3], b = [a, b, c] z = zip(a, b) # 压缩：[(1, a), (2, b), (3, c)] zip(*z) # 解压缩：[(1, 2, 3), (a, b, c)] unicode(string, encoding, errors) # 将字符串string转化为unicode形式，string为encoded string。​ 模块Moudle#-- Python模块搜索路径: (1)程序的主目录 (2)PYTHONPATH目录 (3)标准链接库目录 (4)任何.pth文件的内容 #-- 查看全部的模块搜索路径 import sys sys.path sys.argv # 获得脚本的参数 sys.builtin_module_names # 查找内建模块 sys.platform # 返回当前平台 出现如： win32 linux darwin等 sys.modules # 查找已导入的模块 sys.modules.keys() sys.stdout # stdout 和 stderr 都是类文件对象，但是它们都是只写的。它们都没有 read 方法，只有 write 方法 sys.stdout.write(hello) sys.stderr sys.stdin #-- 模块的使用代码 import module1, module2 # 导入module1 使用module1.printer() from module1 import printer # 导入module1中的printer变量 使用printer() from module1 import * # 导入module1中的全部变量 使用不必添加module1前缀#-- 重载模块reload: 这是一个内置函数 而不是一条语句 from imp import reload reload(module) #-- 模块的包导入:使用点号(.)而不是路径(dir1\\dir2)进行导入 import dir1.dir2.mod # d导入包(目录)dir1中的包dir2中的mod模块 此时dir1必须在Python可搜索路径中 from dir1.dir2.mod import * # from语法的包导入#-- __init__.py包文件:每个导入的包中都应该包含这么一个文件 该文件可以为空 首次进行包导入时 该文件会自动执行 高级功能:在该文件中使用__all__列表来定义包(目录)以from*的形式导入时 需要导入什么 #-- 包相对导入:使用点号(.) 只能使用from语句 from . import spam # 导入当前目录下的spam模块（Python2: 当前目录下的模块, 直接导入即可） from .spam import name # 导入当前目录下的spam模块的name属性（Python2: 当前目录下的模块, 直接导入即可，不用加.） from .. import spam # 导入当前目录的父目录下的spam模块 #-- 包相对导入与普通导入的区别 from string import * # 这里导入的string模块为sys.path路径上的 而不是本目录下的string模块(如果存在也不是) from .string import * # 这里导入的string模块为本目录下的(不存在则导入失败) 而不是sys.path路径上的 #-- 模块数据隐藏:最小化from*的破坏 _X # 变量名前加下划线可以防止from*导入时该变量名被复制出去 __all__ = [x, x1, x2] # 使用__all__列表指定from*时复制出去的变量名(变量名在列表中为字符串形式)#-- 可以使用__name__进行模块的单元测试:当模块为顶层执行文件时值为__main__ 当模块被导入时为模块名 if __name__ == __main__: doSomething # 模块属性中还有其他属性，例如： __doc__ # 模块的说明文档 __file__ # 模块文件的文件名，包括全路径 __name__ # 主文件或者被导入文件 __package__ # 模块所在的包 #-- import语句from语句的as扩展 import modulename as name from modulename import attrname as name #-- 得到模块属性的几种方法 假设为了得到name属性的值 M.name M.__dict__[name] sys.modules[M].name getattr(M, name) 类与面向对象#-- 最普通的类 class C1(C2, C3): spam = 42 # 数据属性 def __init__(self, name): # 函数属性:构造函数 self.name = name def __del__(self): # 函数属性:析构函数 print(goodbey , self.name) I1 = C1(bob) #-- Python的类没有基于参数的函数重载 class FirstClass(object): def test(self, string): print(string) def test(self): # 此时类中只有一个test函数 即后者test(self) 它覆盖掉前者带参数的test函数 print(hello world)#-- 子类扩展超类: 尽量调用超类的方法 class Manager(Person): def giveRaise(self, percent, bonus = .10): self.pay = int(self.pay*(1 + percent + bonus)) # 不好的方式 复制粘贴超类代码 Person.giveRaise(self, percent + bonus) # 好的方式 尽量调用超类方法#-- 类内省工具 bob = Person(bob) bob.__class__ # class Person bob.__class__.__name__ # Person bob.__dict__ # pay:0, name:bob, job:Manager #-- 返回1中 数据属性spam是属于类 而不是对象 I1 = C1(bob); I2 = C2(tom) # 此时I1和I2的spam都为42 但是都是返回的C1的spam属性 C1.spam = 24 # 此时I1和I2的spam都为24 I1.spam = 3 # 此时I1新增自有属性spam 值为3 I2和C1的spam还都为24 #-- 类方法调用的两种方式 instance.method(arg...) class.method(instance, arg...) #-- 抽象超类的实现方法 # (1)某个函数中调用未定义的函数 子类中定义该函数 def delegate(self): self.action() # 本类中不定义action函数 所以使用delegate函数时就会出错 # (2)定义action函数 但是返回异常 def action(self): raise NotImplementedError(action must be defined) # (3)上述的两种方法还都可以定义实例对象 实际上可以利用@装饰器语法生成不能定义的抽象超类 from abc import ABCMeta, abstractmethod class Super(metaclass = ABCMeta): @abstractmethod def action(self): pass x = Super() # 返回 TypeError: Cant instantiate abstract class Super with abstract methods action #-- # OOP和继承: is-a的关系 class A(B): pass a = A() isinstance(a, B) # 返回True, A是B的子类 a也是B的一种 # OOP和组合: has-a的关系 pass # OOP和委托: 包装对象 在Python中委托通常是以__getattr__钩子方法实现的, 这个方法会拦截对不存在属性的读取 # 包装类(或者称为代理类)可以使用__getattr__把任意读取转发给被包装的对象 class wrapper(object): def __init__(self, object): self.wrapped = object def __getattr(self, attrname): print(Trace: , attrname) return getattr(self.wrapped, attrname) # 注:这里使用getattr(X, N)内置函数以变量名字符串N从包装对象X中取出属性 类似于X.__dict__[N] x = wrapper([1, 2, 3]) x.append(4) # 返回 Trace: append [1, 2, 3, 4] x = wrapper(a:1, b:2) list(x.keys()) # 返回 Trace: keys [a, b]#-- 类的伪私有属性:使用__attr class C1(object): def __init__(self, name): self.__name = name # 此时类的__name属性为伪私有属性 原理 它会自动变成self._C1__name = name def __str__(self): return self.name = %s % self.__name I = C1(tom) print(I) # 返回 self.name = tom I.__name = jeey # 这里无法访问 __name为伪私有属性 I._C1__name = jeey # 这里可以修改成功 self.name = jeey #-- 类方法是对象:无绑定类方法对象 / 绑定实例方法对象 class Spam(object): def doit(self, message): print(message) def selfless(message) print(message) obj = Spam() x = obj.doit # 类的绑定方法对象 实例 + 函数 x(hello world) x = Spam.doit # 类的无绑定方法对象 类名 + 函数 x(obj, hello world) x = Spam.selfless # 类的无绑定方法函数 在3.0之前无效 x(hello world)#-- 获取对象信息: 属性和方法 a = MyObject() dir(a) # 使用dir函数 hasattr(a, x) # 测试是否有x属性或方法 即a.x是否已经存在 setattr(a, y, 19) # 设置属性或方法 等同于a.y = 19 getattr(a, z, 0) # 获取属性或方法 如果属性不存在 则返回默认值0 #这里有个小技巧，setattr可以设置一个不能访问到的属性，即只能用getattr获取 setattr(a, cant touch, 100) # 这里的属性名带有空格，不能直接访问 getattr(a, cant touch, 0) # 但是可以用getattr获取#-- 为类动态绑定属性或方法: MethodType方法 # 一般创建了一个class的实例后, 可以给该实例绑定任何属性和方法, 这就是动态语言的灵活性 class Student(object): pass s = Student() s.name = Michael # 动态给实例绑定一个属性 def set_age(self, age): # 定义一个函数作为实例方法 self.age = age from types import MethodType s.set_age = MethodType(set_age, s) # 给实例绑定一个方法 类的其他实例不受此影响 s.set_age(25) # 调用实例方法 Student.set_age = MethodType(set_age, Student) # 为类绑定一个方法 类的所有实例都拥有该方法类的高级话题 #-- 多重继承: 混合类, 搜索方式从下到上 从左到右 广度优先 class A(B, C): pass#-- 类的继承和子类的初始化 # 1.子类定义了__init__方法时，若未显示调用基类__init__方法，python不会帮你调用。 # 2.子类未定义__init__方法时，python会自动帮你调用首个基类的__init__方法，注意是首个。 # 3.子类显示调用基类的初始化函数： class FooParent(object): def __init__(self, a): self.parent = I\\m the Parent. print(Parent:a= + str(a)) def bar(self, message): print(message + from Parent) class FooChild(FooParent): def __init__(self, a): FooParent.__init__(self, a) print(Child:a= + str(a)) def bar(self, message): FooParent.bar(self, message) print(message + from Child) fooChild = FooChild(10) fooChild.bar(HelloWorld) #-- #实例方法 / 静态方法 / 类方法 class Methods(object): def imeth(self, x): print(self, x) # 实例方法：传入的是实例和数据，操作的是实例的属性 def smeth(x): print(x) # 静态方法：只传入数据 不传入实例，操作的是类的属性而不是实例的属性 def cmeth(cls, x): print(cls, x) # 类方法：传入的是类对象和数据 smeth = staticmethod(smeth) # 调用内置函数，也可以使用@staticmethod cmeth = classmethod(cmeth) # 调用内置函数，也可以使用@classmethod obj = Methods() obj.imeth(1) # 实例方法调用 __main__.Methods object... 1 Methods.imeth(obj, 2) # __main__.Methods object... 2 Methods.smeth(3) # 静态方法调用 3 obj.smeth(4) # 这里可以使用实例进行调用 Methods.cmeth(5) # 类方法调用 class __main__.Methods 5 obj.cmeth(6) # class __main__.Methods 6 #-- 函数装饰器:是它后边的函数的运行时的声明 由@符号以及后边紧跟的元函数(metafunction)组成 @staticmethod def smeth(x): print(x) # 等同于: def smeth(x): print(x) smeth = staticmethod(smeth) # 同理 @classmethod def cmeth(cls, x): print(x) # 等同于 def cmeth(cls, x): print(x) cmeth = classmethod(cmeth) #-- 类修饰器:是它后边的类的运行时的声明 由@符号以及后边紧跟的元函数(metafunction)组成 def decorator(aClass):..... @decorator class C(object):.... # 等同于: class C(object):.... C = decorator(C)#-- 限制class属性: __slots__属性 class Student(object): __slots__ = (name, age) # 限制Student及其实例只能拥有name和age属性 # __slots__属性只对当前类起作用, 对其子类不起作用 # __slots__属性能够节省内存 # __slots__属性可以为列表list，或者元组tuple #-- 类属性高级话题: @property # 假设定义了一个类:C，该类必须继承自object类，有一私有变量_x class C(object): def __init__(self): self.__x = None # 第一种使用属性的方法 def getx(self): return self.__x def setx(self, value): self.__x = value def delx(self): del self.__x x = property(getx, setx, delx, ) # property函数原型为property(fget=None,fset=None,fdel=None,doc=None) # 使用 c = C() c.x = 100 # 自动调用setx方法 y = c.x # 自动调用getx方法 del c.x # 自动调用delx方法 # 第二种方法使用属性的方法 @property def x(self): return self.__x @x.setter def x(self, value): self.__x = value @x.deleter def x(self): del self.__x # 使用 c = C() c.x = 100 # 自动调用setter方法 y = c.x # 自动调用x方法 del c.x # 自动调用deleter方法 #-- 定制类: 重写类的方法 # (1)__str__方法、__repr__方法: 定制类的输出字符串 # (2)__iter__方法、next方法: 定制类的可迭代性 class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def next(self): self.a, self.b = self.b, self.a + self.b if self.a 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 for n in Fib(): print(n) # 使用 # (3)__getitem__方法、__setitem__方法: 定制类的下标操作[] 或者切片操作slice class Indexer(object): def __init__(self): self.data = def __getitem__(self, n): # 定义getitem方法 print(getitem:, n) return self.data[n] def __setitem__(self, key, value): # 定义setitem方法 print(setitem:key = 0, value = 1.format(key, value)) self.data[key] = value test = Indexer() test[0] = 1; test[3] = 3 # 调用setitem方法 print(test[0]) # 调用getitem方法 # (4)__getattr__方法: 定制类的属性操作 class Student(object): def __getattr__(self, attr): # 定义当获取类的属性时的返回值 if attr==age: return 25 # 当获取age属性时返回25 raise AttributeError(object has no attribute: %s % attr) # 注意: 只有当属性不存在时 才会调用该方法 且该方法默认返回None 需要在函数最后引发异常 s = Student() s.age # s中age属性不存在 故调用__getattr__方法 返回25 # (5)__call__方法: 定制类的可调用性 class Student(object): def __call__(self): # 也可以带参数 print(Calling......) s = Student() s() # s变成了可调用的 也可以带参数 callable(s) # 测试s的可调用性 返回True # (6)__len__方法：求类的长度 def __len__(self): return len(self.data) #-- 动态创建类type() # 一般创建类 需要在代码中提前定义 class Hello(object): def hello(self, name=world): print(Hello, %s. % name) h = Hello() h.hello() # Hello, world type(Hello) # Hello是一个type类型 返回class type type(h) # h是一个Hello类型 返回class Hello # 动态类型语言中 类可以动态创建 type函数可用于创建新类型 def fn(self, name=world): # 先定义函数 print(Hello, %s. % name) Hello = type(Hello, (object,), dict(hello=fn)) # 创建Hello类 type原型: type(name, bases, dict) h = Hello() # 此时的h和上边的h一致异常相关 #-- #捕获异常: try: except: # 捕获所有的异常 等同于except Exception: except name: # 捕获指定的异常 except name, value: # 捕获指定的异常和额外的数据(实例) except (name1, name2): except (name1, name2), value: except name4 as X: else: # 如果没有发生异常 finally: # 总会执行的部分 # 引发异常: raise子句(raise IndexError) raise instance # raise instance of a class, raise IndexError() raise class # make and raise instance of a class, raise IndexError raise # reraise the most recent exception#-- Python3.x中的异常链: raise exception from otherException except Exception as X: raise IndexError(Bad) from X #-- assert子句: assert test, data assert x 0, x must be negative #-- with/as环境管理器:作为常见的try/finally用法模式的替代方案 with expression [as variable], expression [as variable]: # 例子: with open(test.txt) as myfile: for line in myfile: print(line) # 等同于: myfile = open(test.txt) try: for line in myfile: print(line) finally: myfile.close()#-- 用户自定义异常: class Bad(Exception):..... Exception超类 / except基类即可捕获到其所有子类 Exception超类有默认的打印消息和状态 当然也可以定制打印显示: class MyBad(Exception): def __str__(self): return 定制的打印消息 try: MyBad() except MyBad as x: print(x) #-- 用户定制异常数据 class FormatError(Exception): def __init__(self, line ,file): self.line = line self.file = file try: raise FormatError(42, test.py) except FormatError as X: print(Error at , X.file, X.line) # 用户定制异常行为(方法):以记录日志为例 class FormatError(Exception): logfile = formaterror.txt def __init__(self, line ,file): self.line = line self.file = file def logger(self): open(self.logfile, a).write(Error at , self.file, self.line) try: raise FormatError(42, test.py) except FormatError as X: X.logger()#-- 关于sys.exc_info:允许一个异常处理器获取对最近引发的异常的访问 try: ...... except: # 此时sys.exc_info()返回一个元组(type, value, traceback) # type:正在处理的异常的异常类型 # value:引发的异常的实例 # traceback:堆栈信息 #-- 异常层次 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- WarningUnicode和字节字符串#-- Python的字符串类型 Python2.x # 1.str表示8位文本和二进制数据 # 2.unicode表示宽字符Unicode文本 Python3.x # 1.str表示Unicode文本（8位或者更宽） # 2.bytes表示不可变的二进制数据 # 3.bytearray是一种可变的bytes类型#-- 字符编码方法 ASCII # 一个字节，只包含英文字符，0到127，共128个字符，利用函数可以进行字符和数字的相互转换 ord(a) # 字符a的ASCII码为97，所以这里返回97 chr(97) # 和上边的过程相反，返回字符a Latin-1 # 一个字节，包含特殊字符，0到255，共256个字符，相当于对ASCII码的扩展 chr(196) # 返回一个特殊字符：Ä Unicode # 宽字符，一个字符包含多个字节，一般用于亚洲的字符集，比如中文有好几万字 UTF-8 # 可变字节数，小于128的字符表示为单个字节，128到0X7FF之间的代码转换为两个字节，0X7FF以上的代码转换为3或4个字节 # 注意：可以看出来，ASCII码是Latin-1和UTF-8的一个子集 # 注意：utf-8是unicode的一种实现方式，unicode、gbk、gb2312是编码字符集 #-- 查看Python中的字符串编码名称，查看系统的编码 import encodings help(encoding) import sys sys.platform # win64 sys.getdefaultencoding() # utf-8 sys.getdefaultencoding() # 返回当前系统平台的编码类型 sys.getsizeof(object) # 返回object占有的bytes的大小 #-- 源文件字符集编码声明: 添加注释来指定想要的编码形式 从而改变默认值 注释必须出现在脚本的第一行或者第二行 说明：其实这里只会检查#和coding:utf-8，其余的字符都是为了美观加上的 # _*_ coding: utf-8 _*_ # coding = utf-8 #-- #编码: 字符串 -- 原始字节 #解码: 原始字节 -- 字符串#-- Python3.x中的字符串应用 s = ... # 构建一个str对象，不可变对象 b = b... # 构建一个bytes对象，不可变对象 s[0], b[0] # 返回(., 113) s[1:], b[1:] # 返回(.., b..) B = B xxxx yyyy # B = b xxxx yyyy # 编码，将str字符串转化为其raw bytes形式： str.encode(encoding = utf-8, errors = strict) bytes(str, encoding) # 编码例子： S = egg S.encode() # begg bytes(S, encoding = ascii) # begg # 解码，将raw bytes字符串转化为str形式： bytes.decode(encoding = utf-8, errors = strict) str(bytes_or_buffer[, encoding[, errors]]) # 解码例子： B = bspam B.decode() # spam str(B) # bspam，不带编码的str调用，结果为打印该bytes对象 str(B, encoding = ascii)# spam，带编码的str调用，结果为转化该bytes对象 #-- Python2.x的编码问题 u = u汉 print repr(u) # u\\xba\\xba s = u.encode(UTF-8) print repr(s) # \\xc2\\xba\\xc2\\xba u2 = s.decode(UTF-8) print repr(u2) # u\\xba\\xba # 对unicode进行解码是错误的 s2 = u.decode(UTF-8) # UnicodeEncodeError: ascii codec cant encode characters in position 0-1: ordinal not in range(128) # 同样，对str进行编码也是错误的 u2 = s.encode(UTF-8) # UnicodeDecodeError: ascii codec cant decode byte 0xc2 in position 0: ordinal not in range(128)#-- bytes对象 B = babc B = bytes(abc, ascii) B = bytes([97, 98, 99]) B = abc.encode() # bytes对象的方法调用基本和str类型一致 但:B[0]返回的是ASCII码值97, 而不是ba #-- #文本文件: 根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是指定的编码类型 # 二进制文件：表示字节值的整数的一个序列 open(bin.txt, rb) #-- Unicode文件 s = A\\xc4B\\xe8C # s = A?BèC len(s) = 5 #手动编码 l = s.encode(latin-1) # l = bA\\xc4B\\xe8C len(l) = 5 u = s.encode(utf-8) # u = bA\\xc3\\x84B\\xc3\\xa8C len(u) = 7 #文件输出编码 open(latindata, w, encoding = latin-1).write(s) l = open(latindata, rb).read() # l = bA\\xc4B\\xe8C len(l) = 5 open(uft8data, w, encoding = utf-8).write(s) u = open(uft8data, rb).read() # u = bA\\xc3\\x84B\\xc3\\xa8C len(u) = 7 #文件输入编码 s = open(latindata, r, encoding = latin-1).read() # s = A?BèC len(s) = 5 s = open(latindata, rb).read().decode(latin-1) # s = A?BèC len(s) = 5 s = open(utf8data, r, encoding = utf-8).read() # s = A?BèC len(s) = 5 s = open(utf8data, rb).read().decode(utf-8) # s = A?BèC len(s) = 5 其他#-- Python实现任意深度的赋值 例如a[0] = value1; a[1][2] = value2; a[3][4][5] = value3 class MyDict(dict): def __setitem__(self, key, value): # 该函数不做任何改动 这里只是为了输出 print(setitem:, key, value, self) super().__setitem__(key, value) def __getitem__(self, item): # 主要技巧在该函数 print(getitem:, item, self) # 输出信息 # 基本思路: a[1][2]赋值时 需要先取出a[1] 然后给a[1]的[2]赋值 if item not in self: # 如果a[1]不存在 则需要新建一个dict 并使得a[1] = dict temp = MyDict() # 新建的dict: temp super().__setitem__(item, temp) # 赋值a[1] = temp return temp # 返回temp 使得temp[2] = value有效 return super().__getitem__(item) # 如果a[1]存在 则直接返回a[1] # 例子: test = MyDict() test[0] = test print(test[0]) test[1][2] = test1 print(test[1][2]) test[1][3] = test2 print(test[1][3])#-- Python中的多维数组 lists = [0] * 3 # 扩展list，结果为[0, 0, 0] lists = [[]] * 3 # 多维数组，结果为[[], [], []]，但有问题，往下看 lists[0].append(3) # 期望看到的结果[[3], [], []]，实际结果[[3], [3], [3]]，原因：list*n操作，是浅拷贝，如何避免？往下看 lists = [[] for i in range(3)] # 多维数组，结果为[[], [], []] lists[0].append(3) # 结果为[[3], [], []] lists[1].append(6) # 结果为[[3], [6], []] lists[2].append(9) # 结果为[[3], [6], [9]] lists = [[[] for j in range(4)] for i in range(3)] # 3行4列，且每一个元素为[]","tags":["Python"],"categories":["Python"]},{"title":"Latex学习","path":"/2023/09/29/Latex学习/","content":"希腊字母 $$\\delta, \\lambda \\\\Delta, \\Lambda \\\\alpha, \\beta \\\\phi, \\varphi \\\\epsilon, \\varepsilon$$ 上下标 $$a^2, a_1 \\x^{y+z}, p_{ij}, p_{ij} \\x_i, x_{i} \\\\text{A B}, \\text{rm}$$ 分式与根式 $$\\frac{1}{2}, \\frac{1}{2} \\\\frac{1}{x+y} \\\\frac{\\frac{1}{x}+1}{y+1} \\\\sqrt{2}, \\sqrt{x+y}, \\sqrt[3]{x+y}$$ 普通运算符 $$+, - \\\\times, \\cdot, \\div \\\\pm, \\mp, , , \\geq, \\leq, \\gg, \\ll, eq, \\approx, \\equiv \\\\cap, \\cup, \\in, otin, \\subseteq, \\subsetneq, \\varnothing \\\\forall, \\exists, exists \\\\because, \\therefore \\\\mathbb{R}, \\mathbb{Q}, \\mathbb{N}, \\mathbb{Z}+ \\\\mathcal{F}, \\mathscr{F} \\\\cdots, \\vdots, \\ddots \\\\infty, \\partial, abla, \\propto, ^\\circ \\\\sin x, \\sec x, \\cosh x \\\\log_2 x, \\ln x, \\lg x \\\\lim\\limits{x \\to 0} \\frac{x}{\\sin x} \\\\max x$$ 大型运算符 $$\\sum,\\prod\\\\sum_i,\\sum_{i0}^N\\\\frac{\\sum\\limits_{i1}^n x_i}{\\prod\\limits_{i1}^n x_i}\\\\int,\\iint,\\iiint,\\oint\\int_{-\\infty}^0 f(x),\\text d x\\a,a\\a\\ a\\a\\quad a\\a\\qquad a\\$$ 标注符号 $$\\vec{x}, \\overrightarrow{AB} \\\\bar{x}, \\overline{AB}$$ 箭头 $$\\leftarrow,\\Rightarrow,\\Leftrightarrow,\\Longleftarrow$$ 括号与定界符 $${}\\\\lceil,\\rceil,\\lfloor,\\rfloor.||\\\\left(0,\\frac 1 a\\right]\\\\left.\\frac {\\partial f}{\\partial y}\\right|_{x0}$$ 多行公式 $$\\begin{align}ab+c+d\\e+f\\end{align}$$ 大括号$$f(x)\\begin{cases}\\sin x -\\pi\\le x \\le \\pi\\0, \\text{其他}\\end{cases}$$ 矩阵 $$\\begin{matrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{matrix}$$ $$\\begin{bmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{bmatrix}$$ $$\\begin{pmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{pmatrix}$$ $$\\begin{vmatrix}a b \\cdots c\\\\vdots \\vdots \\ddots \\vdots\\e f \\cdots g\\end{vmatrix}$$ $$\\bf A,\\bf B^{\\rm T}$$ 实战演练 $$f(x) \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\f(x) \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)$$ $$\\lim\\limits_{N \\to \\infty} P \\left{ \\left| \\frac{I\\left(\\alpha_i \\right)}{N} - H(s) \\right| \\varepsilon \\right} 1$$ $$x(n) \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X\\left(e^{j\\omega}\\right) e^{j\\omega n} , d\\omega$$ $$\\begin{align}\\vec{B} \\left(\\vec{r} \\right) \\frac{\\mu_0}{4\\pi} \\oint_C \\frac{I , {\\rm d}\\vec{l} \\times \\vec{R}}{R^3} \\ \\frac{\\mu_0}{4\\pi} \\int_V \\frac{\\vec{J}_V \\times \\vec{R}}{R^3} , {\\rm d}V’\\end{align}$$ mermaid 图形： graph LR A(开始) --> input[/输入a,b/] --> if{a%b=0 ?} if --->|yes| f1[GCD = b] --> B(结束) if --->|no| f2[\"a, b = b, a % b \"]-->if","tags":["Latex","学习"],"categories":["Latex"]},{"title":"labuladong算法小抄","path":"/2023/05/17/labuladong算法小抄/","content":"第零章 核心框架双指针-单链表 合并两个有序链表 LeetCode21 合并两个有序链表 链表的分解 LeetCode86 分割链表 合并k个有序链表 LeetCode23 合并k个升序链表 寻找单链表的倒数第k个节点 LeetCode19 删除链表倒数第N个节点 寻找单链表的中点 LeetCode976 链表的中间结点 判断单链表是否包含环并找出环起点 判断两个单链表是否相交并找出交点 LeetCode160 相交链表 双指针-数组快慢指针 原地修改数组 LeetCode26 删除有序数组中的重复项 对数组某些元素进行原地删除 LeetCode27 移除元素 LeetCode283 移动零 左右指针 二分查找 二分查找框架 两数之和 LeetCode167 两数之和2 反转数组 LeetCode344 反转字符串 回文串判断 LeetCode5 最长回文子串 二叉树(纲要篇)Tips:快速排序就是二叉树的前序遍历,归并排序是二叉树的后序遍历 快速排序框架: def sort(nums, lo, hi) # 前序遍历位置 # 通过交换元素构建分界点 p p = partition(nums, lo, hi) sort(nums, lo, p-1) sort(nums, p+1, hi) 归并排序框架: def sort(nums, lo, hi)\tint mid = (lo + hi) / 2\t# 排序nums[lo..mid]\tsort(nums, lo, mid)\t# 排序nums[mid+1..hi]\tsort(nums, mid+1, hi)\t# 合并nums[lo..mid] 和 nums[mid+1..hi]\tmerge(nums, lo, mid, hi) 二叉树遍历框架:def traverse(root)\tif not root: return\t# 前序位置\ttraverse(root.left)\t# 中序位置\ttraverse(root.right)\t# 后序位置 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据 两种解题思路: 遍历一遍二叉树得出答案 回溯算法框架 LeetCode104 二叉树的最大深度 分解问题计算出答案 动态规划核心框架 后序位置的特殊之处:​ LeetCode543 二叉树的直径 层序遍历:def levelTraverse(root)\tif not root: return\tque = deque()\tque.append(root) # 从上到下遍历二叉树的每一层\twhile que: # 从左到右遍历每一层的每个结点 for i in range(len(que)): cur = que.popleft() # 将下一层结点放入队列 if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) ​ BFS算法框架 动态规划(框架)动态规划框架:# 自顶向下递归的动态规划def dp(状态1, 状态2, ...):\tfor 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...))\treturn result# 自底向上迭代的动态规划# 初始化 base casedp[0][0][...] = base case# 进行状态转移for 状态1 in 状态1的所有取值: for 状态2 in 状态2的所有取值: for ... dp[状态1][状态2][...] = 求最值(选择1, 选择2...) 解题思路:暴力穷举,带备忘录的递归和dp数组的迭代(可降空间复杂度为O(1)) 斐波那契数列 LeetCode509 斐波那契数列 凑零钱 LeetCode322 零钱兑换 总结计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举， 穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。 列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。 备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？ 回溯算法(框架)Tips:回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 回溯算法框架res = []def backtrack(路径, 选择列表):\tif 满足结束条件: res.add(路径) return\tfor 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销xrz 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」 全排列问题 LeetCode46 全排列 全排列详解 N皇后问题 LeetCode51 N皇后 总结 时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。 回溯-排列,组合,子集无论是排列、组合还是子集问题，简单说无非就是让你从序列 nums 中以给定规则取若干元素，主要有以下几种变体： 元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。 ​ 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。 元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次。 ​ 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。 元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次。 ​ 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。 ​\t但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽。 ​\t回溯算法核心 子集(元素无重不可复选) LeetCode78 子集 组合(元素无重不可复选) LeetCode77 组合 排列(元素无重不可复选) LeetCode46 全排列 子集组合(元素可重不可复选) LeetCode 子集2 LeetCode 组合总和2 排列(元素可重不可复选) 全排列2 子集组合(元素无重可复选) LeetCode39 组合总和 排列(元素无重可复选) 总结 元素无重复不可复选 # 组合/子集问题回溯算法框架def backtrack(nums, start)\tfor i in range(start, len(nums)) # 做选择 tarck.addLast(nums[i]) # 注意参数 backtrack(nums, i+1) # 撤销选择 track.removeLast()\t# 排列问题回溯算法框架def backtrack(nums) for i in range(len(nums)) # 剪枝逻辑 if used[i]: continue # 做选择 used[i] = true track.addLast(nums[i]) backtrack(nums) # 撤销选择 track.removeLast() used[i] = false 元素可重不可复选 nums.sort()# 组合/子集问题回溯算法框架def backtrack(nums, start) # 回溯算法标准框架 for i in range(start, len(nums)) # 剪枝逻辑,跳过相同的相邻树枝 if istart and nums[i]==nums[i-1]: continue # 做选择 track.addLast(nums[i]) # 注意参数 backtrack(nums, i+1) # 撤销选择 track.removeLast() nums.sort()# 排列问题回溯算法框架def backtrack(nums) for i in range(len(nums)) # 剪枝逻辑 if used[i]:continue # 剪枝逻辑,固定相同的元素在排列中的相对位置 if i0 and nums[i]==nums[i-1] and not used[i-1]: continue # 做选择 used[i] = true track.addLast(nums[i]) backtrack(nums) #撤销选择 track.removeLast() used[i] = false 元素无重可复选 # 组合/子集问题回溯框架def backtrack(nums, start) # 回溯算法标准框架\tfor i in range(start, len(nums)) # 做选择 track.addLast(nums[i]) # 注意参数 backtrack(nums, i) # 撤销选择 track.removeLase()\t# 排列问题回溯算法框架def backtrack(nums)\tfor i in range(len(nums)) # 做选择 track.addLast(nums[i]) backtrack(nums) # 撤销选择 track.removeLast() BFS(框架) BFS框架: 层序遍历 二叉树的最小高度 LeetCode111 二叉树的最小高度 解开密码锁的最少次数 LeetCode752 打开转盘锁 双向BFS优化 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。 二分搜索 寻找一个数(基本的二分搜索) LeetCode704 二分查找 def binarySearch(nums, target)\tleft, right = 0, len(nums)-1\twhile(left=right): mid = left+(right-left)//2 if(nums[mid]==target): # 直接返回 return mid elif nums[mid]target: right = mid-1 elif nums[mid]target: left = mid+1 # 直接返回\treturn -1 寻找左侧边界的二分搜索 def left_bound(nums, target) left, right = 0, len(nums)-1 # 搜索区间为[left, right] while left=right: mid = left + (right-left)//2 if nums[mid]==target: # 收缩右侧边界 right = mid+1 elif nums[mid]target: # 搜索区间变为[mid+1, right] left = mid+1 elif nums[mid]target: # 搜索区间变为[left, mid-1] right = mid # 判断target是否存在于nums中 # 此时target比所有数都大,返回-1 if left==len(nums): return -1 # 判断一下nums[left]是不是target return nums[left]==target ? left : -1 寻找右侧边界的二分查找 def right_bound(nums, target) left, right = 0, len(nums)-1 while left=right: mid = left+(right-left)//2 if nums[mid]target: left=mid+1 elif nums[mid]target: right = mid-1 elif nums[mid]==target: # 收缩左边界 left = mid+1 # 最后改成返回left-1 if left-1 0: return -1 return nums[left-1]==target ? left-1 :-1 总结: ​\tLeetCode34 在排序数组中查找元素的第一个和最后一个位置 最基本的二分查找算法 因为我们初始化 right = nums.length - 1所以决定了我们的「搜索区间」是 [left, right]所以决定了 while (left = right)同时也决定了 left = mid+1 和 right = mid-1因为我们只需找到一个 target 的索引即可所以当 nums[mid] == target 时可以立即返回 寻找左侧边界的二分查找 因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最左侧索引所以当 nums[mid] == target 时不要立即返回而要收紧右侧边界以锁定左侧边界 寻找右侧边界的二分查找 因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最右侧索引所以当 nums[mid] == target 时不要立即返回而要收紧左侧边界以锁定右侧边界又因为收紧左侧边界时必须 left = mid + 1所以最后无论返回 left 还是 right，必须减一 滑动窗口 滑动窗口框架 left, right = 0,0while rightlen(s): # c是将移入窗口的字符 window.add(s[right]) # 增大窗口 right += 1 # 进行窗口内数据的一系列更新 ... # debug输出的位置 printf(Window:[%d, %d] , left, right) # 判断左侧窗口是否要收缩 while window needs shrink: # d是将移出窗口的字符 char d = s[left] # 缩小窗口 left+=1 # 进行窗口内数据的一系列更新 ... 最小覆盖子串 LeetCode76 最小覆盖子串 字符串排列 LeetCode567 字符串的排列 找所有字母异位词 LeetCode438 找到字符串中所有字母异位词 最长无重复子串 LeetCode3 无重复字符的最长子串 总结: 1. 什么时候应该扩大窗口? 1. 什么时候应该缩小窗口? 1. 什么时候应该更新答案? 买股票(DP) 状态转移方程 base case：dp[-1][...][0] = dp[...][0][0] = 0dp[-1][...][1] = dp[...][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) base case dp[-1][...][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。dp[-1][...][1] = -infinity解释：还没开始的时候，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。dp[...][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。dp[...][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 LeetCode121 买卖股票的最佳时机 LeetCode122 买卖股票的最佳时机2 LeetCode309 最佳买卖股票含冷冻期 LeetCode714 买卖股票的最佳时机含手续费 LeetCode123 买卖股票的最佳时机3 LeetCode188 买卖股票的最佳时机4 打家劫舍(DP) 打家劫舍1 LeetCode198 打家劫舍 # 带备忘录def rob(nums): n = len(nums) if n==0: return 0\tif n==1: return nums[0]\tdp = [0]*n dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[n-1]# 优化空间def rob(nums): prev, curr = 0, 0 for i in nums: prev, curr = curr, max(curr, prev+1) return curr 打家劫舍2 LeetCode213 打家劫舍2 打家劫舍3 LeetCode337 打家劫舍3 nSum 两数之和 LeetCode1 两数之和 3Sum LeetCode15 三数之和 4Sum LeetCode18 四数之和 第一章 数据结构链表1拉宾-卡普 数组二叉树图设计数据结构","tags":["算法","数据结构","LeetCode","Python"],"categories":["算法"]},{"title":"蓝桥杯备赛","path":"/2023/04/19/蓝桥杯备赛/","content":"蓝桥杯暴力dfsbfs回溯动态规划背包问题数论最大公约数def gcd(a, b): if b == 0: reutrn a a, b = b, a % b return gcd(a, b) 中国剩余定理def exgcd(a, b): if b == 0: return 1, 0 else: x, y = exgcd(b, a % b) return y, (x - a // b * y)def CRT(k, a, r): n = 1; ans = 0 for i in range(1, k + 1): n = n * r[i] for i in range(1, k + 1): m = n // r[i] b, y = exgcd(m, r[i]) # b * m mod r[i] = 1 while b 0: b += r[i] ans = (ans + a[i] * m * b) % n return (ans % n + n) % nr = [0, 3, 5, 7]a = [0, 2, 3, 2]print(CRT(3, a, r)) 筛法求素数def isPrime(n):\tprime = [True] * n for i in range(2, n + 1): if prime[i]: for i in range(i * 2, n + 1, i): prime[i] = False return [i for i in range(2, n) if prime[i]] 图论图论基础及遍历构建图(邻接表) def buildGraph(numCourses: int, prerequisites: List[List[int]]) - List[List[int]]: # 图中共有 numCourses 个节点 graph = [[] for _ in range(numCourses)] for edge in prerequisites: from_, to_ = edge[1], edge[0] # 添加一条从 from 指向 to 的有向边 # 如果是无向图，则再反向添加一次 graph[from_].append(to_) return graph 图的遍历 # 记录被遍历过的节点visited = []# 记录从起点到当前节点的路径onPath = []def traverse(graph, s): if visited[s]: return # 经过节点 s，标记为已遍历 visited[s] = True # 做选择：标记节点 s 在路径上 onPath[s] = True for neighbor in graph.neighbors(s): traverse(graph, neighbor) # 撤销选择：节点 s 离开路径 onPath[s] = False 环检测及拓扑排序环检测 def canFinish(self, numCourses: int, prerequisites: List[List[int]]) - bool: graph = self.buildGraph(numCourses, prerequisites) self.visited = [False] * numCourses self.onPath = [False] * numCourses self.hasCycle = False for i in range(numCourses): self.traverse(graph, i) return not self.hasCycledef traverse(self, graph, s): if self.onPath[s]: self.hasCycle = True if self.visited[s] or self.hasCycle: return self.visited[s] = True self.onPath[s] = True for t in graph[s]: self.traverse(graph, t) self.onPath[s] = Falsedef buildGraph(self, numCourses, prerequisites): # 代码见前文 拓扑排序 def findOrder(numCourses: int, prerequisites: List[List[int]]) - List[int]: # 记录后序遍历结果 postorder = [] # 记录是否存在环 hasCycle = False visited = [False] * numCourses onPath = [False] * numCourses # 建图函数 def buildGraph(numCourses, prerequisites): # 代码见前文 pass # 图遍历函数 def traverse(graph, s): if onPath[s]: # 发现环 hasCycle = True if visited[s] or hasCycle: return # 前序遍历位置 onPath[s] = True visited[s] = True for t in graph[s]: traverse(graph, t) # 后序遍历位置 postorder.append(s) onPath[s] = False graph = buildGraph(numCourses, prerequisites) # 遍历图 for i in range(numCourses): traverse(graph, i) # 有环图无法进行拓扑排序 if hasCycle[0]: return [] # 逆后序遍历结果即为拓扑排序结果 return postorder[::-1] 二分图判定def __init__(self): # 记录图是否符合二分图性质 self.ok = True # 记录图中节点的颜色，False和True代表两种不同颜色 self.color = [] # 记录图中节点是否被访问过 self.visited = []# 主函数，输入邻接表，判断是否是二分图def isBipartite(self, graph: List[List[int]]) - bool: n = len(graph) self.color = [False] * n self.visited = [False] * n # 因为图不一定是联通的，可能存在多个子图 # 所以要把每个节点都作为起点进行一次遍历 # 如果发现任何一个子图不是二分图，整幅图都不算二分图 for v in range(n): if not self.visited[v]: self.traverse(graph, v) if not self.ok: break return self.ok# DFS 遍历框架def traverse(self, graph: List[List[int]], v: int) - None: # 如果已经确定不是二分图了，就不用浪费时间再递归遍历了 if not self.ok: return self.visited[v] = True for w in graph[v]: if not self.visited[w]: # 相邻节点 w 没有被访问过 # 那么应该给节点 w 涂上和节点 v 不同的颜色 self.color[w] = not self.color[v] # 继续遍历 w self.traverse(graph, w) else: # 相邻节点 w 已经被访问过 # 根据 v 和 w 的颜色判断是否是二分图 if self.color[w] == self.color[v]: # 若相同，则此图不是二分图 self.ok = False return Prim最小生成树import heapqclass Prim: # 核心数据结构，存储「横切边」的优先级队列 def __init__(self, graph: List[List[int]]): self.graph = graph self.pq = [] # PriorityQueueint[] 的实现 self.inMST = [False] * len(graph) # 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分 self.weightSum = 0 # 记录最小生成树的权重和 self.inMST[0] = True # 随便从一个点开始切分都可以，我们不妨从节点 0 开始 self.cut(0) # 不断进行切分，向最小生成树中添加边 while self.pq: # 按照边的权重从小到大排序 edge = heapq.heappop(self.pq) to = edge[1] # 表示相邻节点 weight = edge[2] # 表示这条边的权重 if self.inMST[to]: # 节点 to 已经在最小生成树中，跳过。否则这条边会产生环 continue self.weightSum += weight # 将边 edge 加入最小生成树 self.inMST[to] = True self.cut(to) # 节点 to 加入后，进行新一轮切分，会产生更多横切边 # 将 s 的横切边加入优先队列 def cut(self, s): for edge in self.graph[s]: # 遍历 s 的邻边 to = edge[1] # 相邻的节点 if self.inMST[to]: # 相邻接点 to 已经在最小生成树中，跳过 continue heapq.heappush(self.pq, edge) # 加入横切边队列 # 最小生成树的权重和 def weightSum(self) - int: return self.weightSum # 判断最小生成树是否包含图中的所有节点 def allConnected(self) - bool: for i in range(len(self.inMST)): if not self.inMST[i]: return False return True Dijstra最短路径import heapqfrom typing import List# 假设 graph 是一个邻接矩阵，graph[i][j] 是从节点 i 到节点 j 的距离def dijkstra(start: int, graph: List[List[int]]) - List[int]: V = len(graph) distTo = [float(inf)] * V distTo[start] = 0 pq = [(0, start)] # 使用元组 (distance, node)，以便按照 distance 进行排序 while pq: (dist, curNodeID) = heapq.heappop(pq) if dist distTo[curNodeID]: continue for weight, nextNodeID in graph[curNodeID]: if weight is not None: # 如果两个节点之间有边 distToNextNode = distTo[curNodeID] + weight if distTo[nextNodeID] distToNextNode: distTo[nextNodeID] = distToNextNode heapq.heappush(pq, (distToNextNode, nextNodeID)) return distTo","tags":["算法","Python","蓝桥杯"],"categories":["算法"]},{"title":"Hello World","path":"/2023/01/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":["Hexo"],"categories":["Hexo"]},{"title":"安卓第一次课","path":"/2022/11/19/安卓第一次课/","content":"恭喜大家都还能活到这节课，从现在开始我们进入Android的学习，前面Java没学会的也不要紧，在以后的学习中就能慢慢理解了，接下来开始起飞。 安装Android Studio工欲善其事，必先利其器。在学习之前，这里有份史诗级新手装备待你领取，它叫AS。 和IDEA一样，进入ToolBox下载 打开AS，选择不导入 不向谷歌发送，下一步 先不设置代理，下一步 有梯子的同学可以设置代理 选择标准安装，下一步 选择主题，下一步 下一步，接受条款，下一步 等待下载，然后点击Finish 等待时间较长，觉得慢用流量开热点，这校园网太垃圾！ 安装完成，接下来开始你的第一个APP🎉 注：从AS是纯英文版，汉化插件需要自己去找，不推荐使用汉化，以后的很多文档都是英文的，各位需打好英语基础。 第一个APP 新建一个项目 选择Empty Activity，点击下一步 其他Activity有很多模板代码，我们也用不到 选择Java语言，安卓兼容最低版本为安卓7 目前市场上大部分安卓版本都在安卓7以上，只有小部分还是安卓5，我们不用去管它 等待下载完成 等待时间较长，觉得慢用流量开热点，这校园网太垃圾！ 运行第一个App，点击绿色的三角 Pixel_3a_API_33_x86_64是我们在AS的模拟器 等一会就运行成功了🎉 刚才那个是在模拟器上运行，实际上，我们一般选择用真机调试，因为模拟器上有一些奇怪的bug，而且轻薄本用模拟器会卡🥀 手机打开usb调试，以小米手机为例：连续点击MIUI版本7下，开启开发者选项，打开USB调试 用数据线连接电脑 第一次连接会提示你配对，点确定就好了 然后AS上会显示你的设备 点击绿三角运行 手机上同意通过USB安装应用 你成功在手机上运行了自己的APP🎉🎉🎉 推荐书籍 在此推荐真正的郭神写的书：《第一行代码》第二版（由于该书时间发行较久，可能不好买到一手。群里有 pdf） 别买到蓝色的第三版了 第三版全部用的 kotlin，里面虽然也有一些 kotlin 的语法讲解，但你们目前阶段对于 java 掌握不牢固，不适合去学习 kotlin 书中的坑 由于 Android 一年一个版本，所以书中很多教程到现在都已经很旧了，在此提一些坑 support 导包问题 书中在讲一些导包时都会让你们像上图一样导入 suport 包，目前该包已被官方停止维护，且已经迁移至 androidx 的包。 这是目前的androidx包，报黄的原因是可以升级了，鼠标移过去就可以升级 在这里我建议在代码中直接输入要使用的控件的全名，再使用 Alt + Enter，AS 会自动帮你导包，对于 build.gradle 文件不建议你们修改 例如：导入 RecyclerView 可以直接在代码中写，在选择后 AS 会自动帮你导包 但仍存在部分控件或者依赖 AS 也不知道的情况，这时就需要你们自己谷歌找最新的依赖包了 XML简单介绍 什么是XML XML (eXtensible Markup Language)指可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言。 XML的用途xml被用于信息的记录和传递，因此xml经常被用于充当配置文件。 在Android中，res文件下和manifest使用的是xml语言 XML 仅仅是纯文本XML 没什么特别的，它仅仅是纯文本而已，所以res下的文件需要受到java下的代码调用。 XML的格式 XML 文档第一行以 XML 声明开始，用来表述文档的一些信息 ?xml version=1.0 encoding=UTF-8?site nameRedrock/name urlhttps://redrock.team/url logoredrock.png/logo desc红岩网校工作站/desc/site 、、、 分别为标签，标签内包含了要传递的信息。 标签必须成对出现，有开始标签就需要有结束标签，例如：开始标签：**** 和 结束标签：**** 标签是有层级的，必须正确的嵌套； 标签区分大小写； xml属性值必须加引号，例 TextView android:layout_width=wrap_content android:layout_height=wrap_content / Android 项目结构 Android 与之前 Java 的一个项目相比复杂了许多，下面我们先简单认识一下。 结构视图有Project和Android两种，Project就是以文件夹的形式展示，Android是编译后更方便的一种展示。 谷歌爸爸为了使我们的应用更好开发，把代码与视图进行了分层，主要的结构视图如下：（在 Android 视图下)： java下面写我们的逻辑代码，就和以前我们在src里写的一样 res是写布局代码，包括一些图片，布局，主题，颜色等等。 gradle是项目构建，目前我们不用管 manifests 用来放 AndroidManifests.xml 简称“注册文件” 注：但由于Android12的问题，目前需要在启动的 activity 的标签新加一句android:exported”true”，它的作用是：是否支持其它应用调用当前组件 java你的所有用于控制视图的代码都在这里 第一个包就是你的源代码 java 文件，后面两个包是有关测试的，不用去了解，之后的个人开发也不会用到他们，网校开发也没有用到 res用于放视图和资源文件 drawable用于放图片资源以及 xml 类型的图片 layout用于放应用中每个界面的地方 mipmap这里只用来放应用的桌面图标的（注：这里一般不是用来放应用内部图片或者图标的，该文件夹一般不用） values用于放一些引用的文字或者颜色等杂东西 认识HelloWorld 相信各位都想自己开始动手改写 HelloWorld，但一打开 java 代码却傻了眼，这都是些什么鬼？ java 代码讲解 你一看MainActivity继承于 AppCompatActivity，然后点进去一看，666 行的英文，什么也看不懂。 其实不用管这么多，就跟你们开始学习 java 一样，只要记住之前的 main() 是整个程序的入口，在 Android 中这个入口“变成了” onCreated() （其实入口并不是它）以后代码就 “全” 写在 onCreated() 中就可以了（别真的把代码全写在一个函数中了！） 关键语句 setContentView()细心的你肯定能发现除了 super.onCreate() 外，他还自己多写了一个 setContentView(R.layout.activity_main)。 setContentView 字面意思就是：设置内容视图前面我们讲过 Android 将 视图 与 代码 进行了分离，而这就话就是将视图与代码进行判定，其中 R.layout 是一种固定写法，用于引用 layout 文件夹中的文件（tips: 同理，R.drawable 表示引用 drawable 文件夹中的图片） layout 中的 XML 点击 activity_main 后肯定更懵逼了，这又是写的什么？（555，我还是退学吧！） 目前可以死记住需要这样写即可 但我还是给大家简单梳理下： 其中 2 ~ 8 行是一体的（严格来说还包括第19行），描绘了一个在 androidx.constraintlayout.widget 下一个叫 ConstraintLayout 的控件的行为（何为控件？后面会讲） 同理，这个是一个名字叫 TextView 的控件 其中第 13 行有一个 “Hello World!”，我们把他改成 “Hello RedRock！”，再打包运行一下，你就会发现应用的字变成了 “Hello Redrock！” 简单的认识了HelloWorld后，我们接下来进行更细致的讲解 视图的基本单位——控件 控件中分为单一的，用于与用户交互的控件 (View) 和 负责布局的控件 (ViewGroup) View 常用的 ViewTextView一个用于显示文本的控件 自身属性 作用 android:text 设置显示的文字 android:textSize 设置字体大小 android:textStyle 设置字体样式（只有加粗和斜体） android:fontFamily 设置文字的字体 app:drawableStartCompat 设置文字左边的图片（类似的可以把 Start 换成 Top、Bottom、End） 如果要设置一个图片在 TextView 旁边，尽量使用 app:drawableStartCompat 属性，而不是写一个 ImageView 在旁边 Button一个与用户进行交互的按钮（注意：并不是只有 Button 可以点击，所有的 View 都可以设置点击监听） 自身属性 作用 所有 TestView 的属性 因为 Button 是直接继承于 TestView 的，所以拥有所有 TestView 的属性 EditText一个与用户进行交互的输入控件 自身属性 作用 所有 TestView 的属性 因为 EditText 也是直接继承于 TestView 的，所有拥有所有 TestView 的属性 android:hint 设置提示文字 android:textColorHint 设置提示文字颜色 android:inputType 设置输入的类型 android:digits 设置值接受指定的文本内容 android:lines 设置显示行数 android:maxLines 设置最大显示行数 （简单提一句：其实后面几个属性也不是 EditText 独有的） ImageView一个显示图片的控件 属性 作用 android:src 设置（前景）图片 android:scaleType 设置当图片与控件大小不一致时缩放模式 如何添加图片： 普通图片 直接将图片放到resdrawable目录下即可 矢量图 推荐一个矢量图网站：阿里巴巴矢量图标库，里面有很多好看的图标，而且是免费的。 先下载SVG图片，保存到你自己能找到的地方 在res文件夹下新建一个Vector Asset 选择加载本地资源，找到你的图片 调整一些参数 完成 补充书没有的内容scaleType推荐博客：scaleType 的使用 一般使用 centeInside 模式，当 size 大于 ImageView 的图片进行等比例缩小，小于 ImageView 的图片不变，直接居中显示。（当不写该属性时，默认是 fitCenter 意思是当 size 大于 ImageView 的图片进行等比例缩小，小于 ImageView 的图片进行等比例放大，直接居中显示） ShapeableImageView如果想实现圆头像或者其他样式的头像，可以试试这个控件 推荐博客：ShapeableImageView 的使用 常用属性android:layout_margin 与 padding初学者往往会搞不懂这两个的含义 其中 layout_margin 是以父布局为参考系，设置外部边距 **padding **是以自身为参考系设置设置内部子 View 或者文本等边距 android:background设置背景（与 ImageView 的 android:src 不同，src 是设置前景，可以选择缩放模式，而 background 是设置背景，是直接强行拉伸或者压缩图片） Material组件库Material Design 是由Google开发设计，扩展于Google即时的“卡片”设计，材质设计基于网格的布局、响应动画与过渡、填充、深度效果（如光线和阴影）。 Material官网 Github地址 强烈建议你们下载下来，里面有很多好看的控件，直接拿来用。 ViewGroup ViewGroup 被翻译成容器，他的作用就是用来装 TextView、Button 这些控件的 基础 ViewGroup以下简单讲解你们现阶段会用到的 ViewGroup，由于《第一行代码》中有关于这些的演示和讲解，所以这次课我更多的是进行实践操作 LinearLayout页数：《第一行代码》P94页 该布局在入门阶段最常用 自身属性 作用 android:orientation 设置排列方向 子控件属性 作用 android:layout_gravity 设置子控件在父控件中的位置 android:layout_weight 设置子控件在父控件中的比重 子控件属性？父布局可以额外添加子控件的属性的，其中有个明显的特点就是，属性都以 layout_ 开头. RelativeLayout 页数：《第一行代码》P100页 该布局不常使用，跳过 FramLayout页数：《第一行代码》P103页 该布局在入门阶段一般不用，跳过（一般在自定义 View 中用的多，通过继承它来实现自己的控件） CardView页数：《第一行代码》P431页 该布局后期很常用，这里做一些补充 自身属性 作用 app:cardCornerRadius 设置圆角 app:elevation 设置阴影厚度（也指 Z 轴高度） app:cardBackgroundColor 设置背景颜色（注意：该控件使用 android:background 来改变背景颜色是无效的，需要换成左边这个属性） app:cardPreventCornerOverlap 显示完整阴影（如果你的阴影厚度较厚，你会发现你的阴影只显示了部分，使用该属性可以将阴影显示完整） app:contentPadding 设置内容的 poadding（间距），除此之外还有app:contentPaddingLeftRightTopBotom 用于复杂布局时的 ConstraintLayout该布局为最常用布局，而且现在AS默认的布局就是ConstraintLayout布局，只需要简单的一拖一拉，就能实现比 LinearLayout、RelativeLayout 更强大的效果。 这里直接推荐看博客内容：约束布局 也许你们觉得写这些好麻烦，其实，这些多用即便就记住了，还有就是我们可以直接使用 XML 中的 Design 窗口用鼠标来拖动，具体的使用会在课上演示 常用属性android:gravity 部分 ViewGroup 拥有该属性，用于设置子控件的重心 控件这么多的属性我该怎么记？ 其实你根本不用记住，直接照书抄就是了，后面你想找某个属性，推荐先去 Android 官网（点我进官网，就是你下 AS 的地方）找找，再去百度看他的用法，只要你用得多了，自然而然就记住这些属性了 其他 命名规范id 命名规范 具体可参考群里的《阿里巴巴Android开发手册》 除此之外，还有如下命名规范： 【模块名】_【控件】_【界面位置】_【作用】 模块名：目前你们还设计不到模块相关，可以不用写 控件名：常见的控件可采用首字母缩写的形式，自定义控件和不常用的建议全写 界面位置：简单的描述是哪个界面，如下图的 stamp_detail 表示邮票详细界面（可以加上 activity、fragment、item 等字眼用于表示控件所在的容器） 作用：如果当前界面相同控件过多，强烈建议加上作用 大致以上面这样来写 id，这样更利于快速查找，也会让之后的学弟不会对你的代码留下什么印象 : ) 控件对象命名规范 虽然是 kt 写得，但各位应该能看懂 【控件缩写】+【作用】 这里提一句，为什么以 m 开头，因为 Android 官方推荐类中的成员变量以 m 开头，你几乎可以在 Android 官方源码中都能发现这种写法，建议遵守官方规范 现搓一个登录界面 光听这些估计很无聊，接下来我将现搓一个登陆界面，写登录界面是这次作业中的 Lv2，各位可以用心听一下 布局代码?xml version=1.0 encoding=utf-8?androidx.constraintlayout.widget.ConstraintLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:app=http://schemas.android.com/apk/res-auto xmlns:tools=http://schemas.android.com/tools android:layout_width=match_parent android:layout_height=match_parent tools:context=.MainActivity ImageView android:id=@+id/img_main_head android:layout_width=100dp android:layout_height=100dp android:layout_marginTop=128dp android:src=@drawable/cqupt app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toTopOf=parent / EditText android:id=@+id/et_main_username android:layout_width=300dp android:layout_height=wrap_content android:layout_marginTop=64dp android:drawableStart=@drawable/ic_baseline_account_box_24 android:hint=账号 android:inputType=number android:lines=1 app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/img_main_head / EditText android:id=@+id/et_main_password android:layout_width=300dp android:layout_height=wrap_content android:layout_marginTop=16dp android:digits=0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ?!=+-_., android:drawableStart=@drawable/ic_baseline_vpn_key_24 android:hint=密码 android:inputType=textPassword android:lines=1 app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/et_main_username / Button android:id=@+id/btn_main_login android:layout_width=wrap_content android:layout_height=wrap_content android:layout_marginTop=64dp android:text=登录 app:layout_constraintEnd_toEndOf=parent app:layout_constraintStart_toStartOf=parent app:layout_constraintTop_toBottomOf=@+id/et_main_password //androidx.constraintlayout.widget.ConstraintLayout Activity代码public class LoginActivity extends AppCompatActivity private ImageView mImgHead; private EditText mEtUsername; private EditText mEtPassword; private Button mBtnLogin; @Override protected void onCreate(Bundle savedInstanceState) super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); initView(); initLogin(); /** * 写一个方法专门用于初始化 View */ private void initView() mImgHead = findViewById(R.id.img_main_head); mEtUsername = findViewById(R.id.et_main_username); mEtPassword = findViewById(R.id.et_main_password); mBtnLogin = findViewById(R.id.btn_main_login); /** * 专门用于登录的方法 */ private void initLogin() mBtnLogin.setOnClickListener(new View.OnClickListener() @Override public void onClick(View v) login(); ); /** * 执行登录操作 */ private void login() String username = mEtUsername.getText().toString(); String password = mEtPassword.getText().toString(); if (username.equals(123456) password.equals(123456)) loginSuccess(username, password); else loginFailure(); /** * 登录成功的方法 */ private void loginSuccess(String username, String password) Toast.makeText(this, 登陆成功!, Toast.LENGTH_SHORT).show(); MainActivity2.startActivity(this, username, password); /** * 登录失败的方法 */ private void loginFailure() Toast.makeText(this, 账号或者密码好像输错了 :(, Toast.LENGTH_SHORT).show(); private long mExitTime = 0L; /** * 以下为连按两次才能退出 */ @Override public boolean onKeyDown(int keyCode, KeyEvent event) if (keyCode == KeyEvent.KEYCODE_BACK) /* * 当当前时间大于上次按返回键的时间 2 秒时 */ if (System.currentTimeMillis() - mExitTime 2000) Toast.makeText(this, 再按一次退出程序, Toast.LENGTH_SHORT).show(); mExitTime = System.currentTimeMillis(); return false; return super.onKeyDown(keyCode, event); 再写一个 Activity这就写完了？这也太简单了吧，简直有手就行。接下来我们给这个界面加上登录后的跳转 intent 跳转页数：《第一行代码》P41 ~ P43 只需要使用显示 Intent 就可以了，就两行代码 Intent intent = new Intent(this, MainActivity.class);startActivity(intent); 对于 Intent 的正确写法（以下为扩展内容，听不懂没事） 如果我们要传入一些数据给 ContentActivity 时，一般我们会在 MainActivity 直接这样写 Intent intent = new Intent(this, ContentActivity.class);intent.putExtra(username, username);intent.putExtra(password, password);startActivity(intent); 这样写确实很方便，也没有什么问题 但在之后的开发中，我们更推荐将启动事件交给要启动的类来处理，这样可以实现类与类之间的解耦合 应该在 MainActivity2 中写一个 static 的方法用于启动自己，让它来决定你该传入什么数据才能启动它 public class MainActivity2 extends AppCompatActivity private static final String INTENT_USER_NAME = username; // intent 中的数据标记 private static final String INTENT_PASSWORD = password; // intent 中的数据标记 /** * 写一个 static 方法，让它来决定该传入那些数据 */ public static void startActivity(Context context, String username, String password) Intent intent = new Intent(context, MainActivity2.class); intent.putExtra(INTENT_USER_NAME, username); intent.putExtra(INTENT_PASSWORD, password); context.startActivity(intent); @Override protected void onCreate(Bundle savedInstanceState) super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Intent intent = getIntent(); String mUserName = intent.getStringExtra(INTENT_USER_NAME); String mPassword = intent.getStringExtra(INTENT_PASSWORD); 那么在 LoginActivity中可以直接一行代码启动 MainActivity2 MainActivity2.startActivity(this, username, password); 这样的写法在写大项目时是必须遵守的，写在这里只是为了让你们提前知道有这个规范 补充启动界面注册文件改默认启动 页数：《第一行代码》P35 最底部 intent-filter\taction android:name=android.intent.action.MAIN /category android:name=android.intent.category.LAUNCHER //intent-filter 上面这一行代码就是设置启动 Activity 的 只需要把它改到你想设置的 Activity 里，在Android12中，默认启动activity必需要设置android:exported=true Activity 的 finish() 方法页数：《第一行代码》P40 最底部 调用该方法会直接销毁当前 Activity，并移出 Activity 栈（Activity 栈的概念可以看书 P53） 扩展内容Activity 是什么？相信在写了上面懵懵懂懂的代码后，你也对 Activity 有了一个初步的认识。 如果说 XML 布局是应用的外表，那么 Activity 就是应用的内核，用于控制 XML(外表) 实时变化，达到与用户交流的目的 其中一个 Activity 掌管了一个对应的 XML 布局，XML 布局中的控件，都可以使用 findViewById() 这个方法转换成对应的一个对象，然后 Activity 就可以直接调用这些对象自带的方法用于设置一些属性 Activity 启动模式页数：《第一行代码》P63 这东西平时不会经常用到，使用也很简单，你们下去看一下书就能理解了。主要用于使用返回键退出当前 Activity 或者 Activity 互相启动时会用到 Fragment 页数：《第一行代码》P142 Fragment 可以理解为一个小型的 Activity，它也可以向 Activity 一样，与 XML 视图进行一对一绑定，但它必须寄生于一个 Activity 中，不能独立存在 不讲内容 该部分内容对于你们目前阶段难以理解，故写在这里，现在只作了解即可，之后会再来详细讲解 Activity 生命周期 页数：《第一行代码》P53页 下学期会进行更深入的讲解，再加上目前你们涉及不到这个，所以就不写这个了 Fragment 生命周期 页数：《第一行代码》P151 与 Activity 生命周期类似，这节课也不会讲解该内容 FragmentManger 页数：《第一行代码》P147 Activity 中 Fragment 的管理者 补充问题设置字体大小 AS默认的字体有点小，我们设置一下 窗口字号设置File - Settings - Appearance 注意：这个只能设置除代码外的字体大小，也就是窗口字体大小 代码字体设置File - Settings - Editor - Font 这里才是设置代码字体大小的地方 Ctrl + 滑轮 设置代码字号File - Settings - Editor - General 开启 Ctrl + 滑轮设置字体大小很有用 快捷键设置 相信在写 java 中直接输 sout 而感到十分方便，其实这些都是可以自己去设置的 下面给出一个可以快捷打出 Log.d 的快捷键的设置方式 打开设置 基本设置 android.util.Log.d(TAG,($class$:$line$)--);// TAG: 换成你自己想设置的 tag（用于过滤 Log，快速找到）// $class$、$line$: 固定写法 设置属性 设置语言 OK，接下来你可以在代码中直接输入 “ld” 然后回车，实现 sout 一样的效果 经过了这个教程后，相信你也可以设置其他快捷键了. 推荐插件 装上一些插件可以很大部分上提高我们工作效率，在这里分享给大家几个插件 插件在这里下载： Translation 一个很好用的翻译插件，对于英文注释来说可以直接翻译成中文 使用方式：选中英文后直接 Ctrl + Shift + Y，也可以直接翻译文档 注：谷歌翻译停止中国访问，该服务需要梯子，或者使用替他翻译引擎。 如果挂了梯子还显示这个就需要设置代理 这里可以替换其他搜索引擎 Rainbow Brackets 括号总是白色，太难找到对应？试试这款插件，让你代码中的括号充满色彩！ 如何打包 当手机装上了你自己的App，你也想分享给其他小伙伴一起使用，可是当你发现通过qq发送给别人的时候，他们安装不了，因为我们手机是通过AS直接装的，不是正式的apk。 打开Build - Generate Signed Bundle APK… 选择apk，点击next 创建签名文件 生成 apk 需要签名文件，这个签名文件主要是用于检测当前 apk 是否已经被修改。比如你通过反编译修改了我的 apk，那么签名文件就会被破坏，其他人就可以通过签名文件来判断是否被修改 选择relsase包 查看apk AS彻底卸载 时间长了AS会出现一些奇怪的问题，我们就需要彻底卸载AS了 在设置里卸载AS 打开下面这个路径，删除所有与 AS 有关的即可 C:\\Users\\WhiteNight\\AppData\\Roaming\\Google 注1：图中的 “WhiteNight” 是电脑的用户名，打开你自己的用户目录 注2：其中 “AppData” 为隐藏文件夹，自己打开显示隐藏文件夹即可找到 如果你想弃坑 Android 了 ，就可以把 gradle 删了🥀 更改gradle路径 AS下载的gradle路径是在C盘的（如上图），到了后期gradle文件会越来越大，C盘会爆满，我们将它移到其他盘 1.打开“系统高级设置”，选择“环境变量” 找到GRADLE_USER_HOME 选择你想存放的地方 确定保存 梯子的问题github和goole需要梯子，搞计算机的，梯子是必不可少的，你们可以自己去找梯子，也可以私下找我们。 设置代理 如果你有梯子的话可以给AS设置代理，这样可以在AS里访问外网（例如谷歌翻译） 打开设置，找到HTTP Proxy，选择手动代理设置，方式选择HTTP，地址默认就是127.0.0.1,端口号可以到Windows的设置-网络和Internet-代理-手动代理设置-编辑，点击编辑就能看到端口号了 总结本节课我们主要学习了Android Studio的使用，掌握了一些常用控件和布局，对Activity也有了一些认识。 在经历了这半学期的学习后，相信你们从网校这里学习到了很多，还记得开始入群时有500多人，到现在只有少数人在活跃，希望在接下来的路，你们能坚持走完，最后回头来看你会感谢如今的自己。","tags":["Android"],"categories":["Android"]},{"title":"Android学习清单","path":"/2022/09/29/Android学习/","content":"Android学习清单 寒假学习路线 按照传统，寒假考核不能使用非官方库，所以以下内容不包含第三方库 难度：kotlin 框架 自定义View 1、kotlin 可以买《第一行代码》第三版进行学习，上面附带讲解了 kotlin 的使用 注意： kotlin 并不是寒假必须学习的内容，寒假仍能使用 java 来写。在下学期开学会给你们几周的时间来学习（自学，我们不会教），所以可以跳过先学下面的 2、框架相关 框架方面比较深奥难懂，建议去GitHub上搜索 wanAndroid 项目阅读一下别人写的源码，不然光看博客的解释不动手操作，是很难理解框架的使用的 2.1、MVP 虽然后期Android开发都是使用的MVVM，但MVVM是MVP的演化版，MVP还是值得去看一看的 2.2、MVVM Android官方推荐架构（但目前在向 MVI 演化了），需要与 LiveData、ViewModel 配合使用 2.2.1、ViewModel ViewModel 主要与生命周期相关，生命周期这概念需要你们多写代码才能彻底理解，可以不急着去彻底学懂 2.2.2、LiveData 寒假期间搞清楚怎么用即可，主要是配合MVVM中的网络层进行回调 2.2.3、DataBinding 目前 DataBinding 有一些奇怪的bug，我们一般把他当成了 ViewBinding 在用 3、自定义View与滑动冲突 自定义 View 方面比较难且耗时间，如果你有想实现的一些复杂控件，可以来看看这一块（比如写一个转动的风车） 3.1、自定义View 点击跳转自定义View 3.2、滑动冲突 滑动冲突是设计自定义View必会的 点击跳转滑动冲突 4、自己撸后端（不推荐） 不是很推荐，光是 Android 的知识你都学不完，当然，卷王除外 大一下及以后学习路线 东西有些多，其实学长我们好多都没学过😂 1、必须内容1.1、kotlin1.2、四大组件 除掉 ContenProvder 可不用学习 ActivityServiceBroadcast 1.3、Rxjava的使用1.4、Retrofit的使用 与Rxjava配套使用与协程配套使用 1.5、Room的使用 与Rxjava配套使用与协程配套使用 1.6、MVVM + ViewModel + LiveData + DataBinding + Retrofit + Rxjava + Room 这是掌邮目前的框架，市面上的大部分应用应该都是类似于这样设计的 以下是对于 Android 之后发展的推测（仅代表个人观点）： Rxjava 与 协程 大概率会共存，因为 Rxjava 适合处理复杂数据流，协程更适合一般使用 LiveData 有几率会被 Flow 代替，但 LiveData 更简便，适用于大部分需求 XML View 与 Compose 以后应该会共存（个人认为各有各的优势） 还有现在谷歌开始推荐 MVI 架构了（靠，谷歌真的是要累死我们开发者） 2、扩展内容 学长们不讲或讲不细的自学内容推荐学习软件：稀土掘金推荐大佬文章：https://github.com/leavesC/AndroidGuide 2.1、Material Design 这里面很多便捷的控件及用法，比如：TabLayout 直接添加小圆点、共享元素动画等 推荐直接看官网：https://material.io/ 推荐去打包他的源码：源码（虽然源码没写注释，但想实现某个功能时可以去看看是否已经有实现了的） 2.2、线程池 线程池作业：https://github.com/985892345/Android_Learning_Route/blob/main/线程池作业.md 阻塞队列 使用LinedList实现阻塞队列 仿写CacheThreadPool等java自带的几个线程池 2.3、RecyclerView高阶用法 RecyclerView进阶作业：https://github.com/985892345/Android_Learning_Route/blob/main/RecyclerView进阶作业.md 1、点击事件不要写在onBindViewHolder中2、实现侧滑删除、长按移动Item（这些官方都有封装好的接口）3、notifyItemChanged ( position：Int, paylosd：Any? ) 这是两个形参的刷新，后面有一个单独的参数 paylosd: Any? 该方法与 onBindViewHolder(holder, position, payloads) 三个参数的回调有关系 补充内容 刷新时图片 rv 的图片会闪动 该问题与 rv 的缓存有关，因为在刷新时这个 ViewHolder 与缓存中进行了互换，相当于重新加载了图片 解决办法：调用带有 paylosd 参数的刷新，取消与缓存的互换 4、差分刷新 DiffUtil DiffUtil 中也有一个可重写的方法，其中带有 paylosd 参数 注： 网上部分博客的差分比较有些问题，尽量自己搞懂原理（不是算法原理，而是究竟该比较什么数据才会是真正的差分，尤其是 areItemsTheSame 方法） 2.4、自定义View 自定义View预习作业：https://github.com/985892345/Android_Learning_Route/blob/main/自定义View预习作业.md 自定义View课件：https://github.com/985892345/CustomViewWithAnimStudy 推荐： 入门：《Android自定义控件开发入门与实战》 进阶：《Android自定义控件高阶进阶与精彩实例》 博客：自定义View源码原理 1、onLayout2、onMearsure3、onDraw4、动画你需要知道的其他知识： View.postpostdelay()方法如何在activity得到控件的宽和高 可以做的实例 流式布局 2.5、滑动冲突 普通滑动 推荐： 博客：图解事件分发dispatchTouchEvent源码解析 图片：郭祥瑞的滑动分发分支图 dispatchTouchEventonInterceptTouchEventonTouchEventrequestDisallowInterceptTouchEvent 嵌套滑动 推荐： 博客：图解嵌套滑动 NestedScrollingParent和NestedScrollingParent2 NestedScrollingChild2官方文档 NestedScrollingChild和NestedScrollingChild2 NestedScrollingParent2官方文档 题外话：为什么还要看1，不直接看2？因为部分官方控件中只使用了1，所以你要知道1和2的区别。还有一个3，这个3在网上的教程较少，直接继承了2，新增了在嵌套滑动中只消耗部分值的方法。NestedScrollingParent3官方文档 与设计多层自定义View时的使用 建议自己写一些复杂自定义View，包含单击、滑动等一系列事件 可参考郭祥瑞写的 TimeSelectView 控件(按照 README导入简单使用一下，源码写的很拉，在重写了😫，这里直接给出软件下载地址，下载后自己试着想想该怎么设计: https://wwi.lanzouo.com/iC1JGy08a0h 简单看看View和ViewGroup中滑动源码可以做的实例 下拉刷新（可参考 SmartRefreshLayout，也可以把上拉加载一起实现） 2.6、协调者布局CoordinatorLayout 学习它需要知道嵌套滑动 高阶用法自定义 Behavior 2.7、仿写Glide 1、实现三级缓存 2、搞懂它为什么能根据 View 的生命周期而自动取消加载图片（他可没有使用 Lifecycle 这个东西） 3、改用 Lifecycle 实现 2.8、仿写Okhttp 尝试实现拦截器 仿写Gson 2.9、仿写Rxjava 就算你没时间仿写它，也必须把它用熟，因为它的思想很重要 2.10、仿写EventBus 但不建议使用，此框架因过于灵活，会像goto一样造成滥用而难以溯源 2.11、MotionLayout 有很多自定义View难实现时用这个来写很简单 推荐谷歌官网：https://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn 3、其他内容 学习成本过高或目前阶段不够或目前不使用 3.1、设计模式 有几个简单的还是自己要提前了解下 3.2、协程原理 推荐文章：https://openxu.blog.csdn.net/article/details/116016798 推荐21级红岩学长蔷神的心得体会：https://github.com/False-Mask/KotlinCoroutine 3.3、Navigation 目前还有些坑，官方还在改进中，掌邮中也不使用 3.4、RecyclerView 滑动事件源码LayoutManger多级缓存 3.5、paging3 不是2和1 3.6、使用注解实现一些骚操作3.7、gradle的使用3.8、hilt依赖注入3.9、jvm3.10、Compose3.11、Flow3.12、ARouter的使用3.xx 别卷了，别卷了！……","tags":["Android"],"categories":["Android"]},{"title":"关于","path":"/about/index.html","content":"🔭 I am currently studying in CQUPT and will soon go to Zhejiang University. 🌱 I am familiar with Python and C++. 👯 I know about computer networks, data structures, operating systems and deep learning. ⚡ Fun fact: mobile and algorithm 📫 How to reach me: Email:","tags":[null],"categories":[null]},{"title":"友链","path":"/friends/index.html","content":"红岩网校 EmNets 掌上重邮","tags":[null],"categories":[null]}]